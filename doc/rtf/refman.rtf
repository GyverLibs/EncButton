{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment EncButton  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3.5 \par
}}EncButton}
{\comment Generated by doxygen 1.9.8.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt EncButton}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 3.5\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\par \pard\plain 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Todo List\par \pard\plain 
{\tc\tcl1 \v Todo List}
{\xe \v Todo List}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b VirtEncButton::action}  ()\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
todo in binary switch case block e_state + b_state and EB_HOLD + EB_TURN verification if ((state & EB_HOLD) && (state & EB_TURN_R)) return EB_TURN_HOLD_R; \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
VirtButton\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Button\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ButtonT< PIN >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
VirtEncButton\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
EncButton\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EncButtonT< ENCA, ENCB, BTN >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
VirtEncoder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Encoder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EncoderT< ENCA, ENCB >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
VirtEncButton\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Button} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a button that extends the {\b VirtButton} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ButtonT< PIN >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EncButton} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class that represents an encoder button })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EncButtonT< ENCA, ENCB, BTN >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Encoder} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Encoder} device })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EncoderT< ENCA, ENCB >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VirtButton} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VirtEncButton} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a virtual encoder button })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VirtEncoder} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a virtual encoder. This class provides methods to set the encoder's properties, attach_call callback functions for handling encoder events, and poll the encoder for rotation and direction })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b src/{\b EncButton.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/core/{\b Button.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Button} class for handling button presses and debouncing })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/core/{\b EncButton.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EncButton} class for handling rotary encoder with button })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/core/{\b Encoder.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Encoder} class for handling rotary encoder })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/core/{\b utils.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/core/{\b utils.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utility functions for handling pins and flags })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/core/{\b VirtButton.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VirtButton} class for handling virtual buttons })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/core/{\b VirtEncButton.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual encoder button class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/core/{\b VirtEncoder.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual encoder class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Button Class Reference\par \pard\plain 
{\tc\tcl2 \v Button}
{\xe \v Button}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a button that extends the {\b VirtButton} class. }}\par
{
{\f2 #include <Button.h>}}\par
Inheritance diagram for Button:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/d03/class_button.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Button} ({\b uint8_t} {\b npin})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b Button} object with the specified pin number. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ({\b uint8_t} {\b npin}=0, {\b uint8_t} {\b mode}={\b INPUT_PULLUP}, {\b uint8_t} {\b btnLevel}={\b LOW})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the button with the specified pin, mode, and button level. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the raw pin state for this button instance. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the button state and updates the internal state machine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the raw pin state for this button instance and updates the internal state machine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setHoldTimeout} ({\b uint16_t} {\b timeout}=600)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setStepTimeout} ({\b uint16_t} {\b timeout}=200)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setClickTimeout} ({\b uint16_t} {\b timeout}=500)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setDebounceTimeout} ({\b uint8_t} {\b timeout}=50)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setBtnLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b pressISR} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clear} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b detach_call} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b press} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b release} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b click} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressing} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b getSteps} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b waiting} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b busy} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b timeout} (uint16_t tout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b pressFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b holdFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holdFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b stepFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b stepFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b VirtButton} &{\b b0}, {\b VirtButton} &{\b b1})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setButtonLevel} ({\b bool} {\b level})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b clicks}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pollBtn} ({\b bool} {\b s})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b eq_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b const} {\b uint16_t} {\b y}) {\b __attribute__}(({\b always_inline}))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b run_timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} = {\b nullptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_DEB_T} = 50\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_CLICK_T} = (500 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_HOLD_T} = (600 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_STEP_T} = (200 >> {\b EB_SHIFT})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a button that extends the {\b VirtButton} class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Button} class provides functionality to read the state of a button, update the internal state machine, and perform initialization. \par
}{
Definition at line {\b 20} of file {\b Button.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Button\:Button}
{\xe \v Button\:Button}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Button::Button ({\b uint8_t}  {\i npin})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b Button} object with the specified pin number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i npin} \cell }{The pin number to which the button is connected. \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:Button}
{\xe \v Button\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtButton::action (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action corresponding to the current flag combination.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The action corresponding to the current flag combination. \par
}}}{
Definition at line {\b 246} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00246                         \{\par
00247         {\cf19 switch} (flags & 0b111111111) \{\par
00248             {\cf19 case} (B_PRS | B_PRS_R):\par
00249                 {\cf19 return} EB_PRESS;\par
00250             {\cf19 case} (B_PRS | B_HLD | B_HLD_R):\par
00251                 {\cf19 return} EB_HOLD;\par
00252             {\cf19 case} (B_PRS | B_HLD | B_STP | B_STP_R):\par
00253                 {\cf19 return} EB_STEP;\par
00254             {\cf19 case} (B_REL | B_REL_R):\par
00255             {\cf19 case} (B_REL | B_REL_R | B_HLD):\par
00256             {\cf19 case} (B_REL | B_REL_R | B_HLD | B_STP):\par
00257                 {\cf19 return} EB_RELEASE;\par
00258             {\cf19 case} (B_REL_R):\par
00259                 {\cf19 return} EB_CLICK;\par
00260             {\cf19 case} (B_CLKS_R):\par
00261                 {\cf19 return} EB_CLICKS;\par
00262             {\cf19 case} (B_REL_R | B_HLD):\par
00263                 {\cf19 return} EB_REL_HOLD;\par
00264             {\cf19 case} (B_CLKS_R | B_HLD):\par
00265                 {\cf19 return} EB_REL_HOLD_C;\par
00266             {\cf19 case} (B_REL_R | B_HLD | B_STP):\par
00267                 {\cf19 return} EB_REL_STEP;\par
00268             {\cf19 case} (B_CLKS_R | B_HLD | B_STP):\par
00269                 {\cf19 return} EB_REL_STEP_C;\par
00270             {\cf19 default}:\par
00271                 {\cf19 return} EB_NONE;\par
00272         \}\par
00273     \}\par
}
}
{\xe \v attach_call\:Button}
{\xe \v Button\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::attach_call ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 137} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                           \{ \par
00138 {\cf21 #ifndef EB_NO_CALLBACK}\par
00139         {\cf19 if} (callback_func == {\cf17 nullptr} || cb) {\cf19 return} {\cf17 false};\par
00140         cb = *callback_func;\par
00141         {\cf19 return} {\cf17 true};\par
00142 {\cf21 #endif}\par
00143         {\cf19 return} {\cf17 false};\par
00144     \}\par
}
}
{\xe \v busy\:Button}
{\xe \v Button\:busy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::busy (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 237} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00237                 \{\par
00238         {\cf19 return} read_btn_flag(B_BUSY);\par
00239     \}\par
}
}
{\xe \v clear\:Button}
{\xe \v Button\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clear (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00122                  \{\par
00123         {\cf19 if} (read_btn_flag(B_CLKS_R)) clicks = 0;\par
00124         {\cf19 if} (read_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R)) \{\par
00125             clr_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R);\par
00126         \}\par
00127     \}\par
}
}
{\xe \v click\:Button}
{\xe \v Button\:click}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::click (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00162                  \{\par
00163         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD, B_REL_R);\par
00164     \}\par
}
}
{\xe \v clr_btn_flag\:Button}
{\xe \v Button\:clr_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clr_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 503} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00503                                                                               \{\par
00504         flags &= ~x;\par
00505     \}\par
}
}
{\xe \v detach_call\:Button}
{\xe \v Button\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::detach_call (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00147                        \{\par
00148 {\cf21 #ifndef EB_NO_CALLBACK}\par
00149         cb = {\cf17 nullptr};\par
00150 {\cf21 #endif}\par
00151     \}\par
}
}
{\xe \v eq_btn_flag\:Button}
{\xe \v Button\:eq_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::eq_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b const} {\b uint16_t}  {\i y}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 513} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00513                                                                                                \{\par
00514         {\cf19 return} (flags & x) == y;\par
00515     \}\par
}
}
{\xe \v getClicks\:Button}
{\xe \v Button\:getClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::getClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                         \{\par
00203         {\cf19 return} clicks;\par
00204     \}\par
}
}
{\xe \v getSteps\:Button}
{\xe \v Button\:getSteps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::getSteps (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00206                         \{\par
00207 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00208 {\cf21 #ifdef EB_STEP_TIME}\par
00209         {\cf19 return} run_timer ? ((stepFor() + EB_STEP_T - 1) / EB_STEP_T) : 0;  \par
00210 {\cf21 #else}\par
00211         {\cf19 return} run_timer ? ((stepFor() + (EB_STEP_T << EB_SHIFT) - 1) / (EB_STEP_T << EB_SHIFT)) : 0;\par
00212 {\cf21 #endif}\par
00213 {\cf21 #endif}\par
00214         {\cf19 return} 0;\par
00215     \}\par
}
}
{\xe \v hasClicks\:Button}
{\xe \v Button\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00194                      \{\par
00195         {\cf19 return} eq_btn_flag(B_CLKS_R | B_HLD, B_CLKS_R);\par
00196     \}\par
}
}
{\xe \v hasClicks\:Button}
{\xe \v Button\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00198                                 \{\par
00199         {\cf19 return} clicks == num && hasClicks();\par
00200     \}\par
}
}
{\xe \v hold\:Button}
{\xe \v Button\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                 \{\par
00171         {\cf19 return} read_btn_flag(B_HLD_R);\par
00172     \}\par
}
}
{\xe \v hold\:Button}
{\xe \v Button\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00174                            \{\par
00175         {\cf19 return} clicks == num && hold();\par
00176     \}\par
}
}
{\xe \v holdFor\:Button}
{\xe \v Button\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::holdFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the duration for which the button has been held.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds. \par
}}}{
Definition at line {\b 313} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                        \{\par
00314 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00315         {\cf19 if} (read_btn_flag(B_HLD)) \{\par
00316 {\cf21 #ifdef EB_HOLD_TIME}\par
00317             {\cf19 return} pressFor() - EB_HOLD_T;\par
00318 {\cf21 #else}\par
00319             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT);\par
00320 {\cf21 #endif}\par
00321         \}\par
00322 {\cf21 #endif}\par
00323         {\cf19 return} 0;\par
00324     \}\par
}
}
{\xe \v holdFor\:Button}
{\xe \v Button\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holdFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the button has been held for a specified duration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ms} \cell }{The duration in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button has been held for the specified duration, false otherwise. \par
}}}{
Definition at line {\b 332} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00332                               \{\par
00333         {\cf19 return} holdFor() > ms;\par
00334     \}\par
}
}
{\xe \v holding\:Button}
{\xe \v Button\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00178                    \{\par
00179         {\cf19 return} eq_btn_flag(B_PRS | B_HLD, B_PRS | B_HLD);\par
00180     \}\par
}
}
{\xe \v holding\:Button}
{\xe \v Button\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                               \{\par
00183         {\cf19 return} clicks == num && holding();\par
00184     \}\par
}
}
{\xe \v init\:Button}
{\xe \v Button\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::init (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00060                \{\par
00061         setHoldTimeout();\par
00062         setStepTimeout();\par
00063         setClickTimeout();\par
00064         setDebounceTimeout();\par
00065 \par
00066     \}\par
}
}
{\xe \v init\:Button}
{\xe \v Button\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} Button::init ({\b uint8_t}  {\i npin} = {\f2 0}, {\b uint8_t}  {\i mode} = {\f2 {\b INPUT_PULLUP}}, {\b uint8_t}  {\i btnLevel} = {\f2 {\b LOW}})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the button with the specified pin, mode, and button level. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i npin} \cell }{The pin number to which the button is connected. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mode} \cell }{The mode of the pin (INPUT, INPUT_PULLUP, etc.). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btnLevel} \cell }{The active level of the button (LOW or HIGH). \cell }
{\row }
}
}}
{\xe \v pollBtn\:Button}
{\xe \v Button\:pollBtn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pollBtn ({\b bool}  {\i s}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00391                          \{\par
00392         {\cf19 if} (read_btn_flag(B_BISR)) \{\par
00393             clr_btn_flag(B_BISR);\par
00394             s = 1;\par
00395         \} {\cf19 else} s ^= read_btn_flag(B_INV);\par
00396 \par
00397         {\cf19 if} (!read_btn_flag(B_BUSY)) \{\par
00398             {\cf19 if} (s) set_btn_flag(B_BUSY);\par
00399             {\cf19 else} {\cf19 return} 0;\par
00400         \}\par
00401 \par
00402         uint16_t ms = EB_UPTIME();\par
00403         uint16_t deb = ms - timer;\par
00404 \par
00405         {\cf19 if} (s) \{                                      \par
00406             {\cf19 if} (!read_btn_flag(B_PRS)) \{                  \par
00407                 {\cf19 if} (!read_btn_flag(B_DEB) && EB_DEB_T) \{  \par
00408                     set_btn_flag(B_DEB);                   \par
00409                     timer = ms;                         \par
00410                 \} {\cf19 else} \{                                \par
00411                     {\cf19 if} (deb >= EB_DEB_T || !EB_DEB_T) \{ \par
00412                         set_btn_flag(B_PRS | B_PRS_R);      \par
00413 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00414                         run_timer = ms;\par
00415 {\cf21 #endif}\par
00416                         timer = ms;  \par
00417                     \}\par
00418                 \}\par
00419             \} {\cf19 else} \{  \par
00420                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00421                     {\cf19 if} (!read_btn_flag(B_HLD)) \{  \par
00422 {\cf21 #ifdef EB_HOLD_TIME}\par
00423                         {\cf19 if} (deb >= (uint16_t)EB_HOLD_T) \{  \par
00424 {\cf21 #else}\par
00425                         {\cf19 if} (deb >= (uint16_t)(EB_HOLD_T << EB_SHIFT)) \{  \par
00426 {\cf21 #endif}\par
00427                             set_btn_flag(B_HLD_R | B_HLD); \par
00428                             timer = ms;                 \par
00429                         \}\par
00430                     \} {\cf19 else} \{  \par
00431 {\cf21 #ifdef EB_STEP_TIME}\par
00432                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? EB_STEP_T : EB_HOLD_T)) \{\par
00433 {\cf21 #else}\par
00434                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? (EB_STEP_T << EB_SHIFT) : (EB_HOLD_T << EB_SHIFT))) \{\par
00435 {\cf21 #endif}\par
00436                             set_btn_flag(B_STP | B_STP_R);  \par
00437                             timer = ms;                   \par
00438                         \}\par
00439                     \}\par
00440                 \}\par
00441             \}\par
00442         \} {\cf19 else} \{                                     \par
00443             {\cf19 if} (read_btn_flag(B_PRS)) \{                 \par
00444                 {\cf19 if} (deb >= EB_DEB_T) \{               \par
00445                     {\cf19 if} (!read_btn_flag(B_HLD)) clicks++;    \par
00446                     {\cf19 if} (read_btn_flag(B_EHLD)) clicks = 0;  \par
00447                     set_btn_flag(B_REL | B_REL_R);        \par
00448                     clr_btn_flag(B_PRS);                   \par
00449                 \}\par
00450             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_REL)) \{\par
00451                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00452                     set_btn_flag(B_REL_R);\par
00453                 \}\par
00454                 clr_btn_flag(B_REL | B_EHLD);\par
00455                 timer = ms;       \par
00456             \} {\cf19 else} {\cf19 if} (clicks) \{  \par
00457 {\cf21 #ifdef EB_CLICK_TIME}\par
00458                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)EB_CLICK_T) set_btn_flag(B_CLKS_R);  \par
00459 {\cf21 #else}\par
00460                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)(EB_CLICK_T << EB_SHIFT)) set_btn_flag(B_CLKS_R);  \par
00461 {\cf21 #endif}\par
00462 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00463                 {\cf19 else} {\cf19 if} (run_timer) run_timer = 0;\par
00464 {\cf21 #endif}\par
00465             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_BUSY)) \{\par
00466                 clr_btn_flag(B_HLD | B_STP | B_BUSY);\par
00467                 set_btn_flag(B_TOUT);\par
00468 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00469                 run_timer = 0;\par
00470 {\cf21 #endif}\par
00471                 timer = ms;  {\cf20 // test!!}\par
00472             \}\par
00473             {\cf19 if} (read_btn_flag(B_DEB)) clr_btn_flag(B_DEB);  \par
00474         \}\par
00475         {\cf19 return} read_btn_flag(B_CLKS_R | B_PRS_R | B_HLD_R | B_STP_R | B_REL_R);\par
00476     \}\par
}
}
{\xe \v press\:Button}
{\xe \v Button\:press}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::press (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00154                  \{\par
00155         {\cf19 return} read_btn_flag(B_PRS_R);\par
00156     \}\par
}
}
{\xe \v pressFor\:Button}
{\xe \v Button\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::pressFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the duration in milliseconds for which the button has been pressed. If the EB_NO_PEDOMETER macro is defined, the function always returns 0. If the button is not currently pressed, the function also returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds for which the button has been pressed. \par
}}}{
Definition at line {\b 297} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00297                         \{\par
00298 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00299         {\cf19 if} (run_timer) {\cf19 return} (uint16_t)EB_UPTIME() - run_timer;\par
00300 {\cf21 #endif}\par
00301         {\cf19 return} 0;\par
00302     \}\par
}
}
{\xe \v pressFor\:Button}
{\xe \v Button\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 304} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                \{\par
00305         {\cf19 return} pressFor() > ms;\par
00306     \}\par
}
}
{\xe \v pressing\:Button}
{\xe \v Button\:pressing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressing (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00166                     \{\par
00167         {\cf19 return} read_btn_flag(B_PRS);\par
00168     \}\par
}
}
{\xe \v pressISR\:Button}
{\xe \v Button\:pressISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::pressISR (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                     \{\par
00113         {\cf19 if} (!read_btn_flag(B_DEB)) timer = EB_UPTIME();\par
00114         set_btn_flag(B_DEB | B_BISR);\par
00115     \}\par
}
}
{\xe \v read\:Button}
{\xe \v Button\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} Button::read ()}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the raw pin state for this button instance. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs an XOR against the configured active level to return the logical button state.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The logical state of the button (true for pressed, false for released). \par
}}}}
{\xe \v read_btn_flag\:Button}
{\xe \v Button\:read_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::read_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 506} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                                                                                \{\par
00507         {\cf19 return} flags & x;\par
00508     \}\par
}
}
{\xe \v release\:Button}
{\xe \v Button\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::release (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00158                    \{\par
00159         {\cf19 return} eq_btn_flag(B_REL_R | B_REL, B_REL_R | B_REL);\par
00160     \}\par
}
}
{\xe \v releaseHold\:Button}
{\xe \v Button\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                        \{\par
00218         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD | B_STP, B_REL_R | B_HLD);\par
00219     \}\par
}
}
{\xe \v releaseHold\:Button}
{\xe \v Button\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00221                                   \{\par
00222         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_HLD | B_STP, B_CLKS_R | B_HLD);\par
00223     \}\par
}
}
{\xe \v releaseStep\:Button}
{\xe \v Button\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00225                        \{\par
00226         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_STP, B_REL_R | B_STP);\par
00227     \}\par
}
}
{\xe \v releaseStep\:Button}
{\xe \v Button\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00229                                   \{\par
00230         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_STP, B_CLKS_R | B_STP);\par
00231     \}\par
}
}
{\xe \v reset\:Button}
{\xe \v Button\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::reset (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117                  \{\par
00118         clicks = 0;\par
00119         clr_btn_flag(~B_INV);\par
00120     \}\par
}
}
{\xe \v set_btn_flag\:Button}
{\xe \v Button\:set_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::set_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 500} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00500                                                                               \{\par
00501         flags |= x;\par
00502     \}\par
}
}
{\xe \v setBtnLevel\:Button}
{\xe \v Button\:setBtnLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setBtnLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                                  \{\par
00109         write_btn_flag(B_INV, !level);\par
00110     \}\par
}
}
{\xe \v setButtonLevel\:Button}
{\xe \v Button\:setButtonLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setButtonLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00385                                     \{\par
00386         write_btn_flag(B_INV, !level);\par
00387     \}\par
}
}
{\xe \v setClickTimeout\:Button}
{\xe \v Button\:setClickTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setClickTimeout ({\b uint16_t}  {\i timeout} = {\f2 500}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The click timeout value in milliseconds. Default is 500 milliseconds. Max is 4000ms. \cell }
{\row }
}
}{
Definition at line {\b 96} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096                                                \{\par
00097 {\cf21 #ifndef EB_CLICK_TIME}\par
00098         EB_CLICK_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00099 {\cf21 #endif}\par
00100     \}\par
}
}
{\xe \v setDebounceTimeout\:Button}
{\xe \v Button\:setDebounceTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setDebounceTimeout ({\b uint8_t}  {\i timeout} = {\f2 50}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00102                                                 \{\par
00103 {\cf21 #ifndef EB_DEB_TIME}\par
00104         EB_DEB_T = (timeout < 255) ? timeout : 255;\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v setHoldTimeout\:Button}
{\xe \v Button\:setHoldTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setHoldTimeout ({\b uint16_t}  {\i timeout} = {\f2 600}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The hold timeout value in milliseconds. Default is 600 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 74} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00074                                               \{\par
00075 {\cf21 #ifndef EB_HOLD_TIME}\par
00076         EB_HOLD_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00077 {\cf21 #endif}\par
00078     \}\par
}
}
{\xe \v setStepTimeout\:Button}
{\xe \v Button\:setStepTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setStepTimeout ({\b uint16_t}  {\i timeout} = {\f2 200}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the step timeout for the virtual button. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The timeout value in milliseconds. Default is 200 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 85} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085                                               \{\par
00086 {\cf21 #ifndef EB_STEP_TIME}\par
00087         EB_STEP_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00088 {\cf21 #endif}\par
00089     \}\par
}
}
{\xe \v step\:Button}
{\xe \v Button\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                 \{\par
00187         {\cf19 return} read_btn_flag(B_STP_R);\par
00188     \}\par
}
}
{\xe \v step\:Button}
{\xe \v Button\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190                            \{\par
00191         {\cf19 return} clicks == num && step();\par
00192     \}\par
}
}
{\xe \v stepFor\:Button}
{\xe \v Button\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::stepFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00336                        \{\par
00337 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00338         {\cf19 if} (read_btn_flag(B_STP)) \{\par
00339 {\cf21 #ifdef EB_HOLD_TIME}\par
00340             {\cf19 return} pressFor() - EB_HOLD_T * 2;\par
00341 {\cf21 #else}\par
00342             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT) * 2;\par
00343 {\cf21 #endif}\par
00344         \}\par
00345 {\cf21 #endif}\par
00346         {\cf19 return} 0;\par
00347     \}\par
}
}
{\xe \v stepFor\:Button}
{\xe \v Button\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::stepFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 349} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                               \{\par
00350         {\cf19 return} stepFor() > ms;\par
00351     \}\par
}
}
{\xe \v tick\:Button}
{\xe \v Button\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} Button::tick ()}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the button state and updates the internal state machine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the parent {\b VirtButton::tick()} method to update the debounced/held state based on the latest raw pin reading.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The updated state of the button (true for pressed, false for released). \par
}}}}
{\xe \v tick\:Button}
{\xe \v Button\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b bool}  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 368} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00368                           \{\par
00369         clear();\par
00370         state = pollBtn(state);\par
00371 {\cf21 #ifndef EB_NO_CALLBACK}\par
00372         {\cf19 if} (cb && state) cb();\par
00373 {\cf21 #endif}\par
00374         {\cf19 return} state;\par
00375     \}\par
}
}
{\xe \v tick\:Button}
{\xe \v Button\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b VirtButton} &  {\i b0}, {\b VirtButton} &  {\i b1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00354                                               \{\par
00355         {\cf19 if} (read_btn_flag(B_BOTH)) \{\par
00356             {\cf19 if} (!b0.pressing() && !b1.pressing()) clr_btn_flag(B_BOTH);\par
00357             {\cf19 if} (!b0.pressing()) b0.reset();\par
00358             {\cf19 if} (!b1.pressing()) b1.reset();\par
00359             b0.clear();\par
00360             b1.clear();\par
00361             {\cf19 return} tick(1);\par
00362         \} {\cf19 else} \{\par
00363             {\cf19 if} (b0.pressing() && b1.pressing()) set_btn_flag(B_BOTH);\par
00364             {\cf19 return} tick(0);\par
00365         \}\par
00366     \}\par
}
}
{\xe \v tickRaw\:Button}
{\xe \v Button\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} Button::tickRaw ()}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the raw pin state for this button instance and updates the internal state machine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the parent {\b VirtButton::tickRaw()} method to update the debounced/held state based on the latest raw pin reading.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The updated state of the button (true for pressed, false for released). \par
}}}}
{\xe \v tickRaw\:Button}
{\xe \v Button\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tickRaw ({\b bool}  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 378} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00378                              \{\par
00379         {\cf19 return} pollBtn(state);\par
00380     \}\par
}
}
{\xe \v timeout\:Button}
{\xe \v Button\:timeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtButton::timeout (uint16_t  {\i tout}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the timeout has occurred.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The timeout value in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the timeout has occurred, false otherwise. \par
}}}{
Definition at line {\b 282} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00282                                 \{\par
00283         {\cf19 if} (read_btn_flag(B_TOUT) && (uint16_t)((uint16_t)EB_UPTIME() - timer) > tout) \{\par
00284             clr_btn_flag(B_TOUT);\par
00285             {\cf19 return} 1;\par
00286         \}\par
00287         {\cf19 return} 0;\par
00288     \}\par
}
}
{\xe \v waiting\:Button}
{\xe \v Button\:waiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::waiting (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00233                    \{\par
00234         {\cf19 return} clicks && eq_btn_flag(B_PRS | B_REL, 0);\par
00235     \}\par
}
}
{\xe \v write_btn_flag\:Button}
{\xe \v Button\:write_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::write_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b bool}  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 509} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00509                                                                                         \{\par
00510         {\cf19 if} (v) set_btn_flag(x);\par
00511         {\cf19 else} clr_btn_flag(x);\par
00512     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:Button}
{\xe \v Button\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtButton::cb = {\b nullptr}{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 484} of file {\b VirtButton.h}.}\par
}
{\xe \v clicks\:Button}
{\xe \v Button\:clicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::clicks{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_CLICK_T\:Button}
{\xe \v Button\:EB_CLICK_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_CLICK_T = (500 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_DEB_T\:Button}
{\xe \v Button\:EB_DEB_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_DEB_T = 50{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_HOLD_T\:Button}
{\xe \v Button\:EB_HOLD_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_HOLD_T = (600 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 494} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_STEP_T\:Button}
{\xe \v Button\:EB_STEP_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_STEP_T = (200 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 497} of file {\b VirtButton.h}.}\par
}
{\xe \v run_timer\:Button}
{\xe \v Button\:run_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::run_timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 480} of file {\b VirtButton.h}.}\par
}
{\xe \v timer\:Button}
{\xe \v Button\:timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b Button.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ButtonT< PIN > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v ButtonT< PIN >}
{\xe \v ButtonT< PIN >}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\par
{
{\f2 #include <Button.h>}}\par
Inheritance diagram for ButtonT< PIN >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d9/d03/class_button_t.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ButtonT} ({\b uint8_t} {\b mode}={\b INPUT_PULLUP}, {\b uint8_t} {\b btnLevel}={\b LOW})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ({\b uint8_t} {\b mode}={\b INPUT_PULLUP}, {\b uint8_t} {\b btnLevel}={\b LOW})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setHoldTimeout} ({\b uint16_t} {\b timeout}=600)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setStepTimeout} ({\b uint16_t} {\b timeout}=200)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setClickTimeout} ({\b uint16_t} {\b timeout}=500)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setDebounceTimeout} ({\b uint8_t} {\b timeout}=50)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setBtnLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b pressISR} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clear} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b detach_call} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b press} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b release} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b click} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressing} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b getSteps} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b waiting} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b busy} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b timeout} (uint16_t tout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b pressFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b holdFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holdFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b stepFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b stepFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b VirtButton} &{\b b0}, {\b VirtButton} &{\b b1})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setButtonLevel} ({\b bool} {\b level})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b clicks}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pollBtn} ({\b bool} {\b s})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b eq_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b const} {\b uint16_t} {\b y}) {\b __attribute__}(({\b always_inline}))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b run_timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} = {\b nullptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_DEB_T} = 50\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_CLICK_T} = (500 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_HOLD_T} = (600 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_STEP_T} = (200 >> {\b EB_SHIFT})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b uint8_t} PIN>\par
class ButtonT< PIN >\par
}
\par
{
Definition at line {\b 75} of file {\b Button.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ButtonT\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:ButtonT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} PIN> {\b ButtonT}< {\b PIN} >{\b ::ButtonT} ({\b uint8_t}  {\i mode} = {\f2 {\b INPUT_PULLUP}}, {\b uint8_t}  {\i btnLevel} = {\f2 {\b LOW}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b Button.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077                                                                  \{\par
00078         init(mode, btnLevel);\par
00079     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtButton::action (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action corresponding to the current flag combination.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The action corresponding to the current flag combination. \par
}}}{
Definition at line {\b 246} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00246                         \{\par
00247         {\cf19 switch} (flags & 0b111111111) \{\par
00248             {\cf19 case} (B_PRS | B_PRS_R):\par
00249                 {\cf19 return} EB_PRESS;\par
00250             {\cf19 case} (B_PRS | B_HLD | B_HLD_R):\par
00251                 {\cf19 return} EB_HOLD;\par
00252             {\cf19 case} (B_PRS | B_HLD | B_STP | B_STP_R):\par
00253                 {\cf19 return} EB_STEP;\par
00254             {\cf19 case} (B_REL | B_REL_R):\par
00255             {\cf19 case} (B_REL | B_REL_R | B_HLD):\par
00256             {\cf19 case} (B_REL | B_REL_R | B_HLD | B_STP):\par
00257                 {\cf19 return} EB_RELEASE;\par
00258             {\cf19 case} (B_REL_R):\par
00259                 {\cf19 return} EB_CLICK;\par
00260             {\cf19 case} (B_CLKS_R):\par
00261                 {\cf19 return} EB_CLICKS;\par
00262             {\cf19 case} (B_REL_R | B_HLD):\par
00263                 {\cf19 return} EB_REL_HOLD;\par
00264             {\cf19 case} (B_CLKS_R | B_HLD):\par
00265                 {\cf19 return} EB_REL_HOLD_C;\par
00266             {\cf19 case} (B_REL_R | B_HLD | B_STP):\par
00267                 {\cf19 return} EB_REL_STEP;\par
00268             {\cf19 case} (B_CLKS_R | B_HLD | B_STP):\par
00269                 {\cf19 return} EB_REL_STEP_C;\par
00270             {\cf19 default}:\par
00271                 {\cf19 return} EB_NONE;\par
00272         \}\par
00273     \}\par
}
}
{\xe \v attach_call\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::attach_call ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 137} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                           \{ \par
00138 {\cf21 #ifndef EB_NO_CALLBACK}\par
00139         {\cf19 if} (callback_func == {\cf17 nullptr} || cb) {\cf19 return} {\cf17 false};\par
00140         cb = *callback_func;\par
00141         {\cf19 return} {\cf17 true};\par
00142 {\cf21 #endif}\par
00143         {\cf19 return} {\cf17 false};\par
00144     \}\par
}
}
{\xe \v busy\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:busy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::busy (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 237} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00237                 \{\par
00238         {\cf19 return} read_btn_flag(B_BUSY);\par
00239     \}\par
}
}
{\xe \v clear\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clear (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00122                  \{\par
00123         {\cf19 if} (read_btn_flag(B_CLKS_R)) clicks = 0;\par
00124         {\cf19 if} (read_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R)) \{\par
00125             clr_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R);\par
00126         \}\par
00127     \}\par
}
}
{\xe \v click\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:click}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::click (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00162                  \{\par
00163         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD, B_REL_R);\par
00164     \}\par
}
}
{\xe \v clr_btn_flag\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:clr_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clr_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 503} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00503                                                                               \{\par
00504         flags &= ~x;\par
00505     \}\par
}
}
{\xe \v detach_call\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::detach_call (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00147                        \{\par
00148 {\cf21 #ifndef EB_NO_CALLBACK}\par
00149         cb = {\cf17 nullptr};\par
00150 {\cf21 #endif}\par
00151     \}\par
}
}
{\xe \v eq_btn_flag\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:eq_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::eq_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b const} {\b uint16_t}  {\i y}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 513} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00513                                                                                                \{\par
00514         {\cf19 return} (flags & x) == y;\par
00515     \}\par
}
}
{\xe \v getClicks\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:getClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::getClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                         \{\par
00203         {\cf19 return} clicks;\par
00204     \}\par
}
}
{\xe \v getSteps\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:getSteps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::getSteps (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00206                         \{\par
00207 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00208 {\cf21 #ifdef EB_STEP_TIME}\par
00209         {\cf19 return} run_timer ? ((stepFor() + EB_STEP_T - 1) / EB_STEP_T) : 0;  \par
00210 {\cf21 #else}\par
00211         {\cf19 return} run_timer ? ((stepFor() + (EB_STEP_T << EB_SHIFT) - 1) / (EB_STEP_T << EB_SHIFT)) : 0;\par
00212 {\cf21 #endif}\par
00213 {\cf21 #endif}\par
00214         {\cf19 return} 0;\par
00215     \}\par
}
}
{\xe \v hasClicks\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00194                      \{\par
00195         {\cf19 return} eq_btn_flag(B_CLKS_R | B_HLD, B_CLKS_R);\par
00196     \}\par
}
}
{\xe \v hasClicks\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00198                                 \{\par
00199         {\cf19 return} clicks == num && hasClicks();\par
00200     \}\par
}
}
{\xe \v hold\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                 \{\par
00171         {\cf19 return} read_btn_flag(B_HLD_R);\par
00172     \}\par
}
}
{\xe \v hold\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00174                            \{\par
00175         {\cf19 return} clicks == num && hold();\par
00176     \}\par
}
}
{\xe \v holdFor\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::holdFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the duration for which the button has been held.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds. \par
}}}{
Definition at line {\b 313} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                        \{\par
00314 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00315         {\cf19 if} (read_btn_flag(B_HLD)) \{\par
00316 {\cf21 #ifdef EB_HOLD_TIME}\par
00317             {\cf19 return} pressFor() - EB_HOLD_T;\par
00318 {\cf21 #else}\par
00319             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT);\par
00320 {\cf21 #endif}\par
00321         \}\par
00322 {\cf21 #endif}\par
00323         {\cf19 return} 0;\par
00324     \}\par
}
}
{\xe \v holdFor\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holdFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the button has been held for a specified duration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ms} \cell }{The duration in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button has been held for the specified duration, false otherwise. \par
}}}{
Definition at line {\b 332} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00332                               \{\par
00333         {\cf19 return} holdFor() > ms;\par
00334     \}\par
}
}
{\xe \v holding\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00178                    \{\par
00179         {\cf19 return} eq_btn_flag(B_PRS | B_HLD, B_PRS | B_HLD);\par
00180     \}\par
}
}
{\xe \v holding\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                               \{\par
00183         {\cf19 return} clicks == num && holding();\par
00184     \}\par
}
}
{\xe \v init\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::init (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00060                \{\par
00061         setHoldTimeout();\par
00062         setStepTimeout();\par
00063         setClickTimeout();\par
00064         setDebounceTimeout();\par
00065 \par
00066     \}\par
}
}
{\xe \v init\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} PIN> {\b void} {\b ButtonT}< {\b PIN} >::init ({\b uint8_t}  {\i mode} = {\f2 {\b INPUT_PULLUP}}, {\b uint8_t}  {\i btnLevel} = {\f2 {\b LOW}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b Button.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00081                                                                    \{\par
00082         pinMode(PIN, mode);\par
00083         setBtnLevel(btnLevel);\par
00084     \}\par
}
}
{\xe \v pollBtn\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:pollBtn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pollBtn ({\b bool}  {\i s}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00391                          \{\par
00392         {\cf19 if} (read_btn_flag(B_BISR)) \{\par
00393             clr_btn_flag(B_BISR);\par
00394             s = 1;\par
00395         \} {\cf19 else} s ^= read_btn_flag(B_INV);\par
00396 \par
00397         {\cf19 if} (!read_btn_flag(B_BUSY)) \{\par
00398             {\cf19 if} (s) set_btn_flag(B_BUSY);\par
00399             {\cf19 else} {\cf19 return} 0;\par
00400         \}\par
00401 \par
00402         uint16_t ms = EB_UPTIME();\par
00403         uint16_t deb = ms - timer;\par
00404 \par
00405         {\cf19 if} (s) \{                                      \par
00406             {\cf19 if} (!read_btn_flag(B_PRS)) \{                  \par
00407                 {\cf19 if} (!read_btn_flag(B_DEB) && EB_DEB_T) \{  \par
00408                     set_btn_flag(B_DEB);                   \par
00409                     timer = ms;                         \par
00410                 \} {\cf19 else} \{                                \par
00411                     {\cf19 if} (deb >= EB_DEB_T || !EB_DEB_T) \{ \par
00412                         set_btn_flag(B_PRS | B_PRS_R);      \par
00413 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00414                         run_timer = ms;\par
00415 {\cf21 #endif}\par
00416                         timer = ms;  \par
00417                     \}\par
00418                 \}\par
00419             \} {\cf19 else} \{  \par
00420                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00421                     {\cf19 if} (!read_btn_flag(B_HLD)) \{  \par
00422 {\cf21 #ifdef EB_HOLD_TIME}\par
00423                         {\cf19 if} (deb >= (uint16_t)EB_HOLD_T) \{  \par
00424 {\cf21 #else}\par
00425                         {\cf19 if} (deb >= (uint16_t)(EB_HOLD_T << EB_SHIFT)) \{  \par
00426 {\cf21 #endif}\par
00427                             set_btn_flag(B_HLD_R | B_HLD); \par
00428                             timer = ms;                 \par
00429                         \}\par
00430                     \} {\cf19 else} \{  \par
00431 {\cf21 #ifdef EB_STEP_TIME}\par
00432                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? EB_STEP_T : EB_HOLD_T)) \{\par
00433 {\cf21 #else}\par
00434                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? (EB_STEP_T << EB_SHIFT) : (EB_HOLD_T << EB_SHIFT))) \{\par
00435 {\cf21 #endif}\par
00436                             set_btn_flag(B_STP | B_STP_R);  \par
00437                             timer = ms;                   \par
00438                         \}\par
00439                     \}\par
00440                 \}\par
00441             \}\par
00442         \} {\cf19 else} \{                                     \par
00443             {\cf19 if} (read_btn_flag(B_PRS)) \{                 \par
00444                 {\cf19 if} (deb >= EB_DEB_T) \{               \par
00445                     {\cf19 if} (!read_btn_flag(B_HLD)) clicks++;    \par
00446                     {\cf19 if} (read_btn_flag(B_EHLD)) clicks = 0;  \par
00447                     set_btn_flag(B_REL | B_REL_R);        \par
00448                     clr_btn_flag(B_PRS);                   \par
00449                 \}\par
00450             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_REL)) \{\par
00451                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00452                     set_btn_flag(B_REL_R);\par
00453                 \}\par
00454                 clr_btn_flag(B_REL | B_EHLD);\par
00455                 timer = ms;       \par
00456             \} {\cf19 else} {\cf19 if} (clicks) \{  \par
00457 {\cf21 #ifdef EB_CLICK_TIME}\par
00458                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)EB_CLICK_T) set_btn_flag(B_CLKS_R);  \par
00459 {\cf21 #else}\par
00460                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)(EB_CLICK_T << EB_SHIFT)) set_btn_flag(B_CLKS_R);  \par
00461 {\cf21 #endif}\par
00462 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00463                 {\cf19 else} {\cf19 if} (run_timer) run_timer = 0;\par
00464 {\cf21 #endif}\par
00465             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_BUSY)) \{\par
00466                 clr_btn_flag(B_HLD | B_STP | B_BUSY);\par
00467                 set_btn_flag(B_TOUT);\par
00468 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00469                 run_timer = 0;\par
00470 {\cf21 #endif}\par
00471                 timer = ms;  {\cf20 // test!!}\par
00472             \}\par
00473             {\cf19 if} (read_btn_flag(B_DEB)) clr_btn_flag(B_DEB);  \par
00474         \}\par
00475         {\cf19 return} read_btn_flag(B_CLKS_R | B_PRS_R | B_HLD_R | B_STP_R | B_REL_R);\par
00476     \}\par
}
}
{\xe \v press\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:press}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::press (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00154                  \{\par
00155         {\cf19 return} read_btn_flag(B_PRS_R);\par
00156     \}\par
}
}
{\xe \v pressFor\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::pressFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the duration in milliseconds for which the button has been pressed. If the EB_NO_PEDOMETER macro is defined, the function always returns 0. If the button is not currently pressed, the function also returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds for which the button has been pressed. \par
}}}{
Definition at line {\b 297} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00297                         \{\par
00298 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00299         {\cf19 if} (run_timer) {\cf19 return} (uint16_t)EB_UPTIME() - run_timer;\par
00300 {\cf21 #endif}\par
00301         {\cf19 return} 0;\par
00302     \}\par
}
}
{\xe \v pressFor\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 304} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                \{\par
00305         {\cf19 return} pressFor() > ms;\par
00306     \}\par
}
}
{\xe \v pressing\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:pressing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressing (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00166                     \{\par
00167         {\cf19 return} read_btn_flag(B_PRS);\par
00168     \}\par
}
}
{\xe \v pressISR\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:pressISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::pressISR (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                     \{\par
00113         {\cf19 if} (!read_btn_flag(B_DEB)) timer = EB_UPTIME();\par
00114         set_btn_flag(B_DEB | B_BISR);\par
00115     \}\par
}
}
{\xe \v read\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} PIN> {\b bool} {\b ButtonT}< {\b PIN} >::read (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b Button.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00086                 \{\par
00087         {\cf19 return} EBread(PIN) ^ read_btn_flag(B_INV);\par
00088     \}\par
}
}
{\xe \v read_btn_flag\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:read_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::read_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 506} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                                                                                \{\par
00507         {\cf19 return} flags & x;\par
00508     \}\par
}
}
{\xe \v release\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::release (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00158                    \{\par
00159         {\cf19 return} eq_btn_flag(B_REL_R | B_REL, B_REL_R | B_REL);\par
00160     \}\par
}
}
{\xe \v releaseHold\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                        \{\par
00218         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD | B_STP, B_REL_R | B_HLD);\par
00219     \}\par
}
}
{\xe \v releaseHold\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00221                                   \{\par
00222         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_HLD | B_STP, B_CLKS_R | B_HLD);\par
00223     \}\par
}
}
{\xe \v releaseStep\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00225                        \{\par
00226         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_STP, B_REL_R | B_STP);\par
00227     \}\par
}
}
{\xe \v releaseStep\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00229                                   \{\par
00230         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_STP, B_CLKS_R | B_STP);\par
00231     \}\par
}
}
{\xe \v reset\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::reset (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117                  \{\par
00118         clicks = 0;\par
00119         clr_btn_flag(~B_INV);\par
00120     \}\par
}
}
{\xe \v set_btn_flag\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:set_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::set_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 500} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00500                                                                               \{\par
00501         flags |= x;\par
00502     \}\par
}
}
{\xe \v setBtnLevel\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:setBtnLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setBtnLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                                  \{\par
00109         write_btn_flag(B_INV, !level);\par
00110     \}\par
}
}
{\xe \v setButtonLevel\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:setButtonLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setButtonLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00385                                     \{\par
00386         write_btn_flag(B_INV, !level);\par
00387     \}\par
}
}
{\xe \v setClickTimeout\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:setClickTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setClickTimeout ({\b uint16_t}  {\i timeout} = {\f2 500}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The click timeout value in milliseconds. Default is 500 milliseconds. Max is 4000ms. \cell }
{\row }
}
}{
Definition at line {\b 96} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096                                                \{\par
00097 {\cf21 #ifndef EB_CLICK_TIME}\par
00098         EB_CLICK_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00099 {\cf21 #endif}\par
00100     \}\par
}
}
{\xe \v setDebounceTimeout\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:setDebounceTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setDebounceTimeout ({\b uint8_t}  {\i timeout} = {\f2 50}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00102                                                 \{\par
00103 {\cf21 #ifndef EB_DEB_TIME}\par
00104         EB_DEB_T = (timeout < 255) ? timeout : 255;\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v setHoldTimeout\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:setHoldTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setHoldTimeout ({\b uint16_t}  {\i timeout} = {\f2 600}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The hold timeout value in milliseconds. Default is 600 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 74} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00074                                               \{\par
00075 {\cf21 #ifndef EB_HOLD_TIME}\par
00076         EB_HOLD_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00077 {\cf21 #endif}\par
00078     \}\par
}
}
{\xe \v setStepTimeout\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:setStepTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setStepTimeout ({\b uint16_t}  {\i timeout} = {\f2 200}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the step timeout for the virtual button. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The timeout value in milliseconds. Default is 200 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 85} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085                                               \{\par
00086 {\cf21 #ifndef EB_STEP_TIME}\par
00087         EB_STEP_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00088 {\cf21 #endif}\par
00089     \}\par
}
}
{\xe \v step\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                 \{\par
00187         {\cf19 return} read_btn_flag(B_STP_R);\par
00188     \}\par
}
}
{\xe \v step\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190                            \{\par
00191         {\cf19 return} clicks == num && step();\par
00192     \}\par
}
}
{\xe \v stepFor\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::stepFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00336                        \{\par
00337 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00338         {\cf19 if} (read_btn_flag(B_STP)) \{\par
00339 {\cf21 #ifdef EB_HOLD_TIME}\par
00340             {\cf19 return} pressFor() - EB_HOLD_T * 2;\par
00341 {\cf21 #else}\par
00342             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT) * 2;\par
00343 {\cf21 #endif}\par
00344         \}\par
00345 {\cf21 #endif}\par
00346         {\cf19 return} 0;\par
00347     \}\par
}
}
{\xe \v stepFor\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::stepFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 349} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                               \{\par
00350         {\cf19 return} stepFor() > ms;\par
00351     \}\par
}
}
{\xe \v tick\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} PIN> {\b bool} {\b ButtonT}< {\b PIN} >::tick (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b Button.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00090                 \{\par
00091         {\cf19 return} VirtButton::tick(EBread(PIN));\par
00092     \}\par
}
}
{\xe \v tick\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b bool}  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 368} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00368                           \{\par
00369         clear();\par
00370         state = pollBtn(state);\par
00371 {\cf21 #ifndef EB_NO_CALLBACK}\par
00372         {\cf19 if} (cb && state) cb();\par
00373 {\cf21 #endif}\par
00374         {\cf19 return} state;\par
00375     \}\par
}
}
{\xe \v tick\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b VirtButton} &  {\i b0}, {\b VirtButton} &  {\i b1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00354                                               \{\par
00355         {\cf19 if} (read_btn_flag(B_BOTH)) \{\par
00356             {\cf19 if} (!b0.pressing() && !b1.pressing()) clr_btn_flag(B_BOTH);\par
00357             {\cf19 if} (!b0.pressing()) b0.reset();\par
00358             {\cf19 if} (!b1.pressing()) b1.reset();\par
00359             b0.clear();\par
00360             b1.clear();\par
00361             {\cf19 return} tick(1);\par
00362         \} {\cf19 else} \{\par
00363             {\cf19 if} (b0.pressing() && b1.pressing()) set_btn_flag(B_BOTH);\par
00364             {\cf19 return} tick(0);\par
00365         \}\par
00366     \}\par
}
}
{\xe \v tickRaw\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} PIN> {\b bool} {\b ButtonT}< {\b PIN} >::tickRaw (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b Button.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00094                    \{\par
00095         {\cf19 return} VirtButton::tickRaw(EBread(PIN));\par
00096     \}\par
}
}
{\xe \v tickRaw\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tickRaw ({\b bool}  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 378} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00378                              \{\par
00379         {\cf19 return} pollBtn(state);\par
00380     \}\par
}
}
{\xe \v timeout\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:timeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtButton::timeout (uint16_t  {\i tout}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the timeout has occurred.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The timeout value in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the timeout has occurred, false otherwise. \par
}}}{
Definition at line {\b 282} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00282                                 \{\par
00283         {\cf19 if} (read_btn_flag(B_TOUT) && (uint16_t)((uint16_t)EB_UPTIME() - timer) > tout) \{\par
00284             clr_btn_flag(B_TOUT);\par
00285             {\cf19 return} 1;\par
00286         \}\par
00287         {\cf19 return} 0;\par
00288     \}\par
}
}
{\xe \v waiting\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:waiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::waiting (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00233                    \{\par
00234         {\cf19 return} clicks && eq_btn_flag(B_PRS | B_REL, 0);\par
00235     \}\par
}
}
{\xe \v write_btn_flag\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:write_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::write_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b bool}  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 509} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00509                                                                                         \{\par
00510         {\cf19 if} (v) set_btn_flag(x);\par
00511         {\cf19 else} clr_btn_flag(x);\par
00512     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtButton::cb = {\b nullptr}{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 484} of file {\b VirtButton.h}.}\par
}
{\xe \v clicks\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:clicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::clicks{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_CLICK_T\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:EB_CLICK_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_CLICK_T = (500 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_DEB_T\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:EB_DEB_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_DEB_T = 50{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_HOLD_T\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:EB_HOLD_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_HOLD_T = (600 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 494} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_STEP_T\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:EB_STEP_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_STEP_T = (200 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 497} of file {\b VirtButton.h}.}\par
}
{\xe \v run_timer\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:run_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::run_timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 480} of file {\b VirtButton.h}.}\par
}
{\xe \v timer\:ButtonT< PIN >}
{\xe \v ButtonT< PIN >\:timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b Button.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EncButton Class Reference\par \pard\plain 
{\tc\tcl2 \v EncButton}
{\xe \v EncButton}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class that represents an encoder button. }}\par
{
{\f2 #include <EncButton.h>}}\par
Inheritance diagram for EncButton:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d1/d01/class_enc_button.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EncButton} ({\b uint8_t} {\b encA}=0, {\b uint8_t} {\b encB}=0, {\b uint8_t} {\b btn}=0, {\b uint8_t} {\b modeEnc}={\b INPUT}, {\b uint8_t} {\b modeBtn}={\b INPUT_PULLUP}, {\b uint8_t} {\b btnLevel}={\b LOW})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an {\b EncButton} object with default pin and mode values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ({\b uint8_t} {\b encA}=0, {\b uint8_t} {\b encB}=0, {\b uint8_t} {\b btn}=0, {\b uint8_t} {\b modeEnc}={\b INPUT}, {\b uint8_t} {\b modeBtn}={\b INPUT_PULLUP}, {\b uint8_t} {\b btnLevel}={\b LOW})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the {\b EncButton} object with the specified pin and mode values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickISR} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a tick operation on the {\b EncButton} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a tick operation on the {\b EncButton} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a raw tick operation on the {\b EncButton} object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b readBtn} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the state of the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b readEnc} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the value of the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b setFastTimeout} ({\b uint8_t} {\b tout})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the Fast Timeout object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clear} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the state of the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b EB_FLAGS_T} {\b handler}, {\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attaches a callback function to handle a specific event of the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b detach_call} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b turnH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b fast} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is in the fast mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b right} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right without holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b left} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left without holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b rightH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right while holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b leftH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left while holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b encHolding} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is being held. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action of the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickISR} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickISR} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} e0, {\b bool} e1, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b int8_t} {\b state}, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b VirtButton} &{\b b0}, {\b VirtButton} &{\b b1})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tick} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tick} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} e0, {\b bool} e1, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b int8_t} {\b state}, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickRaw} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setHoldTimeout} ({\b uint16_t} {\b timeout}=600)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setStepTimeout} ({\b uint16_t} {\b timeout}=200)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setClickTimeout} ({\b uint16_t} {\b timeout}=500)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setDebounceTimeout} ({\b uint8_t} {\b timeout}=50)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setBtnLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b pressISR} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b press} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b release} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b click} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressing} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b getSteps} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b waiting} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b busy} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b timeout} (uint16_t tout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b pressFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b holdFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holdFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b stepFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b stepFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setButtonLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncReverse} ({\b bool} {\b rev}={\b false})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncType} ({\b uint8_t} {\b type}={\b EB_STEP1})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncISR} ({\b bool} {\b use}={\b true})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_right} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_left} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b initEnc} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b initEnc} ({\b int8_t} {\b v})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b turn} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b dir} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b clicks}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pollBtn} ({\b bool} {\b s})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b eq_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b const} {\b uint16_t} {\b y}) {\b __attribute__}(({\b always_inline}))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} [5] = \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\b nullptr}, {\b nullptr}\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_FAST_T} = 30\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b ebuffer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b run_timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_DEB_T} = 50\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_CLICK_T} = (500 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_HOLD_T} = (600 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_STEP_T} = (200 >> {\b EB_SHIFT})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
tickRaw <br>\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickRaw} ({\b int8_t} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b pollEnc} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b pollEnc} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int32_t} {\b counter} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_encf} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class that represents an encoder button. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class extends the {\b VirtEncButton} class and provides additional functionality for handling an encoder button. It allows initializing the encoder pins, button pin, and button mode. It also provides methods for reading the button state and encoder value. \par
}{
Definition at line {\b 20} of file {\b EncButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EncButton\:EncButton}
{\xe \v EncButton\:EncButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EncButton::EncButton ({\b uint8_t}  {\i encA} = {\f2 0}, {\b uint8_t}  {\i encB} = {\f2 0}, {\b uint8_t}  {\i btn} = {\f2 0}, {\b uint8_t}  {\i modeEnc} = {\f2 {\b INPUT}}, {\b uint8_t}  {\i modeBtn} = {\f2 {\b INPUT_PULLUP}}, {\b uint8_t}  {\i btnLevel} = {\f2 {\b LOW}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an {\b EncButton} object with default pin and mode values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i encA} \cell }{The pin number for encoder A. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i encB} \cell }{The pin number for encoder B. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The pin number for the button. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i modeEnc} \cell }{The mode for the encoder pins. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i modeBtn} \cell }{The mode for the button pin. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btnLevel} \cell }{The logic level for the button pin when pressed. \cell }
{\row }
}
}{
Definition at line {\b 32} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032                                                                                                                                                     \{\par
00033         init(encA, encB, btn, modeEnc, modeBtn, btnLevel);\par
00034     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:EncButton}
{\xe \v EncButton\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtEncButton::action (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action of the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The action of the encoder button \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid todo in binary switch case block e_state + b_state and EB_HOLD + EB_TURN verification if ((state & EB_HOLD) && (state & EB_TURN_R)) return EB_TURN_HOLD_R; \par
}
}{
Definition at line {\b 180} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00180                         \{\par
00181         EB_FLAGS_T e_state =  VirtEncoder::action(); \par
00182         EB_FLAGS_T b_state =  VirtButton::action();\par
00183 \par
00184         {\cf19 if} (e_state == EB_NONE) \{\par
00185             {\cf19 return} b_state; \par
00186         \}\par
00187         \par
00188         {\cf19 if}(b_state == EB_HOLD)\{\par
00189             {\cf19 switch} (e_state)\par
00190             \{\par
00191                 {\cf19 case} EB_TURN_R:\par
00192                     {\cf19 return} EB_TURN_HOLD_R;\par
00193                 {\cf19 case} EB_TURN_L:\par
00194                     {\cf19 return} EB_TURN_HOLD_L;\par
00195                 {\cf19 case} EB_TURN:\par
00196                     {\cf19 return} EB_TURN;\par
00197                 {\cf19 default}:\par
00198                     {\cf19 return} EB_HOLD;\par
00199             \}\par
00200         \}\par
00201         {\cf19 return} e_state;\par
00202 \par
00203 \par
00204         {\cf20 /* needs to be tested}\par
00205 {\cf20 }\par
00206 {\cf20          switch (b_state | e_state)}\par
00207 {\cf20          \{}\par
00208 {\cf20             case 1000000001000:}\par
00209 {\cf20                 return EB_TURN_HOLD_R; //EB_HOLD + EB_TURN_R}\par
00210 {\cf20             case 10000000011000:}\par
00211 {\cf20                 return EB_TURN_HOLD_L; //EB_HOLD + EB_TURN_L}\par
00212 {\cf20             case 10000001000 :}\par
00213 {\cf20                 return EB_TURN;//EB_HOLD + EB_TURN}\par
00214 {\cf20             case (e_state | EB_NONE):}\par
00215 {\cf20                 return e_state; //if b_state == EB_NONE}\par
00216 {\cf20             default:}\par
00217 {\cf20                 return b_state; }\par
00218 {\cf20          \}}\par
00219 {\cf20         }\par
00220 {\cf20         */}\par
00221     \}\par
}
}
{\xe \v attach_call\:EncButton}
{\xe \v EncButton\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::attach_call ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 137} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                           \{ \par
00138 {\cf21 #ifndef EB_NO_CALLBACK}\par
00139         {\cf19 if} (callback_func == {\cf17 nullptr} || cb) {\cf19 return} {\cf17 false};\par
00140         cb = *callback_func;\par
00141         {\cf19 return} {\cf17 true};\par
00142 {\cf21 #endif}\par
00143         {\cf19 return} {\cf17 false};\par
00144     \}\par
}
}
{\xe \v attach_call\:EncButton}
{\xe \v EncButton\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::attach_call ({\b EB_FLAGS_T}  {\i handler}, {\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attaches a callback function to handle a specific event of the virtual encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i handler} \cell }{The event type to attach the callback function to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{The callback function to be attached. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns true if the callback function was successfully attached, false otherwise. \par
}}}{
Definition at line {\b 61} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00061                                                             \{\par
00062 {\cf21 #ifndef EB_NO_CALLBACK}\par
00063         {\cf19 if}(callback_func)\{\par
00064             {\cf19 switch} (handler)\par
00065             \{\par
00066                 {\cf19 case} EB_PRESS:\par
00067                     {\cf19 if}(cb[0]) {\cf19 return} {\cf17 false};\par
00068                     {\cf19 return} VirtButton::attach_call(callback_func);\par
00069                 \par
00070                 {\cf19 case} EB_TURN_R:\par
00071                     {\cf19 if}(cb[1]) {\cf19 return} {\cf17 false};\par
00072                     {\cf19 return} VirtEncoder::attach_right(callback_func); {\cf20 //todo attach_call}\par
00073 \par
00074                 {\cf19 case} EB_TURN_L:\par
00075                     {\cf19 if}(cb[2]) {\cf19 return} {\cf17 false};\par
00076                     {\cf19 return} VirtEncoder::attach_left(callback_func); {\cf20 //todo attach_call}\par
00077 \par
00078                 {\cf19 case} EB_TURN_HOLD_R:\par
00079                     {\cf19 if}(cb[3]) {\cf19 return} {\cf17 false};\par
00080                     cb[3] = *callback_func;\par
00081                     {\cf19 return} {\cf17 true};\par
00082 \par
00083                 {\cf19 case} EB_TURN_HOLD_L:\par
00084                     {\cf19 if}(cb[4]) {\cf19 return} {\cf17 false};\par
00085                     cb[4] = *callback_func;\par
00086                     {\cf19 return} {\cf17 true};\par
00087 \par
00088                 {\cf19 default}:\par
00089                     {\cf19 return} {\cf17 false};\par
00090             \}\par
00091         \}       \par
00092 {\cf21 #endif}\par
00093         {\cf19 return} {\cf17 false};\par
00094     \}\par
}
}
{\xe \v attach_left\:EncButton}
{\xe \v EncButton\:attach_left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::attach_left ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 105} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00105                                         \{\par
00106 {\cf21 #ifndef EB_NO_CALLBACK}\par
00107         uint8_t l_r = (read_encf(E_REVERSE)) ? 0 : 1;\par
00108         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00109         cb[l_r] = *callback_func;\par
00110         {\cf19 return} {\cf17 true};\par
00111 {\cf21 #endif}\par
00112         {\cf19 return} {\cf17 false};\par
00113     \}\par
}
}
{\xe \v attach_right\:EncButton}
{\xe \v EncButton\:attach_right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::attach_right ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
callback_func can be "cb_t" type \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 89} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00089                                          \{\par
00090 {\cf21 #ifndef EB_NO_CALLBACK}\par
00091         uint8_t l_r = (read_encf(E_REVERSE)) ? 1 : 0;\par
00092         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00093         cb[l_r] = *callback_func;\par
00094         {\cf19 return} {\cf17 true};\par
00095 {\cf21 #endif}\par
00096         {\cf19 return} {\cf17 false};\par
00097     \}\par
}
}
{\xe \v busy\:EncButton}
{\xe \v EncButton\:busy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::busy (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 237} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00237                 \{\par
00238         {\cf19 return} read_btn_flag(B_BUSY);\par
00239     \}\par
}
}
{\xe \v clear\:EncButton}
{\xe \v EncButton\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncButton::clear (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the state of the virtual encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function clears the state of the virtual encoder button, including the button state and encoder state. \par
}{
Definition at line {\b 49} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00049                  \{\par
00050         VirtButton::clear();\par
00051         VirtEncoder::clear();\par
00052     \}\par
}
}
{\xe \v click\:EncButton}
{\xe \v EncButton\:click}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::click (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00162                  \{\par
00163         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD, B_REL_R);\par
00164     \}\par
}
}
{\xe \v clr_btn_flag\:EncButton}
{\xe \v EncButton\:clr_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clr_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 503} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00503                                                                               \{\par
00504         flags &= ~x;\par
00505     \}\par
}
}
{\xe \v clr_encf\:EncButton}
{\xe \v EncButton\:clr_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::clr_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00350                                                                           \{\par
00351         flags &= ~x;\par
00352     \}\par
}
}
{\xe \v detach_call\:EncButton}
{\xe \v EncButton\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncButton::detach_call (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for the virtual encoder button. }}\par
{
Definition at line {\b 99} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00099                       \{\par
00100 {\cf21 #ifndef EB_NO_CALLBACK}\par
00101         VirtButton::detach_call();\par
00102         VirtEncoder::detach_call();\par
00103         cb[3] = {\cf17 nullptr};\par
00104         cb[4] = {\cf17 nullptr};\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v dir\:EncButton}
{\xe \v EncButton\:dir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::dir (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1 if rotated left, 1 if rotated right \par
}}}{
Definition at line {\b 170} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                  \{\par
00171         {\cf19 return} read_encf(E_DIR) ? 1 : -1;\par
00172     \}\par
}
}
{\xe \v encHolding\:EncButton}
{\xe \v EncButton\:encHolding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::encHolding (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is being held. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is being held, false otherwise \par
}}}{
Definition at line {\b 169} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00169                       \{\par
00170         {\cf19 return} read_btn_flag(B_EHLD);\par
00171     \}\par
}
}
{\xe \v eq_btn_flag\:EncButton}
{\xe \v EncButton\:eq_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::eq_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b const} {\b uint16_t}  {\i y}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 513} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00513                                                                                                \{\par
00514         {\cf19 return} (flags & x) == y;\par
00515     \}\par
}
}
{\xe \v fast\:EncButton}
{\xe \v EncButton\:fast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::fast (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is in the fast mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is in the fast mode, false otherwise \par
}}}{
Definition at line {\b 124} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00124                 \{\par
00125         {\cf19 return} read_encf(E_FAST);\par
00126     \}\par
}
}
{\xe \v getClicks\:EncButton}
{\xe \v EncButton\:getClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::getClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                         \{\par
00203         {\cf19 return} clicks;\par
00204     \}\par
}
}
{\xe \v getSteps\:EncButton}
{\xe \v EncButton\:getSteps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::getSteps (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00206                         \{\par
00207 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00208 {\cf21 #ifdef EB_STEP_TIME}\par
00209         {\cf19 return} run_timer ? ((stepFor() + EB_STEP_T - 1) / EB_STEP_T) : 0;  \par
00210 {\cf21 #else}\par
00211         {\cf19 return} run_timer ? ((stepFor() + (EB_STEP_T << EB_SHIFT) - 1) / (EB_STEP_T << EB_SHIFT)) : 0;\par
00212 {\cf21 #endif}\par
00213 {\cf21 #endif}\par
00214         {\cf19 return} 0;\par
00215     \}\par
}
}
{\xe \v hasClicks\:EncButton}
{\xe \v EncButton\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00194                      \{\par
00195         {\cf19 return} eq_btn_flag(B_CLKS_R | B_HLD, B_CLKS_R);\par
00196     \}\par
}
}
{\xe \v hasClicks\:EncButton}
{\xe \v EncButton\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00198                                 \{\par
00199         {\cf19 return} clicks == num && hasClicks();\par
00200     \}\par
}
}
{\xe \v hold\:EncButton}
{\xe \v EncButton\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                 \{\par
00171         {\cf19 return} read_btn_flag(B_HLD_R);\par
00172     \}\par
}
}
{\xe \v hold\:EncButton}
{\xe \v EncButton\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00174                            \{\par
00175         {\cf19 return} clicks == num && hold();\par
00176     \}\par
}
}
{\xe \v holdFor\:EncButton}
{\xe \v EncButton\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::holdFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the duration for which the button has been held.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds. \par
}}}{
Definition at line {\b 313} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                        \{\par
00314 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00315         {\cf19 if} (read_btn_flag(B_HLD)) \{\par
00316 {\cf21 #ifdef EB_HOLD_TIME}\par
00317             {\cf19 return} pressFor() - EB_HOLD_T;\par
00318 {\cf21 #else}\par
00319             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT);\par
00320 {\cf21 #endif}\par
00321         \}\par
00322 {\cf21 #endif}\par
00323         {\cf19 return} 0;\par
00324     \}\par
}
}
{\xe \v holdFor\:EncButton}
{\xe \v EncButton\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holdFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the button has been held for a specified duration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ms} \cell }{The duration in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button has been held for the specified duration, false otherwise. \par
}}}{
Definition at line {\b 332} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00332                               \{\par
00333         {\cf19 return} holdFor() > ms;\par
00334     \}\par
}
}
{\xe \v holding\:EncButton}
{\xe \v EncButton\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00178                    \{\par
00179         {\cf19 return} eq_btn_flag(B_PRS | B_HLD, B_PRS | B_HLD);\par
00180     \}\par
}
}
{\xe \v holding\:EncButton}
{\xe \v EncButton\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                               \{\par
00183         {\cf19 return} clicks == num && holding();\par
00184     \}\par
}
}
{\xe \v init\:EncButton}
{\xe \v EncButton\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::init (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00060                \{\par
00061         setHoldTimeout();\par
00062         setStepTimeout();\par
00063         setClickTimeout();\par
00064         setDebounceTimeout();\par
00065 \par
00066     \}\par
}
}
{\xe \v init\:EncButton}
{\xe \v EncButton\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} EncButton::init ({\b uint8_t}  {\i encA} = {\f2 0}, {\b uint8_t}  {\i encB} = {\f2 0}, {\b uint8_t}  {\i btn} = {\f2 0}, {\b uint8_t}  {\i modeEnc} = {\f2 {\b INPUT}}, {\b uint8_t}  {\i modeBtn} = {\f2 {\b INPUT_PULLUP}}, {\b uint8_t}  {\i btnLevel} = {\f2 {\b LOW}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the {\b EncButton} object with the specified pin and mode values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i encA} \cell }{The pin number for encoder A. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i encB} \cell }{The pin number for encoder B. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The pin number for the button. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i modeEnc} \cell }{The mode for the encoder pins. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i modeBtn} \cell }{The mode for the button pin. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btnLevel} \cell }{The logic level for the button pin when pressed. \cell }
{\row }
}
}{
Definition at line {\b 46} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00046                                                                                                                                                     \{\par
00047         e0 = encA;\par
00048         e1 = encB;\par
00049         b = btn;\par
00050         pinMode(e0, modeEnc);\par
00051         pinMode(e1, modeEnc);\par
00052         pinMode(b, modeBtn);\par
00053         setBtnLevel(btnLevel);\par
00054         initEnc(readEnc());\par
00055     \}\par
}
}
{\xe \v initEnc\:EncButton}
{\xe \v EncButton\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::initEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
}{
Definition at line {\b 134} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                                    \{\par
00135         initEnc(e0 | (e1 << 1));\par
00136     \}\par
}
}
{\xe \v initEnc\:EncButton}
{\xe \v EncButton\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::initEnc (int8_t  {\i v}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v} \cell }{the initial value of the encoder \cell }
{\row }
}
}{
Definition at line {\b 143} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143                            \{\par
00144         prev = v;\par
00145     \}\par
}
}
{\xe \v left\:EncButton}
{\xe \v EncButton\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::left (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left without holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the left without holding the button, false otherwise \par
}}}{
Definition at line {\b 142} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00142                 \{\par
00143         {\cf19 return} !read_encf(E_DIR) && turn() && !read_btn_flag(B_EHLD);\par
00144     \}\par
}
}
{\xe \v leftH\:EncButton}
{\xe \v EncButton\:leftH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::leftH (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left while holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the left while holding the button, false otherwise \par
}}}{
Definition at line {\b 160} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00160                  \{\par
00161         {\cf19 return} !read_encf(E_DIR) && turnH();\par
00162     \}\par
}
}
{\xe \v pollBtn\:EncButton}
{\xe \v EncButton\:pollBtn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pollBtn ({\b bool}  {\i s}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00391                          \{\par
00392         {\cf19 if} (read_btn_flag(B_BISR)) \{\par
00393             clr_btn_flag(B_BISR);\par
00394             s = 1;\par
00395         \} {\cf19 else} s ^= read_btn_flag(B_INV);\par
00396 \par
00397         {\cf19 if} (!read_btn_flag(B_BUSY)) \{\par
00398             {\cf19 if} (s) set_btn_flag(B_BUSY);\par
00399             {\cf19 else} {\cf19 return} 0;\par
00400         \}\par
00401 \par
00402         uint16_t ms = EB_UPTIME();\par
00403         uint16_t deb = ms - timer;\par
00404 \par
00405         {\cf19 if} (s) \{                                      \par
00406             {\cf19 if} (!read_btn_flag(B_PRS)) \{                  \par
00407                 {\cf19 if} (!read_btn_flag(B_DEB) && EB_DEB_T) \{  \par
00408                     set_btn_flag(B_DEB);                   \par
00409                     timer = ms;                         \par
00410                 \} {\cf19 else} \{                                \par
00411                     {\cf19 if} (deb >= EB_DEB_T || !EB_DEB_T) \{ \par
00412                         set_btn_flag(B_PRS | B_PRS_R);      \par
00413 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00414                         run_timer = ms;\par
00415 {\cf21 #endif}\par
00416                         timer = ms;  \par
00417                     \}\par
00418                 \}\par
00419             \} {\cf19 else} \{  \par
00420                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00421                     {\cf19 if} (!read_btn_flag(B_HLD)) \{  \par
00422 {\cf21 #ifdef EB_HOLD_TIME}\par
00423                         {\cf19 if} (deb >= (uint16_t)EB_HOLD_T) \{  \par
00424 {\cf21 #else}\par
00425                         {\cf19 if} (deb >= (uint16_t)(EB_HOLD_T << EB_SHIFT)) \{  \par
00426 {\cf21 #endif}\par
00427                             set_btn_flag(B_HLD_R | B_HLD); \par
00428                             timer = ms;                 \par
00429                         \}\par
00430                     \} {\cf19 else} \{  \par
00431 {\cf21 #ifdef EB_STEP_TIME}\par
00432                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? EB_STEP_T : EB_HOLD_T)) \{\par
00433 {\cf21 #else}\par
00434                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? (EB_STEP_T << EB_SHIFT) : (EB_HOLD_T << EB_SHIFT))) \{\par
00435 {\cf21 #endif}\par
00436                             set_btn_flag(B_STP | B_STP_R);  \par
00437                             timer = ms;                   \par
00438                         \}\par
00439                     \}\par
00440                 \}\par
00441             \}\par
00442         \} {\cf19 else} \{                                     \par
00443             {\cf19 if} (read_btn_flag(B_PRS)) \{                 \par
00444                 {\cf19 if} (deb >= EB_DEB_T) \{               \par
00445                     {\cf19 if} (!read_btn_flag(B_HLD)) clicks++;    \par
00446                     {\cf19 if} (read_btn_flag(B_EHLD)) clicks = 0;  \par
00447                     set_btn_flag(B_REL | B_REL_R);        \par
00448                     clr_btn_flag(B_PRS);                   \par
00449                 \}\par
00450             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_REL)) \{\par
00451                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00452                     set_btn_flag(B_REL_R);\par
00453                 \}\par
00454                 clr_btn_flag(B_REL | B_EHLD);\par
00455                 timer = ms;       \par
00456             \} {\cf19 else} {\cf19 if} (clicks) \{  \par
00457 {\cf21 #ifdef EB_CLICK_TIME}\par
00458                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)EB_CLICK_T) set_btn_flag(B_CLKS_R);  \par
00459 {\cf21 #else}\par
00460                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)(EB_CLICK_T << EB_SHIFT)) set_btn_flag(B_CLKS_R);  \par
00461 {\cf21 #endif}\par
00462 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00463                 {\cf19 else} {\cf19 if} (run_timer) run_timer = 0;\par
00464 {\cf21 #endif}\par
00465             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_BUSY)) \{\par
00466                 clr_btn_flag(B_HLD | B_STP | B_BUSY);\par
00467                 set_btn_flag(B_TOUT);\par
00468 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00469                 run_timer = 0;\par
00470 {\cf21 #endif}\par
00471                 timer = ms;  {\cf20 // test!!}\par
00472             \}\par
00473             {\cf19 if} (read_btn_flag(B_DEB)) clr_btn_flag(B_DEB);  \par
00474         \}\par
00475         {\cf19 return} read_btn_flag(B_CLKS_R | B_PRS_R | B_HLD_R | B_STP_R | B_REL_R);\par
00476     \}\par
}
}
{\xe \v pollEnc\:EncButton}
{\xe \v EncButton\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::pollEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 305} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00305                                      \{\par
00306         {\cf19 return} pollEnc(e0 | (e1 << 1));\par
00307     \}\par
}
}
{\xe \v pollEnc\:EncButton}
{\xe \v EncButton\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::pollEnc (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 315} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00315                                  \{\par
00316         {\cf19 if} (prev != state) \{\par
00317             ecount += ((0x49941661 >> ((state | (prev << 2)) << 1)) & 0b11) - 1;\par
00318             prev = state;\par
00319             {\cf19 if} (!ecount) {\cf19 return} 0;\par
00320             {\cf19 switch} (flags & 0b11) \{\par
00321                 {\cf19 case} EB_STEP4_LOW:\par
00322                     {\cf19 if} (state != 0b11) {\cf19 return} 0;  {\cf20 // skip 00, 01, 10}\par
00323                     {\cf19 break};\par
00324                 {\cf19 case} EB_STEP4_HIGH:\par
00325                     {\cf19 if} (state) {\cf19 return} 0;  {\cf20 // skip 01, 10, 11}\par
00326                     {\cf19 break};\par
00327                 {\cf19 case} EB_STEP2:\par
00328                     {\cf19 if} (state == 0b10 || state == 0b01) {\cf19 return} 0;  {\cf20 // skip 10 01}\par
00329                     {\cf19 break};\par
00330             \}\par
00331             state = ((ecount > 0) ^ read_encf(E_REVERSE)) ? 1 : -1;\par
00332             ecount = 0;\par
00333 {\cf21 #ifndef EB_NO_COUNTER}\par
00334             counter += state;\par
00335 {\cf21 #endif}\par
00336             {\cf19 return} state;\par
00337         \}\par
00338         {\cf19 return} 0;\par
00339     \}\par
}
}
{\xe \v press\:EncButton}
{\xe \v EncButton\:press}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::press (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00154                  \{\par
00155         {\cf19 return} read_btn_flag(B_PRS_R);\par
00156     \}\par
}
}
{\xe \v pressFor\:EncButton}
{\xe \v EncButton\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::pressFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the duration in milliseconds for which the button has been pressed. If the EB_NO_PEDOMETER macro is defined, the function always returns 0. If the button is not currently pressed, the function also returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds for which the button has been pressed. \par
}}}{
Definition at line {\b 297} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00297                         \{\par
00298 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00299         {\cf19 if} (run_timer) {\cf19 return} (uint16_t)EB_UPTIME() - run_timer;\par
00300 {\cf21 #endif}\par
00301         {\cf19 return} 0;\par
00302     \}\par
}
}
{\xe \v pressFor\:EncButton}
{\xe \v EncButton\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 304} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                \{\par
00305         {\cf19 return} pressFor() > ms;\par
00306     \}\par
}
}
{\xe \v pressing\:EncButton}
{\xe \v EncButton\:pressing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressing (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00166                     \{\par
00167         {\cf19 return} read_btn_flag(B_PRS);\par
00168     \}\par
}
}
{\xe \v pressISR\:EncButton}
{\xe \v EncButton\:pressISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::pressISR (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                     \{\par
00113         {\cf19 if} (!read_btn_flag(B_DEB)) timer = EB_UPTIME();\par
00114         set_btn_flag(B_DEB | B_BISR);\par
00115     \}\par
}
}
{\xe \v read_btn_flag\:EncButton}
{\xe \v EncButton\:read_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::read_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 506} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                                                                                \{\par
00507         {\cf19 return} flags & x;\par
00508     \}\par
}
}
{\xe \v read_encf\:EncButton}
{\xe \v EncButton\:read_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::read_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00357                                                                            \{\par
00358         {\cf19 return} flags & x;\par
00359     \}\par
}
}
{\xe \v readBtn\:EncButton}
{\xe \v EncButton\:readBtn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} EncButton::readBtn (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the state of the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button is pressed, false otherwise. \par
}}}{
Definition at line {\b 99} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00099                    \{\par
00100         {\cf19 return} EBread(b) ^ read_btn_flag(B_INV);\par
00101     \}\par
}
}
{\xe \v readEnc\:EncButton}
{\xe \v EncButton\:readEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} EncButton::readEnc (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the value of the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current encoder value. \par
}}}{
Definition at line {\b 108} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                      \{\par
00109         {\cf19 return} EBread(e0) | (EBread(e1) << 1);\par
00110     \}\par
}
}
{\xe \v release\:EncButton}
{\xe \v EncButton\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::release (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00158                    \{\par
00159         {\cf19 return} eq_btn_flag(B_REL_R | B_REL, B_REL_R | B_REL);\par
00160     \}\par
}
}
{\xe \v releaseHold\:EncButton}
{\xe \v EncButton\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                        \{\par
00218         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD | B_STP, B_REL_R | B_HLD);\par
00219     \}\par
}
}
{\xe \v releaseHold\:EncButton}
{\xe \v EncButton\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00221                                   \{\par
00222         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_HLD | B_STP, B_CLKS_R | B_HLD);\par
00223     \}\par
}
}
{\xe \v releaseStep\:EncButton}
{\xe \v EncButton\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00225                        \{\par
00226         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_STP, B_REL_R | B_STP);\par
00227     \}\par
}
}
{\xe \v releaseStep\:EncButton}
{\xe \v EncButton\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00229                                   \{\par
00230         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_STP, B_CLKS_R | B_STP);\par
00231     \}\par
}
}
{\xe \v reset\:EncButton}
{\xe \v EncButton\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::reset (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117                  \{\par
00118         clicks = 0;\par
00119         clr_btn_flag(~B_INV);\par
00120     \}\par
}
}
{\xe \v right\:EncButton}
{\xe \v EncButton\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::right (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right without holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right without holding the button, false otherwise \par
}}}{
Definition at line {\b 133} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00133                  \{\par
00134         {\cf19 return} read_encf(E_DIR) && turn() && !read_btn_flag(B_EHLD);\par
00135     \}\par
}
}
{\xe \v rightH\:EncButton}
{\xe \v EncButton\:rightH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::rightH (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right while holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right while holding the button, false otherwise \par
}}}{
Definition at line {\b 151} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                   \{\par
00152         {\cf19 return} read_encf(E_DIR) && turnH();\par
00153     \}\par
}
}
{\xe \v set_btn_flag\:EncButton}
{\xe \v EncButton\:set_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::set_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 500} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00500                                                                               \{\par
00501         flags |= x;\par
00502     \}\par
}
}
{\xe \v set_encf\:EncButton}
{\xe \v EncButton\:set_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::set_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 347} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00347                                                                           \{\par
00348         flags |= x;\par
00349     \}\par
}
}
{\xe \v setBtnLevel\:EncButton}
{\xe \v EncButton\:setBtnLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setBtnLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                                  \{\par
00109         write_btn_flag(B_INV, !level);\par
00110     \}\par
}
}
{\xe \v setButtonLevel\:EncButton}
{\xe \v EncButton\:setButtonLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setButtonLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00385                                     \{\par
00386         write_btn_flag(B_INV, !level);\par
00387     \}\par
}
}
{\xe \v setClickTimeout\:EncButton}
{\xe \v EncButton\:setClickTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setClickTimeout ({\b uint16_t}  {\i timeout} = {\f2 500}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The click timeout value in milliseconds. Default is 500 milliseconds. Max is 4000ms. \cell }
{\row }
}
}{
Definition at line {\b 96} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096                                                \{\par
00097 {\cf21 #ifndef EB_CLICK_TIME}\par
00098         EB_CLICK_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00099 {\cf21 #endif}\par
00100     \}\par
}
}
{\xe \v setDebounceTimeout\:EncButton}
{\xe \v EncButton\:setDebounceTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setDebounceTimeout ({\b uint8_t}  {\i timeout} = {\f2 50}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00102                                                 \{\par
00103 {\cf21 #ifndef EB_DEB_TIME}\par
00104         EB_DEB_T = (timeout < 255) ? timeout : 255;\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v setEncISR\:EncButton}
{\xe \v EncButton\:setEncISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncISR (bool  {\i use} = {\f2 true}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use} \cell }{true to use the ISR, false otherwise \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Argument "use" by default is true because name of this function means that it is used to set/activate the ISR. \par
}}}{
Definition at line {\b 78} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078                                  \{\par
00079         write_encf(E_ISR, use);\par
00080     \}\par
}
}
{\xe \v setEncReverse\:EncButton}
{\xe \v EncButton\:setEncReverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncReverse (bool  {\i rev} = {\f2 false}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rev} \cell }{true to reverse the encoder, false otherwise \cell }
{\row }
}
}{
Definition at line {\b 57} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00057                                          \{\par
00058         {\cf19 if} (rev) set_encf(E_REVERSE);\par
00059         {\cf19 else} clr_encf(E_REVERSE);\par
00060     \}\par
}
}
{\xe \v setEncType\:EncButton}
{\xe \v EncButton\:setEncType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncType (uint8_t  {\i type} = {\f2 {\b EB_STEP1}}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i type} \cell }{the encoder type to set \cell }
{\row }
}
}{
Definition at line {\b 67} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00067                                              \{\par
00068         flags = (flags & 0b11111100) | type;\par
00069     \}\par
}
}
{\xe \v setFastTimeout\:EncButton}
{\xe \v EncButton\:setFastTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::setFastTimeout ({\b uint8_t}  {\i tout}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the Fast Timeout object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The fast timeout value to set \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the fast timeout was successfully set, false otherwise \par
}}}{
Definition at line {\b 35} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00035                                       \{\par
00036 {\cf21 #ifndef EB_FAST_TIME}\par
00037         EB_FAST_T = tout;\par
00038         {\cf19 return} {\cf17 true};\par
00039 {\cf21 #endif}\par
00040         {\cf19 return} {\cf17 false};\par
00041     \}\par
}
}
{\xe \v setHoldTimeout\:EncButton}
{\xe \v EncButton\:setHoldTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setHoldTimeout ({\b uint16_t}  {\i timeout} = {\f2 600}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The hold timeout value in milliseconds. Default is 600 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 74} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00074                                               \{\par
00075 {\cf21 #ifndef EB_HOLD_TIME}\par
00076         EB_HOLD_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00077 {\cf21 #endif}\par
00078     \}\par
}
}
{\xe \v setStepTimeout\:EncButton}
{\xe \v EncButton\:setStepTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setStepTimeout ({\b uint16_t}  {\i timeout} = {\f2 200}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the step timeout for the virtual button. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The timeout value in milliseconds. Default is 200 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 85} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085                                               \{\par
00086 {\cf21 #ifndef EB_STEP_TIME}\par
00087         EB_STEP_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00088 {\cf21 #endif}\par
00089     \}\par
}
}
{\xe \v step\:EncButton}
{\xe \v EncButton\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                 \{\par
00187         {\cf19 return} read_btn_flag(B_STP_R);\par
00188     \}\par
}
}
{\xe \v step\:EncButton}
{\xe \v EncButton\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190                            \{\par
00191         {\cf19 return} clicks == num && step();\par
00192     \}\par
}
}
{\xe \v stepFor\:EncButton}
{\xe \v EncButton\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::stepFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00336                        \{\par
00337 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00338         {\cf19 if} (read_btn_flag(B_STP)) \{\par
00339 {\cf21 #ifdef EB_HOLD_TIME}\par
00340             {\cf19 return} pressFor() - EB_HOLD_T * 2;\par
00341 {\cf21 #else}\par
00342             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT) * 2;\par
00343 {\cf21 #endif}\par
00344         \}\par
00345 {\cf21 #endif}\par
00346         {\cf19 return} 0;\par
00347     \}\par
}
}
{\xe \v stepFor\:EncButton}
{\xe \v EncButton\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::stepFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 349} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                               \{\par
00350         {\cf19 return} stepFor() > ms;\par
00351     \}\par
}
}
{\xe \v tick\:EncButton}
{\xe \v EncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} EncButton::tick (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a tick operation on the {\b EncButton} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button state changed, false otherwise. \par
}}}{
Definition at line {\b 73} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073                 \{\par
00074         {\cf19 if} (read_encf(E_ISR))\par
00075             {\cf19 return} VirtEncButton::tick(EBread(b));\par
00076         {\cf19 else}\par
00077             {\cf19 return} VirtEncButton::tick(readEnc(), EBread(b));\par
00078     \}\par
}
}
{\xe \v tick\:EncButton}
{\xe \v EncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 324} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00324                         \{\par
00325         {\cf19 return} tick(-1, btn);\par
00326     \}\par
}
}
{\xe \v tick\:EncButton}
{\xe \v EncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tick (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 228} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00228                                   \{\par
00229         {\cf19 return} tick(e0 | (e1 << 1));\par
00230     \}\par
}
}
{\xe \v tick\:EncButton}
{\xe \v EncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b bool}  {\i e0}, {\b bool}  {\i e1}, {\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 276} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00276                                           \{\par
00277         {\cf19 return} tick(e0 | (e1 << 1), btn);\par
00278     \}\par
}
}
{\xe \v tick\:EncButton}
{\xe \v EncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tick (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 238} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                               \{\par
00239         state = tickRaw(state);\par
00240         {\cf19 if} (state)\par
00241         \{\par
00242 {\cf21     #ifndef EB_NO_CALLBACK}\par
00243             {\cf19 if} (cb[0] && state < 0) cb[0]();\par
00244             {\cf19 if} (cb[1] && state > 0) cb[1]();\par
00245 {\cf21     #endif}\par
00246             {\cf19 return} state;\par
00247         \}\par
00248         clear();\par
00249         {\cf19 return} 0;\par
00250     \}\par
}
}
{\xe \v tick\:EncButton}
{\xe \v EncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b int8_t}  {\i state}, {\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 287} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00287                                       \{\par
00288         clear();\par
00289         {\cf18 bool} f = tickRaw(state, btn);\par
00290 \par
00291 {\cf21 #ifndef EB_NO_CALLBACK}\par
00292         {\cf19 if}(f)\{\par
00293             {\cf19 switch} (action())\par
00294             \{\par
00295                 {\cf19 case} EB_PRESS:\par
00296                     {\cf19 if}(cb[0]) (this->cb[0])();\par
00297                     {\cf19 break};\par
00298                 {\cf19 case} EB_TURN_R:\par
00299                     {\cf19 if}(cb[1]) (this->cb[1])();\par
00300                     {\cf19 break};\par
00301                 {\cf19 case} EB_TURN_L:\par
00302                     {\cf19 if}(cb[2]) (this->cb[2])();\par
00303                     {\cf19 break};\par
00304                 {\cf19 case} EB_TURN_HOLD_R:\par
00305                     {\cf19 if}(cb[3]) (this->cb[3])();\par
00306                     {\cf19 break};\par
00307                 {\cf19 case} EB_TURN_HOLD_L:\par
00308                     {\cf19 if}(cb[4]) (this->cb[4])();\par
00309                     {\cf19 break};\par
00310                 {\cf19 default}:\par
00311                     {\cf19 break};\par
00312             \}\par
00313         \}\par
00314 {\cf21 #endif}\par
00315         {\cf19 return} f;\par
00316     \}\par
}
}
{\xe \v tick\:EncButton}
{\xe \v EncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b VirtButton} &  {\i b0}, {\b VirtButton} &  {\i b1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00354                                               \{\par
00355         {\cf19 if} (read_btn_flag(B_BOTH)) \{\par
00356             {\cf19 if} (!b0.pressing() && !b1.pressing()) clr_btn_flag(B_BOTH);\par
00357             {\cf19 if} (!b0.pressing()) b0.reset();\par
00358             {\cf19 if} (!b1.pressing()) b1.reset();\par
00359             b0.clear();\par
00360             b1.clear();\par
00361             {\cf19 return} tick(1);\par
00362         \} {\cf19 else} \{\par
00363             {\cf19 if} (b0.pressing() && b1.pressing()) set_btn_flag(B_BOTH);\par
00364             {\cf19 return} tick(0);\par
00365         \}\par
00366     \}\par
}
}
{\xe \v tickISR\:EncButton}
{\xe \v EncButton\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} EncButton::tickISR (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a tick operation on the {\b EncButton} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The change in encoder value. \par
}}}{
Definition at line {\b 64} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00064                      \{\par
00065         {\cf19 return} VirtEncButton::tickISR(readEnc());\par
00066     \}\par
}
}
{\xe \v tickISR\:EncButton}
{\xe \v EncButton\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncButton::tickISR ({\b bool}  {\i e0}, {\b bool}  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The updated state of the encoder button \par
}}}{
Definition at line {\b 234} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00234                                      \{\par
00235         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00236     \}\par
}
}
{\xe \v tickISR\:EncButton}
{\xe \v EncButton\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncButton::tickISR ({\b int8_t}  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The updated state of the encoder button \par
}}}{
Definition at line {\b 244} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                  \{\par
00245         state = VirtEncoder::pollEnc(state);\par
00246         {\cf19 if} (state) \{\par
00247 {\cf21 #ifdef EB_NO_BUFFER}\par
00248             set_encf(E_ISR_F);\par
00249             write_encf(E_DIR, state > 0);\par
00250             write_encf(E_FAST, checkFast());\par
00251 {\cf21 #else}\par
00252             {\cf19 for} (uint8_t i = 0; i < 15; i += 3) \{\par
00253                 {\cf19 if} (!(ebuffer & (1 << i))) \{\par
00254                     ebuffer |= (1 << i);                 {\cf20 // turn}\par
00255                     {\cf19 if} (state > 0) ebuffer |= E_DIR;    {\cf20 // dir}\par
00256                     {\cf19 if} (checkFast()) ebuffer |= E_FAST;  {\cf20 // fast}\par
00257 \par
00258                     {\cf20 // if (state > 0) ebuffer |= (1 << (i + 1));    // dir}\par
00259                     {\cf20 // if (checkFast()) ebuffer |= (1 << (i + 2));  // fast}\par
00260                     {\cf19 break};\par
00261                 \}\par
00262             \}\par
00263 {\cf21 #endif}\par
00264         \}\par
00265         {\cf19 return} state;\par
00266     \}\par
}
}
{\xe \v tickRaw\:EncButton}
{\xe \v EncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} EncButton::tickRaw (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a raw tick operation on the {\b EncButton} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button state changed, false otherwise. \par
}}}{
Definition at line {\b 85} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085                    \{\par
00086         {\cf19 if} (read_encf(E_ISR))\par
00087             {\cf19 return} VirtEncButton::tickRaw(EBread(b));\par
00088         {\cf19 else}\par
00089             {\cf19 return} VirtEncButton::tickRaw(readEnc(), EBread(b));\par
00090     \}\par
}
}
{\xe \v tickRaw\:EncButton}
{\xe \v EncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 386} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00386                            \{\par
00387         {\cf19 return} tickRaw(-1, btn);\par
00388     \}\par
}
}
{\xe \v tickRaw\:EncButton}
{\xe \v EncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tickRaw (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 268} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00268                                      \{\par
00269         {\cf19 return} tickRaw(e0 | (e1 << 1));\par
00270     \}\par
}
}
{\xe \v tickRaw\:EncButton}
{\xe \v EncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b bool}  {\i e0}, {\b bool}  {\i e1}, {\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 338} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00338                                              \{\par
00339         {\cf19 return} tickRaw(e0 | (e1 << 1), btn);\par
00340     \}\par
}
}
{\xe \v tickRaw\:EncButton}
{\xe \v EncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tickRaw (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00279                                  \{\par
00280         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00281             clr_encf(E_ISR_F);\par
00282             set_encf(E_TRN_R);\par
00283             {\cf19 return} dir();\par
00284         \}\par
00285         {\cf19 if} ((state >= 0) && (state = pollEnc(state))) \{\par
00286             write_encf(E_DIR, state > 0);\par
00287             set_encf(E_TRN_R);\par
00288             {\cf19 return} state;\par
00289         \}\par
00290         {\cf19 return} 0;\par
00291     \}\par
}
}
{\xe \v tickRaw\:EncButton}
{\xe \v EncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b int8_t}  {\i state}, {\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 349} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                                          \{\par
00350         btn = VirtButton::tickRaw(btn);\par
00351 \par
00352         {\cf18 bool} encf = 0;\par
00353 {\cf21 #ifdef EB_NO_BUFFER}\par
00354         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00355             clr_encf(E_ISR_F);\par
00356             encf = 1;\par
00357         \}\par
00358 {\cf21 #else}\par
00359         {\cf19 if} (ebuffer) \{\par
00360             write_encf(E_DIR, ebuffer & 0b10);\par
00361             write_encf(E_FAST, ebuffer & 0b100);\par
00362             ebuffer >>= 3;\par
00363             encf = 1;\par
00364         \}\par
00365 {\cf21 #endif}\par
00366         {\cf19 else} {\cf19 if} ((state >= 0) && (state = VirtEncoder::pollEnc(state))) \{\par
00367             write_encf(E_DIR, state > 0);\par
00368             write_encf(E_FAST, checkFast());\par
00369             encf = 1;\par
00370         \}\par
00371         {\cf19 if} (encf) \{\par
00372             {\cf19 if} (read_btn_flag(B_PRS)) set_btn_flag(B_EHLD);    \par
00373             {\cf19 else} clicks = 0;\par
00374             {\cf19 if} (!read_btn_flag(B_TOUT)) set_btn_flag(B_TOUT);  \par
00375             set_encf(E_TRN_R);                      \par
00376         \}\par
00377         {\cf19 return} encf | btn;\par
00378     \}\par
}
}
{\xe \v timeout\:EncButton}
{\xe \v EncButton\:timeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtButton::timeout (uint16_t  {\i tout}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the timeout has occurred.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The timeout value in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the timeout has occurred, false otherwise. \par
}}}{
Definition at line {\b 282} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00282                                 \{\par
00283         {\cf19 if} (read_btn_flag(B_TOUT) && (uint16_t)((uint16_t)EB_UPTIME() - timer) > tout) \{\par
00284             clr_btn_flag(B_TOUT);\par
00285             {\cf19 return} 1;\par
00286         \}\par
00287         {\cf19 return} 0;\par
00288     \}\par
}
}
{\xe \v turn\:EncButton}
{\xe \v EncButton\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::turn (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder has been turned, false otherwise \par
}}}{
Definition at line {\b 161} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00161                 \{\par
00162         {\cf19 return} read_encf(E_TRN_R);\par
00163     \}\par
}
}
{\xe \v turnH\:EncButton}
{\xe \v EncButton\:turnH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::turnH (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right, false otherwise \par
}}}{
Definition at line {\b 115} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                  \{\par
00116         {\cf19 return} turn() && read_btn_flag(B_EHLD);\par
00117     \}\par
}
}
{\xe \v waiting\:EncButton}
{\xe \v EncButton\:waiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::waiting (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00233                    \{\par
00234         {\cf19 return} clicks && eq_btn_flag(B_PRS | B_REL, 0);\par
00235     \}\par
}
}
{\xe \v write_btn_flag\:EncButton}
{\xe \v EncButton\:write_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::write_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b bool}  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 509} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00509                                                                                         \{\par
00510         {\cf19 if} (v) set_btn_flag(x);\par
00511         {\cf19 else} clr_btn_flag(x);\par
00512     \}\par
}
}
{\xe \v write_encf\:EncButton}
{\xe \v EncButton\:write_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::write_encf (const uint16_t  {\i x}, bool  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00353                                                                                     \{\par
00354         {\cf19 if} (v) set_encf(x);\par
00355         {\cf19 else} clr_encf(x);\par
00356     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:EncButton}
{\xe \v EncButton\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtEncButton::cb[5] = \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\b nullptr}, {\b nullptr}\}{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 396} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00396 \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\cf17 nullptr}, {\cf17 nullptr}\};\par
}
}
{\xe \v clicks\:EncButton}
{\xe \v EncButton\:clicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::clicks{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b VirtButton.h}.}\par
}
{\xe \v counter\:EncButton}
{\xe \v EncButton\:counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int32_t} VirtEncoder::counter = 0{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 342} of file {\b VirtEncoder.h}.}\par
}
{\xe \v EB_CLICK_T\:EncButton}
{\xe \v EncButton\:EB_CLICK_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_CLICK_T = (500 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_DEB_T\:EncButton}
{\xe \v EncButton\:EB_DEB_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_DEB_T = 50{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_FAST_T\:EncButton}
{\xe \v EncButton\:EB_FAST_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtEncButton::EB_FAST_T = 30{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 400} of file {\b VirtEncButton.h}.}\par
}
{\xe \v EB_HOLD_T\:EncButton}
{\xe \v EncButton\:EB_HOLD_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_HOLD_T = (600 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 494} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_STEP_T\:EncButton}
{\xe \v EncButton\:EB_STEP_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_STEP_T = (200 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 497} of file {\b VirtButton.h}.}\par
}
{\xe \v ebuffer\:EncButton}
{\xe \v EncButton\:ebuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtEncButton::ebuffer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 404} of file {\b VirtEncButton.h}.}\par
}
{\xe \v run_timer\:EncButton}
{\xe \v EncButton\:run_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::run_timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 480} of file {\b VirtButton.h}.}\par
}
{\xe \v timer\:EncButton}
{\xe \v EncButton\:timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b EncButton.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EncButtonT< ENCA, ENCB, BTN > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >}
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
\par
{
{\f2 #include <EncButton.h>}}\par
Inheritance diagram for EncButtonT< ENCA, ENCB, BTN >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d4/d03/class_enc_button_t.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EncButtonT} ({\b uint8_t} {\b modeEnc}={\b INPUT}, {\b uint8_t} {\b modeBtn}={\b INPUT_PULLUP}, {\b uint8_t} {\b btnLevel}={\b LOW})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ({\b uint8_t} {\b modeEnc}={\b INPUT}, {\b uint8_t} {\b modeBtn}={\b INPUT_PULLUP}, {\b uint8_t} {\b btnLevel}={\b LOW})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickISR} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b readBtn} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b readEnc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b setFastTimeout} ({\b uint8_t} {\b tout})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the Fast Timeout object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clear} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the state of the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b EB_FLAGS_T} {\b handler}, {\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attaches a callback function to handle a specific event of the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b detach_call} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b turnH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b fast} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is in the fast mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b right} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right without holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b left} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left without holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b rightH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right while holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b leftH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left while holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b encHolding} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is being held. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action of the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickISR} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickISR} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} e0, {\b bool} e1, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b int8_t} {\b state}, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b VirtButton} &{\b b0}, {\b VirtButton} &{\b b1})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tick} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tick} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} e0, {\b bool} e1, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b int8_t} {\b state}, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickRaw} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setHoldTimeout} ({\b uint16_t} {\b timeout}=600)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setStepTimeout} ({\b uint16_t} {\b timeout}=200)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setClickTimeout} ({\b uint16_t} {\b timeout}=500)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setDebounceTimeout} ({\b uint8_t} {\b timeout}=50)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setBtnLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b pressISR} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b press} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b release} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b click} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressing} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b getSteps} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b waiting} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b busy} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b timeout} (uint16_t tout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b pressFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b holdFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holdFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b stepFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b stepFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setButtonLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncReverse} ({\b bool} {\b rev}={\b false})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncType} ({\b uint8_t} {\b type}={\b EB_STEP1})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncISR} ({\b bool} {\b use}={\b true})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_right} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_left} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b initEnc} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b initEnc} ({\b int8_t} {\b v})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b turn} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b dir} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b clicks}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pollBtn} ({\b bool} {\b s})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b eq_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b const} {\b uint16_t} {\b y}) {\b __attribute__}(({\b always_inline}))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} [5] = \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\b nullptr}, {\b nullptr}\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_FAST_T} = 30\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b ebuffer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b run_timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_DEB_T} = 50\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_CLICK_T} = (500 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_HOLD_T} = (600 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_STEP_T} = (200 >> {\b EB_SHIFT})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
tickRaw <br>\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickRaw} ({\b int8_t} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b pollEnc} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b pollEnc} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int32_t} {\b counter} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_encf} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b uint8_t} ENCA, {\b uint8_t} ENCB, {\b uint8_t} BTN>\par
class EncButtonT< ENCA, ENCB, BTN >\par
}
\par
{
Definition at line {\b 119} of file {\b EncButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EncButtonT\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:EncButtonT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} ENCA, {\b uint8_t} ENCB, {\b uint8_t} BTN> {\b EncButtonT}< {\b ENCA}, {\b ENCB}, {\b BTN} >{\b ::EncButtonT} ({\b uint8_t}  {\i modeEnc} = {\f2 {\b INPUT}}, {\b uint8_t}  {\i modeBtn} = {\f2 {\b INPUT_PULLUP}}, {\b uint8_t}  {\i btnLevel} = {\f2 {\b LOW}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                                                                                                 \{\par
00122         init(modeEnc, modeBtn, btnLevel);\par
00123     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtEncButton::action (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action of the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The action of the encoder button \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid todo in binary switch case block e_state + b_state and EB_HOLD + EB_TURN verification if ((state & EB_HOLD) && (state & EB_TURN_R)) return EB_TURN_HOLD_R; \par
}
}{
Definition at line {\b 180} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00180                         \{\par
00181         EB_FLAGS_T e_state =  VirtEncoder::action(); \par
00182         EB_FLAGS_T b_state =  VirtButton::action();\par
00183 \par
00184         {\cf19 if} (e_state == EB_NONE) \{\par
00185             {\cf19 return} b_state; \par
00186         \}\par
00187         \par
00188         {\cf19 if}(b_state == EB_HOLD)\{\par
00189             {\cf19 switch} (e_state)\par
00190             \{\par
00191                 {\cf19 case} EB_TURN_R:\par
00192                     {\cf19 return} EB_TURN_HOLD_R;\par
00193                 {\cf19 case} EB_TURN_L:\par
00194                     {\cf19 return} EB_TURN_HOLD_L;\par
00195                 {\cf19 case} EB_TURN:\par
00196                     {\cf19 return} EB_TURN;\par
00197                 {\cf19 default}:\par
00198                     {\cf19 return} EB_HOLD;\par
00199             \}\par
00200         \}\par
00201         {\cf19 return} e_state;\par
00202 \par
00203 \par
00204         {\cf20 /* needs to be tested}\par
00205 {\cf20 }\par
00206 {\cf20          switch (b_state | e_state)}\par
00207 {\cf20          \{}\par
00208 {\cf20             case 1000000001000:}\par
00209 {\cf20                 return EB_TURN_HOLD_R; //EB_HOLD + EB_TURN_R}\par
00210 {\cf20             case 10000000011000:}\par
00211 {\cf20                 return EB_TURN_HOLD_L; //EB_HOLD + EB_TURN_L}\par
00212 {\cf20             case 10000001000 :}\par
00213 {\cf20                 return EB_TURN;//EB_HOLD + EB_TURN}\par
00214 {\cf20             case (e_state | EB_NONE):}\par
00215 {\cf20                 return e_state; //if b_state == EB_NONE}\par
00216 {\cf20             default:}\par
00217 {\cf20                 return b_state; }\par
00218 {\cf20          \}}\par
00219 {\cf20         }\par
00220 {\cf20         */}\par
00221     \}\par
}
}
{\xe \v attach_call\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::attach_call ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 137} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                           \{ \par
00138 {\cf21 #ifndef EB_NO_CALLBACK}\par
00139         {\cf19 if} (callback_func == {\cf17 nullptr} || cb) {\cf19 return} {\cf17 false};\par
00140         cb = *callback_func;\par
00141         {\cf19 return} {\cf17 true};\par
00142 {\cf21 #endif}\par
00143         {\cf19 return} {\cf17 false};\par
00144     \}\par
}
}
{\xe \v attach_call\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::attach_call ({\b EB_FLAGS_T}  {\i handler}, {\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attaches a callback function to handle a specific event of the virtual encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i handler} \cell }{The event type to attach the callback function to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{The callback function to be attached. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns true if the callback function was successfully attached, false otherwise. \par
}}}{
Definition at line {\b 61} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00061                                                             \{\par
00062 {\cf21 #ifndef EB_NO_CALLBACK}\par
00063         {\cf19 if}(callback_func)\{\par
00064             {\cf19 switch} (handler)\par
00065             \{\par
00066                 {\cf19 case} EB_PRESS:\par
00067                     {\cf19 if}(cb[0]) {\cf19 return} {\cf17 false};\par
00068                     {\cf19 return} VirtButton::attach_call(callback_func);\par
00069                 \par
00070                 {\cf19 case} EB_TURN_R:\par
00071                     {\cf19 if}(cb[1]) {\cf19 return} {\cf17 false};\par
00072                     {\cf19 return} VirtEncoder::attach_right(callback_func); {\cf20 //todo attach_call}\par
00073 \par
00074                 {\cf19 case} EB_TURN_L:\par
00075                     {\cf19 if}(cb[2]) {\cf19 return} {\cf17 false};\par
00076                     {\cf19 return} VirtEncoder::attach_left(callback_func); {\cf20 //todo attach_call}\par
00077 \par
00078                 {\cf19 case} EB_TURN_HOLD_R:\par
00079                     {\cf19 if}(cb[3]) {\cf19 return} {\cf17 false};\par
00080                     cb[3] = *callback_func;\par
00081                     {\cf19 return} {\cf17 true};\par
00082 \par
00083                 {\cf19 case} EB_TURN_HOLD_L:\par
00084                     {\cf19 if}(cb[4]) {\cf19 return} {\cf17 false};\par
00085                     cb[4] = *callback_func;\par
00086                     {\cf19 return} {\cf17 true};\par
00087 \par
00088                 {\cf19 default}:\par
00089                     {\cf19 return} {\cf17 false};\par
00090             \}\par
00091         \}       \par
00092 {\cf21 #endif}\par
00093         {\cf19 return} {\cf17 false};\par
00094     \}\par
}
}
{\xe \v attach_left\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:attach_left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::attach_left ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 105} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00105                                         \{\par
00106 {\cf21 #ifndef EB_NO_CALLBACK}\par
00107         uint8_t l_r = (read_encf(E_REVERSE)) ? 0 : 1;\par
00108         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00109         cb[l_r] = *callback_func;\par
00110         {\cf19 return} {\cf17 true};\par
00111 {\cf21 #endif}\par
00112         {\cf19 return} {\cf17 false};\par
00113     \}\par
}
}
{\xe \v attach_right\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:attach_right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::attach_right ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
callback_func can be "cb_t" type \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 89} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00089                                          \{\par
00090 {\cf21 #ifndef EB_NO_CALLBACK}\par
00091         uint8_t l_r = (read_encf(E_REVERSE)) ? 1 : 0;\par
00092         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00093         cb[l_r] = *callback_func;\par
00094         {\cf19 return} {\cf17 true};\par
00095 {\cf21 #endif}\par
00096         {\cf19 return} {\cf17 false};\par
00097     \}\par
}
}
{\xe \v busy\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:busy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::busy (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 237} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00237                 \{\par
00238         {\cf19 return} read_btn_flag(B_BUSY);\par
00239     \}\par
}
}
{\xe \v clear\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncButton::clear (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the state of the virtual encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function clears the state of the virtual encoder button, including the button state and encoder state. \par
}{
Definition at line {\b 49} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00049                  \{\par
00050         VirtButton::clear();\par
00051         VirtEncoder::clear();\par
00052     \}\par
}
}
{\xe \v click\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:click}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::click (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00162                  \{\par
00163         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD, B_REL_R);\par
00164     \}\par
}
}
{\xe \v clr_btn_flag\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:clr_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clr_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 503} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00503                                                                               \{\par
00504         flags &= ~x;\par
00505     \}\par
}
}
{\xe \v clr_encf\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:clr_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::clr_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00350                                                                           \{\par
00351         flags &= ~x;\par
00352     \}\par
}
}
{\xe \v detach_call\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncButton::detach_call (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for the virtual encoder button. }}\par
{
Definition at line {\b 99} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00099                       \{\par
00100 {\cf21 #ifndef EB_NO_CALLBACK}\par
00101         VirtButton::detach_call();\par
00102         VirtEncoder::detach_call();\par
00103         cb[3] = {\cf17 nullptr};\par
00104         cb[4] = {\cf17 nullptr};\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v dir\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:dir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::dir (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1 if rotated left, 1 if rotated right \par
}}}{
Definition at line {\b 170} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                  \{\par
00171         {\cf19 return} read_encf(E_DIR) ? 1 : -1;\par
00172     \}\par
}
}
{\xe \v encHolding\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:encHolding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::encHolding (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is being held. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is being held, false otherwise \par
}}}{
Definition at line {\b 169} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00169                       \{\par
00170         {\cf19 return} read_btn_flag(B_EHLD);\par
00171     \}\par
}
}
{\xe \v eq_btn_flag\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:eq_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::eq_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b const} {\b uint16_t}  {\i y}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 513} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00513                                                                                                \{\par
00514         {\cf19 return} (flags & x) == y;\par
00515     \}\par
}
}
{\xe \v fast\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:fast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::fast (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is in the fast mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is in the fast mode, false otherwise \par
}}}{
Definition at line {\b 124} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00124                 \{\par
00125         {\cf19 return} read_encf(E_FAST);\par
00126     \}\par
}
}
{\xe \v getClicks\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:getClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::getClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                         \{\par
00203         {\cf19 return} clicks;\par
00204     \}\par
}
}
{\xe \v getSteps\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:getSteps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::getSteps (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00206                         \{\par
00207 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00208 {\cf21 #ifdef EB_STEP_TIME}\par
00209         {\cf19 return} run_timer ? ((stepFor() + EB_STEP_T - 1) / EB_STEP_T) : 0;  \par
00210 {\cf21 #else}\par
00211         {\cf19 return} run_timer ? ((stepFor() + (EB_STEP_T << EB_SHIFT) - 1) / (EB_STEP_T << EB_SHIFT)) : 0;\par
00212 {\cf21 #endif}\par
00213 {\cf21 #endif}\par
00214         {\cf19 return} 0;\par
00215     \}\par
}
}
{\xe \v hasClicks\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00194                      \{\par
00195         {\cf19 return} eq_btn_flag(B_CLKS_R | B_HLD, B_CLKS_R);\par
00196     \}\par
}
}
{\xe \v hasClicks\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00198                                 \{\par
00199         {\cf19 return} clicks == num && hasClicks();\par
00200     \}\par
}
}
{\xe \v hold\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                 \{\par
00171         {\cf19 return} read_btn_flag(B_HLD_R);\par
00172     \}\par
}
}
{\xe \v hold\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00174                            \{\par
00175         {\cf19 return} clicks == num && hold();\par
00176     \}\par
}
}
{\xe \v holdFor\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::holdFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the duration for which the button has been held.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds. \par
}}}{
Definition at line {\b 313} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                        \{\par
00314 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00315         {\cf19 if} (read_btn_flag(B_HLD)) \{\par
00316 {\cf21 #ifdef EB_HOLD_TIME}\par
00317             {\cf19 return} pressFor() - EB_HOLD_T;\par
00318 {\cf21 #else}\par
00319             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT);\par
00320 {\cf21 #endif}\par
00321         \}\par
00322 {\cf21 #endif}\par
00323         {\cf19 return} 0;\par
00324     \}\par
}
}
{\xe \v holdFor\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holdFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the button has been held for a specified duration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ms} \cell }{The duration in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button has been held for the specified duration, false otherwise. \par
}}}{
Definition at line {\b 332} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00332                               \{\par
00333         {\cf19 return} holdFor() > ms;\par
00334     \}\par
}
}
{\xe \v holding\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00178                    \{\par
00179         {\cf19 return} eq_btn_flag(B_PRS | B_HLD, B_PRS | B_HLD);\par
00180     \}\par
}
}
{\xe \v holding\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                               \{\par
00183         {\cf19 return} clicks == num && holding();\par
00184     \}\par
}
}
{\xe \v init\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::init (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00060                \{\par
00061         setHoldTimeout();\par
00062         setStepTimeout();\par
00063         setClickTimeout();\par
00064         setDebounceTimeout();\par
00065 \par
00066     \}\par
}
}
{\xe \v init\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} ENCA, {\b uint8_t} ENCB, {\b uint8_t} BTN> {\b void} {\b EncButtonT}< {\b ENCA}, {\b ENCB}, {\b BTN} >::init ({\b uint8_t}  {\i modeEnc} = {\f2 {\b INPUT}}, {\b uint8_t}  {\i modeBtn} = {\f2 {\b INPUT_PULLUP}}, {\b uint8_t}  {\i btnLevel} = {\f2 {\b LOW}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00125                                                                                                \{\par
00126         pinMode(ENCA, modeEnc);\par
00127         pinMode(ENCB, modeEnc);\par
00128         pinMode(BTN, modeBtn);\par
00129         setBtnLevel(btnLevel);\par
00130         initEnc(readEnc());\par
00131     \}\par
}
}
{\xe \v initEnc\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::initEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
}{
Definition at line {\b 134} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                                    \{\par
00135         initEnc(e0 | (e1 << 1));\par
00136     \}\par
}
}
{\xe \v initEnc\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::initEnc (int8_t  {\i v}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v} \cell }{the initial value of the encoder \cell }
{\row }
}
}{
Definition at line {\b 143} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143                            \{\par
00144         prev = v;\par
00145     \}\par
}
}
{\xe \v left\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::left (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left without holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the left without holding the button, false otherwise \par
}}}{
Definition at line {\b 142} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00142                 \{\par
00143         {\cf19 return} !read_encf(E_DIR) && turn() && !read_btn_flag(B_EHLD);\par
00144     \}\par
}
}
{\xe \v leftH\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:leftH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::leftH (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left while holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the left while holding the button, false otherwise \par
}}}{
Definition at line {\b 160} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00160                  \{\par
00161         {\cf19 return} !read_encf(E_DIR) && turnH();\par
00162     \}\par
}
}
{\xe \v pollBtn\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:pollBtn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pollBtn ({\b bool}  {\i s}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00391                          \{\par
00392         {\cf19 if} (read_btn_flag(B_BISR)) \{\par
00393             clr_btn_flag(B_BISR);\par
00394             s = 1;\par
00395         \} {\cf19 else} s ^= read_btn_flag(B_INV);\par
00396 \par
00397         {\cf19 if} (!read_btn_flag(B_BUSY)) \{\par
00398             {\cf19 if} (s) set_btn_flag(B_BUSY);\par
00399             {\cf19 else} {\cf19 return} 0;\par
00400         \}\par
00401 \par
00402         uint16_t ms = EB_UPTIME();\par
00403         uint16_t deb = ms - timer;\par
00404 \par
00405         {\cf19 if} (s) \{                                      \par
00406             {\cf19 if} (!read_btn_flag(B_PRS)) \{                  \par
00407                 {\cf19 if} (!read_btn_flag(B_DEB) && EB_DEB_T) \{  \par
00408                     set_btn_flag(B_DEB);                   \par
00409                     timer = ms;                         \par
00410                 \} {\cf19 else} \{                                \par
00411                     {\cf19 if} (deb >= EB_DEB_T || !EB_DEB_T) \{ \par
00412                         set_btn_flag(B_PRS | B_PRS_R);      \par
00413 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00414                         run_timer = ms;\par
00415 {\cf21 #endif}\par
00416                         timer = ms;  \par
00417                     \}\par
00418                 \}\par
00419             \} {\cf19 else} \{  \par
00420                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00421                     {\cf19 if} (!read_btn_flag(B_HLD)) \{  \par
00422 {\cf21 #ifdef EB_HOLD_TIME}\par
00423                         {\cf19 if} (deb >= (uint16_t)EB_HOLD_T) \{  \par
00424 {\cf21 #else}\par
00425                         {\cf19 if} (deb >= (uint16_t)(EB_HOLD_T << EB_SHIFT)) \{  \par
00426 {\cf21 #endif}\par
00427                             set_btn_flag(B_HLD_R | B_HLD); \par
00428                             timer = ms;                 \par
00429                         \}\par
00430                     \} {\cf19 else} \{  \par
00431 {\cf21 #ifdef EB_STEP_TIME}\par
00432                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? EB_STEP_T : EB_HOLD_T)) \{\par
00433 {\cf21 #else}\par
00434                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? (EB_STEP_T << EB_SHIFT) : (EB_HOLD_T << EB_SHIFT))) \{\par
00435 {\cf21 #endif}\par
00436                             set_btn_flag(B_STP | B_STP_R);  \par
00437                             timer = ms;                   \par
00438                         \}\par
00439                     \}\par
00440                 \}\par
00441             \}\par
00442         \} {\cf19 else} \{                                     \par
00443             {\cf19 if} (read_btn_flag(B_PRS)) \{                 \par
00444                 {\cf19 if} (deb >= EB_DEB_T) \{               \par
00445                     {\cf19 if} (!read_btn_flag(B_HLD)) clicks++;    \par
00446                     {\cf19 if} (read_btn_flag(B_EHLD)) clicks = 0;  \par
00447                     set_btn_flag(B_REL | B_REL_R);        \par
00448                     clr_btn_flag(B_PRS);                   \par
00449                 \}\par
00450             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_REL)) \{\par
00451                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00452                     set_btn_flag(B_REL_R);\par
00453                 \}\par
00454                 clr_btn_flag(B_REL | B_EHLD);\par
00455                 timer = ms;       \par
00456             \} {\cf19 else} {\cf19 if} (clicks) \{  \par
00457 {\cf21 #ifdef EB_CLICK_TIME}\par
00458                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)EB_CLICK_T) set_btn_flag(B_CLKS_R);  \par
00459 {\cf21 #else}\par
00460                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)(EB_CLICK_T << EB_SHIFT)) set_btn_flag(B_CLKS_R);  \par
00461 {\cf21 #endif}\par
00462 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00463                 {\cf19 else} {\cf19 if} (run_timer) run_timer = 0;\par
00464 {\cf21 #endif}\par
00465             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_BUSY)) \{\par
00466                 clr_btn_flag(B_HLD | B_STP | B_BUSY);\par
00467                 set_btn_flag(B_TOUT);\par
00468 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00469                 run_timer = 0;\par
00470 {\cf21 #endif}\par
00471                 timer = ms;  {\cf20 // test!!}\par
00472             \}\par
00473             {\cf19 if} (read_btn_flag(B_DEB)) clr_btn_flag(B_DEB);  \par
00474         \}\par
00475         {\cf19 return} read_btn_flag(B_CLKS_R | B_PRS_R | B_HLD_R | B_STP_R | B_REL_R);\par
00476     \}\par
}
}
{\xe \v pollEnc\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::pollEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 305} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00305                                      \{\par
00306         {\cf19 return} pollEnc(e0 | (e1 << 1));\par
00307     \}\par
}
}
{\xe \v pollEnc\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::pollEnc (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 315} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00315                                  \{\par
00316         {\cf19 if} (prev != state) \{\par
00317             ecount += ((0x49941661 >> ((state | (prev << 2)) << 1)) & 0b11) - 1;\par
00318             prev = state;\par
00319             {\cf19 if} (!ecount) {\cf19 return} 0;\par
00320             {\cf19 switch} (flags & 0b11) \{\par
00321                 {\cf19 case} EB_STEP4_LOW:\par
00322                     {\cf19 if} (state != 0b11) {\cf19 return} 0;  {\cf20 // skip 00, 01, 10}\par
00323                     {\cf19 break};\par
00324                 {\cf19 case} EB_STEP4_HIGH:\par
00325                     {\cf19 if} (state) {\cf19 return} 0;  {\cf20 // skip 01, 10, 11}\par
00326                     {\cf19 break};\par
00327                 {\cf19 case} EB_STEP2:\par
00328                     {\cf19 if} (state == 0b10 || state == 0b01) {\cf19 return} 0;  {\cf20 // skip 10 01}\par
00329                     {\cf19 break};\par
00330             \}\par
00331             state = ((ecount > 0) ^ read_encf(E_REVERSE)) ? 1 : -1;\par
00332             ecount = 0;\par
00333 {\cf21 #ifndef EB_NO_COUNTER}\par
00334             counter += state;\par
00335 {\cf21 #endif}\par
00336             {\cf19 return} state;\par
00337         \}\par
00338         {\cf19 return} 0;\par
00339     \}\par
}
}
{\xe \v press\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:press}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::press (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00154                  \{\par
00155         {\cf19 return} read_btn_flag(B_PRS_R);\par
00156     \}\par
}
}
{\xe \v pressFor\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::pressFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the duration in milliseconds for which the button has been pressed. If the EB_NO_PEDOMETER macro is defined, the function always returns 0. If the button is not currently pressed, the function also returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds for which the button has been pressed. \par
}}}{
Definition at line {\b 297} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00297                         \{\par
00298 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00299         {\cf19 if} (run_timer) {\cf19 return} (uint16_t)EB_UPTIME() - run_timer;\par
00300 {\cf21 #endif}\par
00301         {\cf19 return} 0;\par
00302     \}\par
}
}
{\xe \v pressFor\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 304} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                \{\par
00305         {\cf19 return} pressFor() > ms;\par
00306     \}\par
}
}
{\xe \v pressing\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:pressing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressing (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00166                     \{\par
00167         {\cf19 return} read_btn_flag(B_PRS);\par
00168     \}\par
}
}
{\xe \v pressISR\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:pressISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::pressISR (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                     \{\par
00113         {\cf19 if} (!read_btn_flag(B_DEB)) timer = EB_UPTIME();\par
00114         set_btn_flag(B_DEB | B_BISR);\par
00115     \}\par
}
}
{\xe \v read_btn_flag\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:read_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::read_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 506} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                                                                                \{\par
00507         {\cf19 return} flags & x;\par
00508     \}\par
}
}
{\xe \v read_encf\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:read_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::read_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00357                                                                            \{\par
00358         {\cf19 return} flags & x;\par
00359     \}\par
}
}
{\xe \v readBtn\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:readBtn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} ENCA, {\b uint8_t} ENCB, {\b uint8_t} BTN> {\b bool} {\b EncButtonT}< {\b ENCA}, {\b ENCB}, {\b BTN} >::readBtn (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00149                    \{\par
00150         {\cf19 return} EBread(BTN) ^ read_btn_flag(B_INV);\par
00151     \}\par
}
}
{\xe \v readEnc\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:readEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} ENCA, {\b uint8_t} ENCB, {\b uint8_t} BTN> {\b int8_t} {\b EncButtonT}< {\b ENCA}, {\b ENCB}, {\b BTN} >::readEnc (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00153                      \{\par
00154         {\cf19 return} EBread(ENCA) | (EBread(ENCB) << 1);\par
00155     \}\par
}
}
{\xe \v release\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::release (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00158                    \{\par
00159         {\cf19 return} eq_btn_flag(B_REL_R | B_REL, B_REL_R | B_REL);\par
00160     \}\par
}
}
{\xe \v releaseHold\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                        \{\par
00218         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD | B_STP, B_REL_R | B_HLD);\par
00219     \}\par
}
}
{\xe \v releaseHold\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00221                                   \{\par
00222         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_HLD | B_STP, B_CLKS_R | B_HLD);\par
00223     \}\par
}
}
{\xe \v releaseStep\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00225                        \{\par
00226         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_STP, B_REL_R | B_STP);\par
00227     \}\par
}
}
{\xe \v releaseStep\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00229                                   \{\par
00230         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_STP, B_CLKS_R | B_STP);\par
00231     \}\par
}
}
{\xe \v reset\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::reset (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117                  \{\par
00118         clicks = 0;\par
00119         clr_btn_flag(~B_INV);\par
00120     \}\par
}
}
{\xe \v right\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::right (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right without holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right without holding the button, false otherwise \par
}}}{
Definition at line {\b 133} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00133                  \{\par
00134         {\cf19 return} read_encf(E_DIR) && turn() && !read_btn_flag(B_EHLD);\par
00135     \}\par
}
}
{\xe \v rightH\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:rightH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::rightH (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right while holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right while holding the button, false otherwise \par
}}}{
Definition at line {\b 151} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                   \{\par
00152         {\cf19 return} read_encf(E_DIR) && turnH();\par
00153     \}\par
}
}
{\xe \v set_btn_flag\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:set_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::set_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 500} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00500                                                                               \{\par
00501         flags |= x;\par
00502     \}\par
}
}
{\xe \v set_encf\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:set_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::set_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 347} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00347                                                                           \{\par
00348         flags |= x;\par
00349     \}\par
}
}
{\xe \v setBtnLevel\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setBtnLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setBtnLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                                  \{\par
00109         write_btn_flag(B_INV, !level);\par
00110     \}\par
}
}
{\xe \v setButtonLevel\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setButtonLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setButtonLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00385                                     \{\par
00386         write_btn_flag(B_INV, !level);\par
00387     \}\par
}
}
{\xe \v setClickTimeout\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setClickTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setClickTimeout ({\b uint16_t}  {\i timeout} = {\f2 500}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The click timeout value in milliseconds. Default is 500 milliseconds. Max is 4000ms. \cell }
{\row }
}
}{
Definition at line {\b 96} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096                                                \{\par
00097 {\cf21 #ifndef EB_CLICK_TIME}\par
00098         EB_CLICK_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00099 {\cf21 #endif}\par
00100     \}\par
}
}
{\xe \v setDebounceTimeout\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setDebounceTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setDebounceTimeout ({\b uint8_t}  {\i timeout} = {\f2 50}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00102                                                 \{\par
00103 {\cf21 #ifndef EB_DEB_TIME}\par
00104         EB_DEB_T = (timeout < 255) ? timeout : 255;\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v setEncISR\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setEncISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncISR (bool  {\i use} = {\f2 true}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use} \cell }{true to use the ISR, false otherwise \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Argument "use" by default is true because name of this function means that it is used to set/activate the ISR. \par
}}}{
Definition at line {\b 78} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078                                  \{\par
00079         write_encf(E_ISR, use);\par
00080     \}\par
}
}
{\xe \v setEncReverse\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setEncReverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncReverse (bool  {\i rev} = {\f2 false}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rev} \cell }{true to reverse the encoder, false otherwise \cell }
{\row }
}
}{
Definition at line {\b 57} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00057                                          \{\par
00058         {\cf19 if} (rev) set_encf(E_REVERSE);\par
00059         {\cf19 else} clr_encf(E_REVERSE);\par
00060     \}\par
}
}
{\xe \v setEncType\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setEncType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncType (uint8_t  {\i type} = {\f2 {\b EB_STEP1}}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i type} \cell }{the encoder type to set \cell }
{\row }
}
}{
Definition at line {\b 67} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00067                                              \{\par
00068         flags = (flags & 0b11111100) | type;\par
00069     \}\par
}
}
{\xe \v setFastTimeout\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setFastTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::setFastTimeout ({\b uint8_t}  {\i tout}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the Fast Timeout object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The fast timeout value to set \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the fast timeout was successfully set, false otherwise \par
}}}{
Definition at line {\b 35} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00035                                       \{\par
00036 {\cf21 #ifndef EB_FAST_TIME}\par
00037         EB_FAST_T = tout;\par
00038         {\cf19 return} {\cf17 true};\par
00039 {\cf21 #endif}\par
00040         {\cf19 return} {\cf17 false};\par
00041     \}\par
}
}
{\xe \v setHoldTimeout\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setHoldTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setHoldTimeout ({\b uint16_t}  {\i timeout} = {\f2 600}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The hold timeout value in milliseconds. Default is 600 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 74} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00074                                               \{\par
00075 {\cf21 #ifndef EB_HOLD_TIME}\par
00076         EB_HOLD_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00077 {\cf21 #endif}\par
00078     \}\par
}
}
{\xe \v setStepTimeout\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:setStepTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setStepTimeout ({\b uint16_t}  {\i timeout} = {\f2 200}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the step timeout for the virtual button. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The timeout value in milliseconds. Default is 200 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 85} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085                                               \{\par
00086 {\cf21 #ifndef EB_STEP_TIME}\par
00087         EB_STEP_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00088 {\cf21 #endif}\par
00089     \}\par
}
}
{\xe \v step\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                 \{\par
00187         {\cf19 return} read_btn_flag(B_STP_R);\par
00188     \}\par
}
}
{\xe \v step\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190                            \{\par
00191         {\cf19 return} clicks == num && step();\par
00192     \}\par
}
}
{\xe \v stepFor\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::stepFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00336                        \{\par
00337 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00338         {\cf19 if} (read_btn_flag(B_STP)) \{\par
00339 {\cf21 #ifdef EB_HOLD_TIME}\par
00340             {\cf19 return} pressFor() - EB_HOLD_T * 2;\par
00341 {\cf21 #else}\par
00342             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT) * 2;\par
00343 {\cf21 #endif}\par
00344         \}\par
00345 {\cf21 #endif}\par
00346         {\cf19 return} 0;\par
00347     \}\par
}
}
{\xe \v stepFor\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::stepFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 349} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                               \{\par
00350         {\cf19 return} stepFor() > ms;\par
00351     \}\par
}
}
{\xe \v tick\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} ENCA, {\b uint8_t} ENCB, {\b uint8_t} BTN> {\b bool} {\b EncButtonT}< {\b ENCA}, {\b ENCB}, {\b BTN} >::tick (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00138                 \{\par
00139         {\cf19 if} (read_encf(E_ISR)) {\cf19 return} VirtEncButton::tick(EBread(BTN));\par
00140         {\cf19 else} {\cf19 return} VirtEncButton::tick(readEnc(), EBread(BTN));\par
00141     \}\par
}
}
{\xe \v tick\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 324} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00324                         \{\par
00325         {\cf19 return} tick(-1, btn);\par
00326     \}\par
}
}
{\xe \v tick\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tick (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 228} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00228                                   \{\par
00229         {\cf19 return} tick(e0 | (e1 << 1));\par
00230     \}\par
}
}
{\xe \v tick\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b bool}  {\i e0}, {\b bool}  {\i e1}, {\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 276} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00276                                           \{\par
00277         {\cf19 return} tick(e0 | (e1 << 1), btn);\par
00278     \}\par
}
}
{\xe \v tick\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tick (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 238} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                               \{\par
00239         state = tickRaw(state);\par
00240         {\cf19 if} (state)\par
00241         \{\par
00242 {\cf21     #ifndef EB_NO_CALLBACK}\par
00243             {\cf19 if} (cb[0] && state < 0) cb[0]();\par
00244             {\cf19 if} (cb[1] && state > 0) cb[1]();\par
00245 {\cf21     #endif}\par
00246             {\cf19 return} state;\par
00247         \}\par
00248         clear();\par
00249         {\cf19 return} 0;\par
00250     \}\par
}
}
{\xe \v tick\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b int8_t}  {\i state}, {\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 287} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00287                                       \{\par
00288         clear();\par
00289         {\cf18 bool} f = tickRaw(state, btn);\par
00290 \par
00291 {\cf21 #ifndef EB_NO_CALLBACK}\par
00292         {\cf19 if}(f)\{\par
00293             {\cf19 switch} (action())\par
00294             \{\par
00295                 {\cf19 case} EB_PRESS:\par
00296                     {\cf19 if}(cb[0]) (this->cb[0])();\par
00297                     {\cf19 break};\par
00298                 {\cf19 case} EB_TURN_R:\par
00299                     {\cf19 if}(cb[1]) (this->cb[1])();\par
00300                     {\cf19 break};\par
00301                 {\cf19 case} EB_TURN_L:\par
00302                     {\cf19 if}(cb[2]) (this->cb[2])();\par
00303                     {\cf19 break};\par
00304                 {\cf19 case} EB_TURN_HOLD_R:\par
00305                     {\cf19 if}(cb[3]) (this->cb[3])();\par
00306                     {\cf19 break};\par
00307                 {\cf19 case} EB_TURN_HOLD_L:\par
00308                     {\cf19 if}(cb[4]) (this->cb[4])();\par
00309                     {\cf19 break};\par
00310                 {\cf19 default}:\par
00311                     {\cf19 break};\par
00312             \}\par
00313         \}\par
00314 {\cf21 #endif}\par
00315         {\cf19 return} f;\par
00316     \}\par
}
}
{\xe \v tick\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b VirtButton} &  {\i b0}, {\b VirtButton} &  {\i b1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00354                                               \{\par
00355         {\cf19 if} (read_btn_flag(B_BOTH)) \{\par
00356             {\cf19 if} (!b0.pressing() && !b1.pressing()) clr_btn_flag(B_BOTH);\par
00357             {\cf19 if} (!b0.pressing()) b0.reset();\par
00358             {\cf19 if} (!b1.pressing()) b1.reset();\par
00359             b0.clear();\par
00360             b1.clear();\par
00361             {\cf19 return} tick(1);\par
00362         \} {\cf19 else} \{\par
00363             {\cf19 if} (b0.pressing() && b1.pressing()) set_btn_flag(B_BOTH);\par
00364             {\cf19 return} tick(0);\par
00365         \}\par
00366     \}\par
}
}
{\xe \v tickISR\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} ENCA, {\b uint8_t} ENCB, {\b uint8_t} BTN> {\b int8_t} {\b EncButtonT}< {\b ENCA}, {\b ENCB}, {\b BTN} >::tickISR (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                      \{\par
00135         {\cf19 return} VirtEncButton::tickISR(readEnc());\par
00136     \}\par
}
}
{\xe \v tickISR\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncButton::tickISR ({\b bool}  {\i e0}, {\b bool}  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The updated state of the encoder button \par
}}}{
Definition at line {\b 234} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00234                                      \{\par
00235         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00236     \}\par
}
}
{\xe \v tickISR\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncButton::tickISR ({\b int8_t}  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The updated state of the encoder button \par
}}}{
Definition at line {\b 244} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                  \{\par
00245         state = VirtEncoder::pollEnc(state);\par
00246         {\cf19 if} (state) \{\par
00247 {\cf21 #ifdef EB_NO_BUFFER}\par
00248             set_encf(E_ISR_F);\par
00249             write_encf(E_DIR, state > 0);\par
00250             write_encf(E_FAST, checkFast());\par
00251 {\cf21 #else}\par
00252             {\cf19 for} (uint8_t i = 0; i < 15; i += 3) \{\par
00253                 {\cf19 if} (!(ebuffer & (1 << i))) \{\par
00254                     ebuffer |= (1 << i);                 {\cf20 // turn}\par
00255                     {\cf19 if} (state > 0) ebuffer |= E_DIR;    {\cf20 // dir}\par
00256                     {\cf19 if} (checkFast()) ebuffer |= E_FAST;  {\cf20 // fast}\par
00257 \par
00258                     {\cf20 // if (state > 0) ebuffer |= (1 << (i + 1));    // dir}\par
00259                     {\cf20 // if (checkFast()) ebuffer |= (1 << (i + 2));  // fast}\par
00260                     {\cf19 break};\par
00261                 \}\par
00262             \}\par
00263 {\cf21 #endif}\par
00264         \}\par
00265         {\cf19 return} state;\par
00266     \}\par
}
}
{\xe \v tickRaw\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint8_t} ENCA, {\b uint8_t} ENCB, {\b uint8_t} BTN> {\b bool} {\b EncButtonT}< {\b ENCA}, {\b ENCB}, {\b BTN} >::tickRaw (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b EncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143                    \{\par
00144         {\cf19 if} (read_encf(E_ISR)) {\cf19 return} VirtEncButton::tickRaw(EBread(BTN));\par
00145         {\cf19 else} {\cf19 return} VirtEncButton::tickRaw(readEnc(), EBread(BTN));\par
00146     \}\par
}
}
{\xe \v tickRaw\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 386} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00386                            \{\par
00387         {\cf19 return} tickRaw(-1, btn);\par
00388     \}\par
}
}
{\xe \v tickRaw\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tickRaw (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 268} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00268                                      \{\par
00269         {\cf19 return} tickRaw(e0 | (e1 << 1));\par
00270     \}\par
}
}
{\xe \v tickRaw\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b bool}  {\i e0}, {\b bool}  {\i e1}, {\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 338} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00338                                              \{\par
00339         {\cf19 return} tickRaw(e0 | (e1 << 1), btn);\par
00340     \}\par
}
}
{\xe \v tickRaw\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tickRaw (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00279                                  \{\par
00280         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00281             clr_encf(E_ISR_F);\par
00282             set_encf(E_TRN_R);\par
00283             {\cf19 return} dir();\par
00284         \}\par
00285         {\cf19 if} ((state >= 0) && (state = pollEnc(state))) \{\par
00286             write_encf(E_DIR, state > 0);\par
00287             set_encf(E_TRN_R);\par
00288             {\cf19 return} state;\par
00289         \}\par
00290         {\cf19 return} 0;\par
00291     \}\par
}
}
{\xe \v tickRaw\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b int8_t}  {\i state}, {\b bool}  {\i btn}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 349} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                                          \{\par
00350         btn = VirtButton::tickRaw(btn);\par
00351 \par
00352         {\cf18 bool} encf = 0;\par
00353 {\cf21 #ifdef EB_NO_BUFFER}\par
00354         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00355             clr_encf(E_ISR_F);\par
00356             encf = 1;\par
00357         \}\par
00358 {\cf21 #else}\par
00359         {\cf19 if} (ebuffer) \{\par
00360             write_encf(E_DIR, ebuffer & 0b10);\par
00361             write_encf(E_FAST, ebuffer & 0b100);\par
00362             ebuffer >>= 3;\par
00363             encf = 1;\par
00364         \}\par
00365 {\cf21 #endif}\par
00366         {\cf19 else} {\cf19 if} ((state >= 0) && (state = VirtEncoder::pollEnc(state))) \{\par
00367             write_encf(E_DIR, state > 0);\par
00368             write_encf(E_FAST, checkFast());\par
00369             encf = 1;\par
00370         \}\par
00371         {\cf19 if} (encf) \{\par
00372             {\cf19 if} (read_btn_flag(B_PRS)) set_btn_flag(B_EHLD);    \par
00373             {\cf19 else} clicks = 0;\par
00374             {\cf19 if} (!read_btn_flag(B_TOUT)) set_btn_flag(B_TOUT);  \par
00375             set_encf(E_TRN_R);                      \par
00376         \}\par
00377         {\cf19 return} encf | btn;\par
00378     \}\par
}
}
{\xe \v timeout\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:timeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtButton::timeout (uint16_t  {\i tout}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the timeout has occurred.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The timeout value in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the timeout has occurred, false otherwise. \par
}}}{
Definition at line {\b 282} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00282                                 \{\par
00283         {\cf19 if} (read_btn_flag(B_TOUT) && (uint16_t)((uint16_t)EB_UPTIME() - timer) > tout) \{\par
00284             clr_btn_flag(B_TOUT);\par
00285             {\cf19 return} 1;\par
00286         \}\par
00287         {\cf19 return} 0;\par
00288     \}\par
}
}
{\xe \v turn\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::turn (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder has been turned, false otherwise \par
}}}{
Definition at line {\b 161} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00161                 \{\par
00162         {\cf19 return} read_encf(E_TRN_R);\par
00163     \}\par
}
}
{\xe \v turnH\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:turnH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::turnH (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right, false otherwise \par
}}}{
Definition at line {\b 115} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                  \{\par
00116         {\cf19 return} turn() && read_btn_flag(B_EHLD);\par
00117     \}\par
}
}
{\xe \v waiting\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:waiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::waiting (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00233                    \{\par
00234         {\cf19 return} clicks && eq_btn_flag(B_PRS | B_REL, 0);\par
00235     \}\par
}
}
{\xe \v write_btn_flag\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:write_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::write_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b bool}  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 509} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00509                                                                                         \{\par
00510         {\cf19 if} (v) set_btn_flag(x);\par
00511         {\cf19 else} clr_btn_flag(x);\par
00512     \}\par
}
}
{\xe \v write_encf\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:write_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::write_encf (const uint16_t  {\i x}, bool  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00353                                                                                     \{\par
00354         {\cf19 if} (v) set_encf(x);\par
00355         {\cf19 else} clr_encf(x);\par
00356     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtEncButton::cb[5] = \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\b nullptr}, {\b nullptr}\}{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 396} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00396 \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\cf17 nullptr}, {\cf17 nullptr}\};\par
}
}
{\xe \v clicks\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:clicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::clicks{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b VirtButton.h}.}\par
}
{\xe \v counter\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int32_t} VirtEncoder::counter = 0{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 342} of file {\b VirtEncoder.h}.}\par
}
{\xe \v EB_CLICK_T\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:EB_CLICK_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_CLICK_T = (500 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_DEB_T\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:EB_DEB_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_DEB_T = 50{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_FAST_T\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:EB_FAST_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtEncButton::EB_FAST_T = 30{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 400} of file {\b VirtEncButton.h}.}\par
}
{\xe \v EB_HOLD_T\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:EB_HOLD_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_HOLD_T = (600 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 494} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_STEP_T\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:EB_STEP_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_STEP_T = (200 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 497} of file {\b VirtButton.h}.}\par
}
{\xe \v ebuffer\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:ebuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtEncButton::ebuffer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 404} of file {\b VirtEncButton.h}.}\par
}
{\xe \v run_timer\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:run_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::run_timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 480} of file {\b VirtButton.h}.}\par
}
{\xe \v timer\:EncButtonT< ENCA, ENCB, BTN >}
{\xe \v EncButtonT< ENCA, ENCB, BTN >\:timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b EncButton.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Encoder Class Reference\par \pard\plain 
{\tc\tcl2 \v Encoder}
{\xe \v Encoder}
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Encoder} class represents an encoder device. }}\par
{
{\f2 #include <Encoder.h>}}\par
Inheritance diagram for Encoder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d3/d01/class_encoder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Encoder} (uint8_t encA=0, uint8_t encB=0, uint8_t mode=INPUT)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an {\b Encoder} object with the specified pin numbers and mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (uint8_t encA=0, uint8_t encB=0, uint8_t mode=INPUT)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the encoder with the specified pin numbers and mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickISR} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a tick operation on the encoder using an interrupt service routine (ISR). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a tick operation on the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a raw tick operation on the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncReverse} (bool rev=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncType} (uint8_t type={\b EB_STEP1})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncISR} (bool use=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b attach_right} ({\b cb_t} callback_func)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b attach_left} ({\b cb_t} callback_func)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b detach_call} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for handling encoder events. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initEnc} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initEnc} (int8_t v)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the encoder flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b turn} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b dir} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing the possible flags for the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickISR} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickISR} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
tickRaw <br>\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} (int8_t state)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b pollEnc} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b pollEnc} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b counter} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} [2] = \{nullptr, nullptr\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_encf} (const uint16_t x) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_encf} (const uint16_t x) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_encf} (const uint16_t x, bool v) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b read_encf} (const uint16_t x) __attribute__((always_inline))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Encoder} class represents an encoder device. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class inherits from the {\b VirtEncoder} class and provides additional functionality for initializing and reading the encoder. \par
}{
Definition at line {\b 17} of file {\b Encoder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Encoder\:Encoder}
{\xe \v Encoder\:Encoder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Encoder::Encoder (uint8_t  {\i encA} = {\f2 0}, uint8_t  {\i encB} = {\f2 0}, uint8_t  {\i mode} = {\f2 INPUT}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an {\b Encoder} object with the specified pin numbers and mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i encA} \cell }{The pin number for encoder A. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i encB} \cell }{The pin number for encoder B. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mode} \cell }{The mode of the pins (INPUT, OUTPUT, INPUT_PULLUP, etc.). \cell }
{\row }
}
}{
Definition at line {\b 26} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00026                                                                       \{\par
00027         init(encA, encB, mode);\par
00028     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:Encoder}
{\xe \v Encoder\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtEncoder::action (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing the possible flags for the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
EB_FLAGS_T can have the following values:{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN: Represents the flag for turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN_L: Represents the flag for left turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN_R: Represents the flag for right turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_NONE: Represents the flag for no action. \par}
}}}{
Definition at line {\b 182} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                         \{\par
00183         {\cf19 switch} (flags & 0b111111111) \{\par
00184             {\cf19 case}(E_TRN_R | E_FAST):\par
00185                 {\cf19 return} EB_TURN;\par
00186             {\cf19 case}(E_TRN_R | E_DIR | E_REVERSE):\par
00187                 {\cf19 return} EB_TURN_L;\par
00188             {\cf19 case}(E_TRN_R | E_DIR):\par
00189                 {\cf19 return} EB_TURN_R;   \par
00190             {\cf19 default}:\par
00191                 {\cf19 return} EB_NONE;\par
00192         \}\par
00193     \}\par
}
}
{\xe \v attach_left\:Encoder}
{\xe \v Encoder\:attach_left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::attach_left ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 105} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00105                                         \{\par
00106 {\cf21 #ifndef EB_NO_CALLBACK}\par
00107         uint8_t l_r = (read_encf(E_REVERSE)) ? 0 : 1;\par
00108         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00109         cb[l_r] = *callback_func;\par
00110         {\cf19 return} {\cf17 true};\par
00111 {\cf21 #endif}\par
00112         {\cf19 return} {\cf17 false};\par
00113     \}\par
}
}
{\xe \v attach_right\:Encoder}
{\xe \v Encoder\:attach_right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::attach_right ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
callback_func can be "cb_t" type \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 89} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00089                                          \{\par
00090 {\cf21 #ifndef EB_NO_CALLBACK}\par
00091         uint8_t l_r = (read_encf(E_REVERSE)) ? 1 : 0;\par
00092         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00093         cb[l_r] = *callback_func;\par
00094         {\cf19 return} {\cf17 true};\par
00095 {\cf21 #endif}\par
00096         {\cf19 return} {\cf17 false};\par
00097     \}\par
}
}
{\xe \v clear\:Encoder}
{\xe \v Encoder\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::clear (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the encoder flags. }}\par
{
Definition at line {\b 150} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00150                  \{\par
00151         {\cf19 if} (read_encf(E_TRN_R)) clr_encf(E_TRN_R);\par
00152     \}\par
}
}
{\xe \v clr_encf\:Encoder}
{\xe \v Encoder\:clr_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::clr_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00350                                                                           \{\par
00351         flags &= ~x;\par
00352     \}\par
}
}
{\xe \v detach_call\:Encoder}
{\xe \v Encoder\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::detach_call (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for handling encoder events. }}\par
{
Definition at line {\b 121} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                        \{\par
00122 {\cf21 #ifndef EB_NO_CALLBACK}\par
00123         cb[0] = {\cf17 nullptr};\par
00124         cb[1] = {\cf17 nullptr};\par
00125 {\cf21 #endif}\par
00126     \}\par
}
}
{\xe \v dir\:Encoder}
{\xe \v Encoder\:dir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::dir (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1 if rotated left, 1 if rotated right \par
}}}{
Definition at line {\b 170} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                  \{\par
00171         {\cf19 return} read_encf(E_DIR) ? 1 : -1;\par
00172     \}\par
}
}
{\xe \v init\:Encoder}
{\xe \v Encoder\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Encoder::init (uint8_t  {\i encA} = {\f2 0}, uint8_t  {\i encB} = {\f2 0}, uint8_t  {\i mode} = {\f2 INPUT}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the encoder with the specified pin numbers and mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i encA} \cell }{The pin number for encoder A. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i encB} \cell }{The pin number for encoder B. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mode} \cell }{The mode of the pins (INPUT, OUTPUT, INPUT_PULLUP, etc.). \cell }
{\row }
}
}{
Definition at line {\b 37} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037                                                                         \{\par
00038         e0 = encA;\par
00039         e1 = encB;\par
00040         pinMode(e0, mode);\par
00041         pinMode(e1, mode);\par
00042         initEnc(readEnc());\par
00043     \}\par
}
}
{\xe \v initEnc\:Encoder}
{\xe \v Encoder\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::initEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
}{
Definition at line {\b 134} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                                    \{\par
00135         initEnc(e0 | (e1 << 1));\par
00136     \}\par
}
}
{\xe \v initEnc\:Encoder}
{\xe \v Encoder\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::initEnc (int8_t  {\i v}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v} \cell }{the initial value of the encoder \cell }
{\row }
}
}{
Definition at line {\b 143} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143                            \{\par
00144         prev = v;\par
00145     \}\par
}
}
{\xe \v pollEnc\:Encoder}
{\xe \v Encoder\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::pollEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 305} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00305                                      \{\par
00306         {\cf19 return} pollEnc(e0 | (e1 << 1));\par
00307     \}\par
}
}
{\xe \v pollEnc\:Encoder}
{\xe \v Encoder\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::pollEnc (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 315} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00315                                  \{\par
00316         {\cf19 if} (prev != state) \{\par
00317             ecount += ((0x49941661 >> ((state | (prev << 2)) << 1)) & 0b11) - 1;\par
00318             prev = state;\par
00319             {\cf19 if} (!ecount) {\cf19 return} 0;\par
00320             {\cf19 switch} (flags & 0b11) \{\par
00321                 {\cf19 case} EB_STEP4_LOW:\par
00322                     {\cf19 if} (state != 0b11) {\cf19 return} 0;  {\cf20 // skip 00, 01, 10}\par
00323                     {\cf19 break};\par
00324                 {\cf19 case} EB_STEP4_HIGH:\par
00325                     {\cf19 if} (state) {\cf19 return} 0;  {\cf20 // skip 01, 10, 11}\par
00326                     {\cf19 break};\par
00327                 {\cf19 case} EB_STEP2:\par
00328                     {\cf19 if} (state == 0b10 || state == 0b01) {\cf19 return} 0;  {\cf20 // skip 10 01}\par
00329                     {\cf19 break};\par
00330             \}\par
00331             state = ((ecount > 0) ^ read_encf(E_REVERSE)) ? 1 : -1;\par
00332             ecount = 0;\par
00333 {\cf21 #ifndef EB_NO_COUNTER}\par
00334             counter += state;\par
00335 {\cf21 #endif}\par
00336             {\cf19 return} state;\par
00337         \}\par
00338         {\cf19 return} 0;\par
00339     \}\par
}
}
{\xe \v read_encf\:Encoder}
{\xe \v Encoder\:read_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::read_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00357                                                                            \{\par
00358         {\cf19 return} flags & x;\par
00359     \}\par
}
}
{\xe \v set_encf\:Encoder}
{\xe \v Encoder\:set_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::set_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 347} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00347                                                                           \{\par
00348         flags |= x;\par
00349     \}\par
}
}
{\xe \v setEncISR\:Encoder}
{\xe \v Encoder\:setEncISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncISR (bool  {\i use} = {\f2 true}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use} \cell }{true to use the ISR, false otherwise \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Argument "use" by default is true because name of this function means that it is used to set/activate the ISR. \par
}}}{
Definition at line {\b 78} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078                                  \{\par
00079         write_encf(E_ISR, use);\par
00080     \}\par
}
}
{\xe \v setEncReverse\:Encoder}
{\xe \v Encoder\:setEncReverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncReverse (bool  {\i rev} = {\f2 false}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rev} \cell }{true to reverse the encoder, false otherwise \cell }
{\row }
}
}{
Definition at line {\b 57} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00057                                          \{\par
00058         {\cf19 if} (rev) set_encf(E_REVERSE);\par
00059         {\cf19 else} clr_encf(E_REVERSE);\par
00060     \}\par
}
}
{\xe \v setEncType\:Encoder}
{\xe \v Encoder\:setEncType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncType (uint8_t  {\i type} = {\f2 {\b EB_STEP1}}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i type} \cell }{the encoder type to set \cell }
{\row }
}
}{
Definition at line {\b 67} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00067                                              \{\par
00068         flags = (flags & 0b11111100) | type;\par
00069     \}\par
}
}
{\xe \v tick\:Encoder}
{\xe \v Encoder\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t Encoder::tick (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a tick operation on the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the encoder has an interrupt flag set, it uses the interrupt-based tick operation. Otherwise, it uses the regular tick operation.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The change in encoder position. \par
}}}{
Definition at line {\b 61} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00061                   \{\par
00062         {\cf19 if} (read_encf(E_ISR))\par
00063             {\cf19 return} VirtEncoder::tick();\par
00064         {\cf19 else}\par
00065             {\cf19 return} VirtEncoder::tick(readEnc());\par
00066     \}\par
}
}
{\xe \v tick\:Encoder}
{\xe \v Encoder\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tick (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 228} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00228                                   \{\par
00229         {\cf19 return} tick(e0 | (e1 << 1));\par
00230     \}\par
}
}
{\xe \v tick\:Encoder}
{\xe \v Encoder\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tick (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 238} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                               \{\par
00239         state = tickRaw(state);\par
00240         {\cf19 if} (state)\par
00241         \{\par
00242 {\cf21     #ifndef EB_NO_CALLBACK}\par
00243             {\cf19 if} (cb[0] && state < 0) cb[0]();\par
00244             {\cf19 if} (cb[1] && state > 0) cb[1]();\par
00245 {\cf21     #endif}\par
00246             {\cf19 return} state;\par
00247         \}\par
00248         clear();\par
00249         {\cf19 return} 0;\par
00250     \}\par
}
}
{\xe \v tickISR\:Encoder}
{\xe \v Encoder\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t Encoder::tickISR (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a tick operation on the encoder using an interrupt service routine (ISR). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The change in encoder position. \par
}}}{
Definition at line {\b 50} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00050                      \{\par
00051         {\cf19 return} VirtEncoder::tickISR(readEnc());\par
00052     \}\par
}
}
{\xe \v tickISR\:Encoder}
{\xe \v Encoder\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickISR (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 202} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                                      \{\par
00203         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00204     \}\par
}
}
{\xe \v tickISR\:Encoder}
{\xe \v Encoder\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickISR (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 212} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00212                                  \{\par
00213         state = pollEnc(state);\par
00214         {\cf19 if} (state) \{\par
00215             set_encf(E_ISR_F);\par
00216             write_encf(E_DIR, state > 0);\par
00217         \}\par
00218         {\cf19 return} state;\par
00219     \}\par
}
}
{\xe \v tickRaw\:Encoder}
{\xe \v Encoder\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t Encoder::tickRaw (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a raw tick operation on the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the encoder has an interrupt flag set, it uses the interrupt-based raw tick operation. Otherwise, it uses the regular raw tick operation.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The change in encoder position. \par
}}}{
Definition at line {\b 75} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00075                      \{\par
00076         {\cf19 if} (read_encf(E_ISR))\par
00077             {\cf19 return} VirtEncoder::tickRaw();\par
00078         {\cf19 else}\par
00079             {\cf19 return} VirtEncoder::tickRaw(readEnc());\par
00080     \}\par
}
}
{\xe \v tickRaw\:Encoder}
{\xe \v Encoder\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickRaw (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 268} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00268                                      \{\par
00269         {\cf19 return} tickRaw(e0 | (e1 << 1));\par
00270     \}\par
}
}
{\xe \v tickRaw\:Encoder}
{\xe \v Encoder\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickRaw (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00279                                  \{\par
00280         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00281             clr_encf(E_ISR_F);\par
00282             set_encf(E_TRN_R);\par
00283             {\cf19 return} dir();\par
00284         \}\par
00285         {\cf19 if} ((state >= 0) && (state = pollEnc(state))) \{\par
00286             write_encf(E_DIR, state > 0);\par
00287             set_encf(E_TRN_R);\par
00288             {\cf19 return} state;\par
00289         \}\par
00290         {\cf19 return} 0;\par
00291     \}\par
}
}
{\xe \v turn\:Encoder}
{\xe \v Encoder\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::turn (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder has been turned, false otherwise \par
}}}{
Definition at line {\b 161} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00161                 \{\par
00162         {\cf19 return} read_encf(E_TRN_R);\par
00163     \}\par
}
}
{\xe \v write_encf\:Encoder}
{\xe \v Encoder\:write_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::write_encf (const uint16_t  {\i x}, bool  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00353                                                                                     \{\par
00354         {\cf19 if} (v) set_encf(x);\par
00355         {\cf19 else} clr_encf(x);\par
00356     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:Encoder}
{\xe \v Encoder\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtEncoder::cb[2] = \{nullptr, nullptr\}{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 362} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00362 \{{\cf17 nullptr}, {\cf17 nullptr}\}; {\cf20 // callbacks for right and left turns}\par
}
}
{\xe \v counter\:Encoder}
{\xe \v Encoder\:counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t VirtEncoder::counter = 0{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 342} of file {\b VirtEncoder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b Encoder.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EncoderT< ENCA, ENCB > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >}
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
\par
{
{\f2 #include <Encoder.h>}}\par
Inheritance diagram for EncoderT< ENCA, ENCB >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/d00/class_encoder_t.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EncoderT} (uint8_t mode=INPUT)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (uint8_t mode=INPUT)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickISR} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b readEnc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncReverse} (bool rev=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncType} (uint8_t type={\b EB_STEP1})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncISR} (bool use=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b attach_right} ({\b cb_t} callback_func)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b attach_left} ({\b cb_t} callback_func)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b detach_call} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for handling encoder events. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initEnc} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initEnc} (int8_t v)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the encoder flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b turn} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b dir} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing the possible flags for the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickISR} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickISR} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
tickRaw <br>\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} (int8_t state)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b pollEnc} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b pollEnc} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b counter} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} [2] = \{nullptr, nullptr\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_encf} (const uint16_t x) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_encf} (const uint16_t x) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_encf} (const uint16_t x, bool v) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b read_encf} (const uint16_t x) __attribute__((always_inline))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<uint8_t ENCA, uint8_t ENCB>\par
class EncoderT< ENCA, ENCB >\par
}
\par
{
Definition at line {\b 97} of file {\b Encoder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EncoderT\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:EncoderT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint8_t ENCA, uint8_t ENCB> {\b EncoderT}< ENCA, ENCB >{\b ::EncoderT} (uint8_t  {\i mode} = {\f2 INPUT}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00099                                    \{\par
00100         init(mode);\par
00101     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtEncoder::action (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing the possible flags for the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
EB_FLAGS_T can have the following values:{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN: Represents the flag for turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN_L: Represents the flag for left turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN_R: Represents the flag for right turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_NONE: Represents the flag for no action. \par}
}}}{
Definition at line {\b 182} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                         \{\par
00183         {\cf19 switch} (flags & 0b111111111) \{\par
00184             {\cf19 case}(E_TRN_R | E_FAST):\par
00185                 {\cf19 return} EB_TURN;\par
00186             {\cf19 case}(E_TRN_R | E_DIR | E_REVERSE):\par
00187                 {\cf19 return} EB_TURN_L;\par
00188             {\cf19 case}(E_TRN_R | E_DIR):\par
00189                 {\cf19 return} EB_TURN_R;   \par
00190             {\cf19 default}:\par
00191                 {\cf19 return} EB_NONE;\par
00192         \}\par
00193     \}\par
}
}
{\xe \v attach_left\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:attach_left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::attach_left ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 105} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00105                                         \{\par
00106 {\cf21 #ifndef EB_NO_CALLBACK}\par
00107         uint8_t l_r = (read_encf(E_REVERSE)) ? 0 : 1;\par
00108         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00109         cb[l_r] = *callback_func;\par
00110         {\cf19 return} {\cf17 true};\par
00111 {\cf21 #endif}\par
00112         {\cf19 return} {\cf17 false};\par
00113     \}\par
}
}
{\xe \v attach_right\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:attach_right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::attach_right ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
callback_func can be "cb_t" type \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 89} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00089                                          \{\par
00090 {\cf21 #ifndef EB_NO_CALLBACK}\par
00091         uint8_t l_r = (read_encf(E_REVERSE)) ? 1 : 0;\par
00092         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00093         cb[l_r] = *callback_func;\par
00094         {\cf19 return} {\cf17 true};\par
00095 {\cf21 #endif}\par
00096         {\cf19 return} {\cf17 false};\par
00097     \}\par
}
}
{\xe \v clear\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::clear (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the encoder flags. }}\par
{
Definition at line {\b 150} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00150                  \{\par
00151         {\cf19 if} (read_encf(E_TRN_R)) clr_encf(E_TRN_R);\par
00152     \}\par
}
}
{\xe \v clr_encf\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:clr_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::clr_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00350                                                                           \{\par
00351         flags &= ~x;\par
00352     \}\par
}
}
{\xe \v detach_call\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::detach_call (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for handling encoder events. }}\par
{
Definition at line {\b 121} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                        \{\par
00122 {\cf21 #ifndef EB_NO_CALLBACK}\par
00123         cb[0] = {\cf17 nullptr};\par
00124         cb[1] = {\cf17 nullptr};\par
00125 {\cf21 #endif}\par
00126     \}\par
}
}
{\xe \v dir\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:dir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::dir (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1 if rotated left, 1 if rotated right \par
}}}{
Definition at line {\b 170} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                  \{\par
00171         {\cf19 return} read_encf(E_DIR) ? 1 : -1;\par
00172     \}\par
}
}
{\xe \v init\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint8_t ENCA, uint8_t ENCB> void {\b EncoderT}< ENCA, ENCB >::init (uint8_t  {\i mode} = {\f2 INPUT}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00103                                     \{\par
00104         pinMode(ENCA, mode);\par
00105         pinMode(ENCB, mode);\par
00106         initEnc(readEnc());\par
00107     \}\par
}
}
{\xe \v initEnc\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::initEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
}{
Definition at line {\b 134} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                                    \{\par
00135         initEnc(e0 | (e1 << 1));\par
00136     \}\par
}
}
{\xe \v initEnc\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::initEnc (int8_t  {\i v}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v} \cell }{the initial value of the encoder \cell }
{\row }
}
}{
Definition at line {\b 143} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143                            \{\par
00144         prev = v;\par
00145     \}\par
}
}
{\xe \v pollEnc\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::pollEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 305} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00305                                      \{\par
00306         {\cf19 return} pollEnc(e0 | (e1 << 1));\par
00307     \}\par
}
}
{\xe \v pollEnc\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::pollEnc (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 315} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00315                                  \{\par
00316         {\cf19 if} (prev != state) \{\par
00317             ecount += ((0x49941661 >> ((state | (prev << 2)) << 1)) & 0b11) - 1;\par
00318             prev = state;\par
00319             {\cf19 if} (!ecount) {\cf19 return} 0;\par
00320             {\cf19 switch} (flags & 0b11) \{\par
00321                 {\cf19 case} EB_STEP4_LOW:\par
00322                     {\cf19 if} (state != 0b11) {\cf19 return} 0;  {\cf20 // skip 00, 01, 10}\par
00323                     {\cf19 break};\par
00324                 {\cf19 case} EB_STEP4_HIGH:\par
00325                     {\cf19 if} (state) {\cf19 return} 0;  {\cf20 // skip 01, 10, 11}\par
00326                     {\cf19 break};\par
00327                 {\cf19 case} EB_STEP2:\par
00328                     {\cf19 if} (state == 0b10 || state == 0b01) {\cf19 return} 0;  {\cf20 // skip 10 01}\par
00329                     {\cf19 break};\par
00330             \}\par
00331             state = ((ecount > 0) ^ read_encf(E_REVERSE)) ? 1 : -1;\par
00332             ecount = 0;\par
00333 {\cf21 #ifndef EB_NO_COUNTER}\par
00334             counter += state;\par
00335 {\cf21 #endif}\par
00336             {\cf19 return} state;\par
00337         \}\par
00338         {\cf19 return} 0;\par
00339     \}\par
}
}
{\xe \v read_encf\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:read_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::read_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00357                                                                            \{\par
00358         {\cf19 return} flags & x;\par
00359     \}\par
}
}
{\xe \v readEnc\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:readEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint8_t ENCA, uint8_t ENCB> int8_t {\b EncoderT}< ENCA, ENCB >::readEnc (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00123                      \{\par
00124         {\cf19 return} EBread(ENCA) | (EBread(ENCB) << 1);\par
00125     \}\par
}
}
{\xe \v set_encf\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:set_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::set_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 347} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00347                                                                           \{\par
00348         flags |= x;\par
00349     \}\par
}
}
{\xe \v setEncISR\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:setEncISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncISR (bool  {\i use} = {\f2 true}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use} \cell }{true to use the ISR, false otherwise \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Argument "use" by default is true because name of this function means that it is used to set/activate the ISR. \par
}}}{
Definition at line {\b 78} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078                                  \{\par
00079         write_encf(E_ISR, use);\par
00080     \}\par
}
}
{\xe \v setEncReverse\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:setEncReverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncReverse (bool  {\i rev} = {\f2 false}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rev} \cell }{true to reverse the encoder, false otherwise \cell }
{\row }
}
}{
Definition at line {\b 57} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00057                                          \{\par
00058         {\cf19 if} (rev) set_encf(E_REVERSE);\par
00059         {\cf19 else} clr_encf(E_REVERSE);\par
00060     \}\par
}
}
{\xe \v setEncType\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:setEncType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncType (uint8_t  {\i type} = {\f2 {\b EB_STEP1}}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i type} \cell }{the encoder type to set \cell }
{\row }
}
}{
Definition at line {\b 67} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00067                                              \{\par
00068         flags = (flags & 0b11111100) | type;\par
00069     \}\par
}
}
{\xe \v tick\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint8_t ENCA, uint8_t ENCB> int8_t {\b EncoderT}< ENCA, ENCB >::tick (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00113                   \{\par
00114         {\cf19 if} (read_encf(E_ISR)) {\cf19 return} VirtEncoder::tick();\par
00115         {\cf19 else} {\cf19 return} VirtEncoder::tick(readEnc());\par
00116     \}\par
}
}
{\xe \v tick\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tick (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 228} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00228                                   \{\par
00229         {\cf19 return} tick(e0 | (e1 << 1));\par
00230     \}\par
}
}
{\xe \v tick\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tick (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 238} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                               \{\par
00239         state = tickRaw(state);\par
00240         {\cf19 if} (state)\par
00241         \{\par
00242 {\cf21     #ifndef EB_NO_CALLBACK}\par
00243             {\cf19 if} (cb[0] && state < 0) cb[0]();\par
00244             {\cf19 if} (cb[1] && state > 0) cb[1]();\par
00245 {\cf21     #endif}\par
00246             {\cf19 return} state;\par
00247         \}\par
00248         clear();\par
00249         {\cf19 return} 0;\par
00250     \}\par
}
}
{\xe \v tickISR\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint8_t ENCA, uint8_t ENCB> int8_t {\b EncoderT}< ENCA, ENCB >::tickISR (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00109                      \{\par
00110         {\cf19 return} VirtEncoder::tickISR(readEnc());\par
00111     \}\par
}
}
{\xe \v tickISR\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickISR (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 202} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                                      \{\par
00203         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00204     \}\par
}
}
{\xe \v tickISR\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickISR (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 212} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00212                                  \{\par
00213         state = pollEnc(state);\par
00214         {\cf19 if} (state) \{\par
00215             set_encf(E_ISR_F);\par
00216             write_encf(E_DIR, state > 0);\par
00217         \}\par
00218         {\cf19 return} state;\par
00219     \}\par
}
}
{\xe \v tickRaw\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint8_t ENCA, uint8_t ENCB> int8_t {\b EncoderT}< ENCA, ENCB >::tickRaw (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b Encoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00118                      \{\par
00119         {\cf19 if} (read_encf(E_ISR)) {\cf19 return} VirtEncoder::tickRaw();\par
00120         {\cf19 else} {\cf19 return} VirtEncoder::tickRaw(readEnc());\par
00121     \}\par
}
}
{\xe \v tickRaw\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickRaw (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 268} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00268                                      \{\par
00269         {\cf19 return} tickRaw(e0 | (e1 << 1));\par
00270     \}\par
}
}
{\xe \v tickRaw\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickRaw (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00279                                  \{\par
00280         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00281             clr_encf(E_ISR_F);\par
00282             set_encf(E_TRN_R);\par
00283             {\cf19 return} dir();\par
00284         \}\par
00285         {\cf19 if} ((state >= 0) && (state = pollEnc(state))) \{\par
00286             write_encf(E_DIR, state > 0);\par
00287             set_encf(E_TRN_R);\par
00288             {\cf19 return} state;\par
00289         \}\par
00290         {\cf19 return} 0;\par
00291     \}\par
}
}
{\xe \v turn\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::turn (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder has been turned, false otherwise \par
}}}{
Definition at line {\b 161} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00161                 \{\par
00162         {\cf19 return} read_encf(E_TRN_R);\par
00163     \}\par
}
}
{\xe \v write_encf\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:write_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::write_encf (const uint16_t  {\i x}, bool  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00353                                                                                     \{\par
00354         {\cf19 if} (v) set_encf(x);\par
00355         {\cf19 else} clr_encf(x);\par
00356     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtEncoder::cb[2] = \{nullptr, nullptr\}{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 362} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00362 \{{\cf17 nullptr}, {\cf17 nullptr}\}; {\cf20 // callbacks for right and left turns}\par
}
}
{\xe \v counter\:EncoderT< ENCA, ENCB >}
{\xe \v EncoderT< ENCA, ENCB >\:counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t VirtEncoder::counter = 0{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 342} of file {\b VirtEncoder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b Encoder.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VirtButton Class Reference\par \pard\plain 
{\tc\tcl2 \v VirtButton}
{\xe \v VirtButton}
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
\par
{
{\f2 #include <VirtButton.h>}}\par
Inheritance diagram for VirtButton:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d7/d02/class_virt_button.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setHoldTimeout} ({\b uint16_t} {\b timeout}=600)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setStepTimeout} ({\b uint16_t} {\b timeout}=200)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setClickTimeout} ({\b uint16_t} {\b timeout}=500)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setDebounceTimeout} ({\b uint8_t} {\b timeout}=50)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setBtnLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b pressISR} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clear} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b detach_call} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b press} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b release} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b click} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressing} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b getSteps} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b waiting} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b busy} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b timeout} (uint16_t tout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b pressFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b holdFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holdFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b stepFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b stepFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b VirtButton} &{\b b0}, {\b VirtButton} &{\b b1})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setButtonLevel} ({\b bool} {\b level})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b clicks}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pollBtn} ({\b bool} {\b s})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b eq_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b const} {\b uint16_t} {\b y}) {\b __attribute__}(({\b always_inline}))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b run_timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} = {\b nullptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_DEB_T} = 50\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_CLICK_T} = (500 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_HOLD_T} = (600 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_STEP_T} = (200 >> {\b EB_SHIFT})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 56} of file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:VirtButton}
{\xe \v VirtButton\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtButton::action (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action corresponding to the current flag combination.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The action corresponding to the current flag combination. \par
}}}{
Definition at line {\b 246} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00246                         \{\par
00247         {\cf19 switch} (flags & 0b111111111) \{\par
00248             {\cf19 case} (B_PRS | B_PRS_R):\par
00249                 {\cf19 return} EB_PRESS;\par
00250             {\cf19 case} (B_PRS | B_HLD | B_HLD_R):\par
00251                 {\cf19 return} EB_HOLD;\par
00252             {\cf19 case} (B_PRS | B_HLD | B_STP | B_STP_R):\par
00253                 {\cf19 return} EB_STEP;\par
00254             {\cf19 case} (B_REL | B_REL_R):\par
00255             {\cf19 case} (B_REL | B_REL_R | B_HLD):\par
00256             {\cf19 case} (B_REL | B_REL_R | B_HLD | B_STP):\par
00257                 {\cf19 return} EB_RELEASE;\par
00258             {\cf19 case} (B_REL_R):\par
00259                 {\cf19 return} EB_CLICK;\par
00260             {\cf19 case} (B_CLKS_R):\par
00261                 {\cf19 return} EB_CLICKS;\par
00262             {\cf19 case} (B_REL_R | B_HLD):\par
00263                 {\cf19 return} EB_REL_HOLD;\par
00264             {\cf19 case} (B_CLKS_R | B_HLD):\par
00265                 {\cf19 return} EB_REL_HOLD_C;\par
00266             {\cf19 case} (B_REL_R | B_HLD | B_STP):\par
00267                 {\cf19 return} EB_REL_STEP;\par
00268             {\cf19 case} (B_CLKS_R | B_HLD | B_STP):\par
00269                 {\cf19 return} EB_REL_STEP_C;\par
00270             {\cf19 default}:\par
00271                 {\cf19 return} EB_NONE;\par
00272         \}\par
00273     \}\par
}
}
{\xe \v attach_call\:VirtButton}
{\xe \v VirtButton\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::attach_call ({\b cb_t}  {\i callback_func}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 137} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                           \{ \par
00138 {\cf21 #ifndef EB_NO_CALLBACK}\par
00139         {\cf19 if} (callback_func == {\cf17 nullptr} || cb) {\cf19 return} {\cf17 false};\par
00140         cb = *callback_func;\par
00141         {\cf19 return} {\cf17 true};\par
00142 {\cf21 #endif}\par
00143         {\cf19 return} {\cf17 false};\par
00144     \}\par
}
}
{\xe \v busy\:VirtButton}
{\xe \v VirtButton\:busy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::busy (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 237} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00237                 \{\par
00238         {\cf19 return} read_btn_flag(B_BUSY);\par
00239     \}\par
}
}
{\xe \v clear\:VirtButton}
{\xe \v VirtButton\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clear (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00122                  \{\par
00123         {\cf19 if} (read_btn_flag(B_CLKS_R)) clicks = 0;\par
00124         {\cf19 if} (read_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R)) \{\par
00125             clr_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R);\par
00126         \}\par
00127     \}\par
}
}
{\xe \v click\:VirtButton}
{\xe \v VirtButton\:click}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::click (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00162                  \{\par
00163         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD, B_REL_R);\par
00164     \}\par
}
}
{\xe \v clr_btn_flag\:VirtButton}
{\xe \v VirtButton\:clr_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clr_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 503} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00503                                                                               \{\par
00504         flags &= ~x;\par
00505     \}\par
}
}
{\xe \v detach_call\:VirtButton}
{\xe \v VirtButton\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::detach_call (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00147                        \{\par
00148 {\cf21 #ifndef EB_NO_CALLBACK}\par
00149         cb = {\cf17 nullptr};\par
00150 {\cf21 #endif}\par
00151     \}\par
}
}
{\xe \v eq_btn_flag\:VirtButton}
{\xe \v VirtButton\:eq_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::eq_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b const} {\b uint16_t}  {\i y}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 513} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00513                                                                                                \{\par
00514         {\cf19 return} (flags & x) == y;\par
00515     \}\par
}
}
{\xe \v getClicks\:VirtButton}
{\xe \v VirtButton\:getClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::getClicks (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                         \{\par
00203         {\cf19 return} clicks;\par
00204     \}\par
}
}
{\xe \v getSteps\:VirtButton}
{\xe \v VirtButton\:getSteps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::getSteps (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00206                         \{\par
00207 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00208 {\cf21 #ifdef EB_STEP_TIME}\par
00209         {\cf19 return} run_timer ? ((stepFor() + EB_STEP_T - 1) / EB_STEP_T) : 0;  \par
00210 {\cf21 #else}\par
00211         {\cf19 return} run_timer ? ((stepFor() + (EB_STEP_T << EB_SHIFT) - 1) / (EB_STEP_T << EB_SHIFT)) : 0;\par
00212 {\cf21 #endif}\par
00213 {\cf21 #endif}\par
00214         {\cf19 return} 0;\par
00215     \}\par
}
}
{\xe \v hasClicks\:VirtButton}
{\xe \v VirtButton\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00194                      \{\par
00195         {\cf19 return} eq_btn_flag(B_CLKS_R | B_HLD, B_CLKS_R);\par
00196     \}\par
}
}
{\xe \v hasClicks\:VirtButton}
{\xe \v VirtButton\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks ({\b uint8_t}  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00198                                 \{\par
00199         {\cf19 return} clicks == num && hasClicks();\par
00200     \}\par
}
}
{\xe \v hold\:VirtButton}
{\xe \v VirtButton\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                 \{\par
00171         {\cf19 return} read_btn_flag(B_HLD_R);\par
00172     \}\par
}
}
{\xe \v hold\:VirtButton}
{\xe \v VirtButton\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold ({\b uint8_t}  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00174                            \{\par
00175         {\cf19 return} clicks == num && hold();\par
00176     \}\par
}
}
{\xe \v holdFor\:VirtButton}
{\xe \v VirtButton\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::holdFor (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the duration for which the button has been held.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds. \par
}}}{
Definition at line {\b 313} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                        \{\par
00314 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00315         {\cf19 if} (read_btn_flag(B_HLD)) \{\par
00316 {\cf21 #ifdef EB_HOLD_TIME}\par
00317             {\cf19 return} pressFor() - EB_HOLD_T;\par
00318 {\cf21 #else}\par
00319             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT);\par
00320 {\cf21 #endif}\par
00321         \}\par
00322 {\cf21 #endif}\par
00323         {\cf19 return} 0;\par
00324     \}\par
}
}
{\xe \v holdFor\:VirtButton}
{\xe \v VirtButton\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holdFor ({\b uint16_t}  {\i ms}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the button has been held for a specified duration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ms} \cell }{The duration in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button has been held for the specified duration, false otherwise. \par
}}}{
Definition at line {\b 332} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00332                               \{\par
00333         {\cf19 return} holdFor() > ms;\par
00334     \}\par
}
}
{\xe \v holding\:VirtButton}
{\xe \v VirtButton\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00178                    \{\par
00179         {\cf19 return} eq_btn_flag(B_PRS | B_HLD, B_PRS | B_HLD);\par
00180     \}\par
}
}
{\xe \v holding\:VirtButton}
{\xe \v VirtButton\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding ({\b uint8_t}  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                               \{\par
00183         {\cf19 return} clicks == num && holding();\par
00184     \}\par
}
}
{\xe \v init\:VirtButton}
{\xe \v VirtButton\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::init (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00060                \{\par
00061         setHoldTimeout();\par
00062         setStepTimeout();\par
00063         setClickTimeout();\par
00064         setDebounceTimeout();\par
00065 \par
00066     \}\par
}
}
{\xe \v pollBtn\:VirtButton}
{\xe \v VirtButton\:pollBtn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pollBtn ({\b bool}  {\i s}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00391                          \{\par
00392         {\cf19 if} (read_btn_flag(B_BISR)) \{\par
00393             clr_btn_flag(B_BISR);\par
00394             s = 1;\par
00395         \} {\cf19 else} s ^= read_btn_flag(B_INV);\par
00396 \par
00397         {\cf19 if} (!read_btn_flag(B_BUSY)) \{\par
00398             {\cf19 if} (s) set_btn_flag(B_BUSY);\par
00399             {\cf19 else} {\cf19 return} 0;\par
00400         \}\par
00401 \par
00402         uint16_t ms = EB_UPTIME();\par
00403         uint16_t deb = ms - timer;\par
00404 \par
00405         {\cf19 if} (s) \{                                      \par
00406             {\cf19 if} (!read_btn_flag(B_PRS)) \{                  \par
00407                 {\cf19 if} (!read_btn_flag(B_DEB) && EB_DEB_T) \{  \par
00408                     set_btn_flag(B_DEB);                   \par
00409                     timer = ms;                         \par
00410                 \} {\cf19 else} \{                                \par
00411                     {\cf19 if} (deb >= EB_DEB_T || !EB_DEB_T) \{ \par
00412                         set_btn_flag(B_PRS | B_PRS_R);      \par
00413 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00414                         run_timer = ms;\par
00415 {\cf21 #endif}\par
00416                         timer = ms;  \par
00417                     \}\par
00418                 \}\par
00419             \} {\cf19 else} \{  \par
00420                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00421                     {\cf19 if} (!read_btn_flag(B_HLD)) \{  \par
00422 {\cf21 #ifdef EB_HOLD_TIME}\par
00423                         {\cf19 if} (deb >= (uint16_t)EB_HOLD_T) \{  \par
00424 {\cf21 #else}\par
00425                         {\cf19 if} (deb >= (uint16_t)(EB_HOLD_T << EB_SHIFT)) \{  \par
00426 {\cf21 #endif}\par
00427                             set_btn_flag(B_HLD_R | B_HLD); \par
00428                             timer = ms;                 \par
00429                         \}\par
00430                     \} {\cf19 else} \{  \par
00431 {\cf21 #ifdef EB_STEP_TIME}\par
00432                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? EB_STEP_T : EB_HOLD_T)) \{\par
00433 {\cf21 #else}\par
00434                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? (EB_STEP_T << EB_SHIFT) : (EB_HOLD_T << EB_SHIFT))) \{\par
00435 {\cf21 #endif}\par
00436                             set_btn_flag(B_STP | B_STP_R);  \par
00437                             timer = ms;                   \par
00438                         \}\par
00439                     \}\par
00440                 \}\par
00441             \}\par
00442         \} {\cf19 else} \{                                     \par
00443             {\cf19 if} (read_btn_flag(B_PRS)) \{                 \par
00444                 {\cf19 if} (deb >= EB_DEB_T) \{               \par
00445                     {\cf19 if} (!read_btn_flag(B_HLD)) clicks++;    \par
00446                     {\cf19 if} (read_btn_flag(B_EHLD)) clicks = 0;  \par
00447                     set_btn_flag(B_REL | B_REL_R);        \par
00448                     clr_btn_flag(B_PRS);                   \par
00449                 \}\par
00450             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_REL)) \{\par
00451                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00452                     set_btn_flag(B_REL_R);\par
00453                 \}\par
00454                 clr_btn_flag(B_REL | B_EHLD);\par
00455                 timer = ms;       \par
00456             \} {\cf19 else} {\cf19 if} (clicks) \{  \par
00457 {\cf21 #ifdef EB_CLICK_TIME}\par
00458                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)EB_CLICK_T) set_btn_flag(B_CLKS_R);  \par
00459 {\cf21 #else}\par
00460                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)(EB_CLICK_T << EB_SHIFT)) set_btn_flag(B_CLKS_R);  \par
00461 {\cf21 #endif}\par
00462 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00463                 {\cf19 else} {\cf19 if} (run_timer) run_timer = 0;\par
00464 {\cf21 #endif}\par
00465             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_BUSY)) \{\par
00466                 clr_btn_flag(B_HLD | B_STP | B_BUSY);\par
00467                 set_btn_flag(B_TOUT);\par
00468 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00469                 run_timer = 0;\par
00470 {\cf21 #endif}\par
00471                 timer = ms;  {\cf20 // test!!}\par
00472             \}\par
00473             {\cf19 if} (read_btn_flag(B_DEB)) clr_btn_flag(B_DEB);  \par
00474         \}\par
00475         {\cf19 return} read_btn_flag(B_CLKS_R | B_PRS_R | B_HLD_R | B_STP_R | B_REL_R);\par
00476     \}\par
}
}
{\xe \v press\:VirtButton}
{\xe \v VirtButton\:press}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::press (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00154                  \{\par
00155         {\cf19 return} read_btn_flag(B_PRS_R);\par
00156     \}\par
}
}
{\xe \v pressFor\:VirtButton}
{\xe \v VirtButton\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::pressFor (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the duration in milliseconds for which the button has been pressed. If the EB_NO_PEDOMETER macro is defined, the function always returns 0. If the button is not currently pressed, the function also returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds for which the button has been pressed. \par
}}}{
Definition at line {\b 297} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00297                         \{\par
00298 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00299         {\cf19 if} (run_timer) {\cf19 return} (uint16_t)EB_UPTIME() - run_timer;\par
00300 {\cf21 #endif}\par
00301         {\cf19 return} 0;\par
00302     \}\par
}
}
{\xe \v pressFor\:VirtButton}
{\xe \v VirtButton\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressFor ({\b uint16_t}  {\i ms}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 304} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                \{\par
00305         {\cf19 return} pressFor() > ms;\par
00306     \}\par
}
}
{\xe \v pressing\:VirtButton}
{\xe \v VirtButton\:pressing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressing (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00166                     \{\par
00167         {\cf19 return} read_btn_flag(B_PRS);\par
00168     \}\par
}
}
{\xe \v pressISR\:VirtButton}
{\xe \v VirtButton\:pressISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::pressISR (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                     \{\par
00113         {\cf19 if} (!read_btn_flag(B_DEB)) timer = EB_UPTIME();\par
00114         set_btn_flag(B_DEB | B_BISR);\par
00115     \}\par
}
}
{\xe \v read_btn_flag\:VirtButton}
{\xe \v VirtButton\:read_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::read_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 506} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                                                                                \{\par
00507         {\cf19 return} flags & x;\par
00508     \}\par
}
}
{\xe \v release\:VirtButton}
{\xe \v VirtButton\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::release (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00158                    \{\par
00159         {\cf19 return} eq_btn_flag(B_REL_R | B_REL, B_REL_R | B_REL);\par
00160     \}\par
}
}
{\xe \v releaseHold\:VirtButton}
{\xe \v VirtButton\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                        \{\par
00218         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD | B_STP, B_REL_R | B_HLD);\par
00219     \}\par
}
}
{\xe \v releaseHold\:VirtButton}
{\xe \v VirtButton\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold ({\b uint8_t}  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00221                                   \{\par
00222         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_HLD | B_STP, B_CLKS_R | B_HLD);\par
00223     \}\par
}
}
{\xe \v releaseStep\:VirtButton}
{\xe \v VirtButton\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00225                        \{\par
00226         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_STP, B_REL_R | B_STP);\par
00227     \}\par
}
}
{\xe \v releaseStep\:VirtButton}
{\xe \v VirtButton\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep ({\b uint8_t}  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00229                                   \{\par
00230         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_STP, B_CLKS_R | B_STP);\par
00231     \}\par
}
}
{\xe \v reset\:VirtButton}
{\xe \v VirtButton\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::reset (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117                  \{\par
00118         clicks = 0;\par
00119         clr_btn_flag(~B_INV);\par
00120     \}\par
}
}
{\xe \v set_btn_flag\:VirtButton}
{\xe \v VirtButton\:set_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::set_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 500} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00500                                                                               \{\par
00501         flags |= x;\par
00502     \}\par
}
}
{\xe \v setBtnLevel\:VirtButton}
{\xe \v VirtButton\:setBtnLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setBtnLevel ({\b bool}  {\i level}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                                  \{\par
00109         write_btn_flag(B_INV, !level);\par
00110     \}\par
}
}
{\xe \v setButtonLevel\:VirtButton}
{\xe \v VirtButton\:setButtonLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setButtonLevel ({\b bool}  {\i level}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00385                                     \{\par
00386         write_btn_flag(B_INV, !level);\par
00387     \}\par
}
}
{\xe \v setClickTimeout\:VirtButton}
{\xe \v VirtButton\:setClickTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setClickTimeout ({\b uint16_t}  {\i timeout} = {\f2 500}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The click timeout value in milliseconds. Default is 500 milliseconds. Max is 4000ms. \cell }
{\row }
}
}{
Definition at line {\b 96} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096                                                \{\par
00097 {\cf21 #ifndef EB_CLICK_TIME}\par
00098         EB_CLICK_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00099 {\cf21 #endif}\par
00100     \}\par
}
}
{\xe \v setDebounceTimeout\:VirtButton}
{\xe \v VirtButton\:setDebounceTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setDebounceTimeout ({\b uint8_t}  {\i timeout} = {\f2 50}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00102                                                 \{\par
00103 {\cf21 #ifndef EB_DEB_TIME}\par
00104         EB_DEB_T = (timeout < 255) ? timeout : 255;\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v setHoldTimeout\:VirtButton}
{\xe \v VirtButton\:setHoldTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setHoldTimeout ({\b uint16_t}  {\i timeout} = {\f2 600}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The hold timeout value in milliseconds. Default is 600 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 74} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00074                                               \{\par
00075 {\cf21 #ifndef EB_HOLD_TIME}\par
00076         EB_HOLD_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00077 {\cf21 #endif}\par
00078     \}\par
}
}
{\xe \v setStepTimeout\:VirtButton}
{\xe \v VirtButton\:setStepTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setStepTimeout ({\b uint16_t}  {\i timeout} = {\f2 200}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the step timeout for the virtual button. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The timeout value in milliseconds. Default is 200 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 85} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085                                               \{\par
00086 {\cf21 #ifndef EB_STEP_TIME}\par
00087         EB_STEP_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00088 {\cf21 #endif}\par
00089     \}\par
}
}
{\xe \v step\:VirtButton}
{\xe \v VirtButton\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                 \{\par
00187         {\cf19 return} read_btn_flag(B_STP_R);\par
00188     \}\par
}
}
{\xe \v step\:VirtButton}
{\xe \v VirtButton\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step ({\b uint8_t}  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190                            \{\par
00191         {\cf19 return} clicks == num && step();\par
00192     \}\par
}
}
{\xe \v stepFor\:VirtButton}
{\xe \v VirtButton\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::stepFor (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00336                        \{\par
00337 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00338         {\cf19 if} (read_btn_flag(B_STP)) \{\par
00339 {\cf21 #ifdef EB_HOLD_TIME}\par
00340             {\cf19 return} pressFor() - EB_HOLD_T * 2;\par
00341 {\cf21 #else}\par
00342             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT) * 2;\par
00343 {\cf21 #endif}\par
00344         \}\par
00345 {\cf21 #endif}\par
00346         {\cf19 return} 0;\par
00347     \}\par
}
}
{\xe \v stepFor\:VirtButton}
{\xe \v VirtButton\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::stepFor ({\b uint16_t}  {\i ms}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 349} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                               \{\par
00350         {\cf19 return} stepFor() > ms;\par
00351     \}\par
}
}
{\xe \v tick\:VirtButton}
{\xe \v VirtButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b bool}  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 368} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00368                           \{\par
00369         clear();\par
00370         state = pollBtn(state);\par
00371 {\cf21 #ifndef EB_NO_CALLBACK}\par
00372         {\cf19 if} (cb && state) cb();\par
00373 {\cf21 #endif}\par
00374         {\cf19 return} state;\par
00375     \}\par
}
}
{\xe \v tick\:VirtButton}
{\xe \v VirtButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b VirtButton} &  {\i b0}, {\b VirtButton} &  {\i b1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00354                                               \{\par
00355         {\cf19 if} (read_btn_flag(B_BOTH)) \{\par
00356             {\cf19 if} (!b0.pressing() && !b1.pressing()) clr_btn_flag(B_BOTH);\par
00357             {\cf19 if} (!b0.pressing()) b0.reset();\par
00358             {\cf19 if} (!b1.pressing()) b1.reset();\par
00359             b0.clear();\par
00360             b1.clear();\par
00361             {\cf19 return} tick(1);\par
00362         \} {\cf19 else} \{\par
00363             {\cf19 if} (b0.pressing() && b1.pressing()) set_btn_flag(B_BOTH);\par
00364             {\cf19 return} tick(0);\par
00365         \}\par
00366     \}\par
}
}
{\xe \v tickRaw\:VirtButton}
{\xe \v VirtButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tickRaw ({\b bool}  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 378} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00378                              \{\par
00379         {\cf19 return} pollBtn(state);\par
00380     \}\par
}
}
{\xe \v timeout\:VirtButton}
{\xe \v VirtButton\:timeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtButton::timeout (uint16_t  {\i tout}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the timeout has occurred.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The timeout value in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the timeout has occurred, false otherwise. \par
}}}{
Definition at line {\b 282} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00282                                 \{\par
00283         {\cf19 if} (read_btn_flag(B_TOUT) && (uint16_t)((uint16_t)EB_UPTIME() - timer) > tout) \{\par
00284             clr_btn_flag(B_TOUT);\par
00285             {\cf19 return} 1;\par
00286         \}\par
00287         {\cf19 return} 0;\par
00288     \}\par
}
}
{\xe \v waiting\:VirtButton}
{\xe \v VirtButton\:waiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::waiting (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00233                    \{\par
00234         {\cf19 return} clicks && eq_btn_flag(B_PRS | B_REL, 0);\par
00235     \}\par
}
}
{\xe \v write_btn_flag\:VirtButton}
{\xe \v VirtButton\:write_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::write_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b bool}  {\i v}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 509} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00509                                                                                         \{\par
00510         {\cf19 if} (v) set_btn_flag(x);\par
00511         {\cf19 else} clr_btn_flag(x);\par
00512     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:VirtButton}
{\xe \v VirtButton\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtButton::cb = {\b nullptr}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 484} of file {\b VirtButton.h}.}\par
}
{\xe \v clicks\:VirtButton}
{\xe \v VirtButton\:clicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::clicks}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_CLICK_T\:VirtButton}
{\xe \v VirtButton\:EB_CLICK_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_CLICK_T = (500 >> {\b EB_SHIFT}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_DEB_T\:VirtButton}
{\xe \v VirtButton\:EB_DEB_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_DEB_T = 50{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_HOLD_T\:VirtButton}
{\xe \v VirtButton\:EB_HOLD_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_HOLD_T = (600 >> {\b EB_SHIFT}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 494} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_STEP_T\:VirtButton}
{\xe \v VirtButton\:EB_STEP_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_STEP_T = (200 >> {\b EB_SHIFT}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 497} of file {\b VirtButton.h}.}\par
}
{\xe \v run_timer\:VirtButton}
{\xe \v VirtButton\:run_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::run_timer = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 480} of file {\b VirtButton.h}.}\par
}
{\xe \v timer\:VirtButton}
{\xe \v VirtButton\:timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::timer = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b VirtButton.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VirtEncButton Class Reference\par \pard\plain 
{\tc\tcl2 \v VirtEncButton}
{\xe \v VirtEncButton}
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a virtual encoder button. }}\par
{
{\f2 #include <VirtEncButton.h>}}\par
Inheritance diagram for VirtEncButton:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d00/class_virt_enc_button.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b setFastTimeout} ({\b uint8_t} {\b tout})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the Fast Timeout object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clear} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the state of the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b EB_FLAGS_T} {\b handler}, {\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attaches a callback function to handle a specific event of the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b detach_call} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for the virtual encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b turnH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b fast} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is in the fast mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b right} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right without holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b left} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left without holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b rightH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right while holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b leftH} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left while holding the button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b encHolding} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is being held. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action of the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickISR} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickISR} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} e0, {\b bool} e1, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b int8_t} {\b state}, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} e0, {\b bool} e1, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b int8_t} {\b state}, {\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tickRaw} ({\b bool} {\b btn})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b init} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setHoldTimeout} ({\b uint16_t} {\b timeout}=600)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setStepTimeout} ({\b uint16_t} {\b timeout}=200)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setClickTimeout} ({\b uint16_t} {\b timeout}=500)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setDebounceTimeout} ({\b uint8_t} {\b timeout}=50)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setBtnLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b pressISR} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_call} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b press} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b release} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b click} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressing} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holding} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b step} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b hasClicks} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b getClicks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b getSteps} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseHold} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b releaseStep} ({\b uint8_t} {\b num})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b waiting} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b busy} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b timeout} (uint16_t tout)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b pressFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pressFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b holdFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b holdFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b stepFor} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b stepFor} ({\b uint16_t} {\b ms})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b tick} ({\b VirtButton} &{\b b0}, {\b VirtButton} &{\b b1})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setButtonLevel} ({\b bool} {\b level})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncReverse} ({\b bool} {\b rev}={\b false})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncType} ({\b uint8_t} {\b type}={\b EB_STEP1})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setEncISR} ({\b bool} {\b use}={\b true})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_right} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b attach_left} ({\b cb_t} {\b callback_func})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b initEnc} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b initEnc} ({\b int8_t} {\b v})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b turn} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b dir} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tick} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tick} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tick} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickRaw} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b clicks}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b pollBtn} ({\b bool} {\b s})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_btn_flag} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b eq_btn_flag} ({\b const} {\b uint16_t} {\b x}, {\b const} {\b uint16_t} {\b y}) {\b __attribute__}(({\b always_inline}))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} [5] = \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\b nullptr}, {\b nullptr}\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_FAST_T} = 30\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b ebuffer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16_t} {\b run_timer} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_DEB_T} = 50\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_CLICK_T} = (500 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_HOLD_T} = (600 >> {\b EB_SHIFT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b EB_STEP_T} = (200 >> {\b EB_SHIFT})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
tickRaw <br>\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickRaw} ({\b int8_t} {\b state})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b tickRaw} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b pollEnc} ({\b bool} e0, {\b bool} e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int8_t} {\b pollEnc} ({\b int8_t} {\b state})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int32_t} {\b counter} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b set_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b clr_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b write_encf} ({\b const} {\b uint16_t} {\b x}, {\b bool} {\b v}) {\b __attribute__}(({\b always_inline}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b read_encf} ({\b const} {\b uint16_t} {\b x}) {\b __attribute__}(({\b always_inline}))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a virtual encoder button. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class inherits from {\b VirtButton} and {\b VirtEncoder} classes. It provides methods for setting and getting the fast timeout, as well as various methods for checking the state of the encoder button. The class also includes methods for handling interrupts and polling the encoder button. \par
}{
Definition at line {\b 25} of file {\b VirtEncButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:VirtEncButton}
{\xe \v VirtEncButton\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtEncButton::action (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the action of the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The action of the encoder button \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Todo:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid todo in binary switch case block e_state + b_state and EB_HOLD + EB_TURN verification if ((state & EB_HOLD) && (state & EB_TURN_R)) return EB_TURN_HOLD_R; \par
}
}{
Definition at line {\b 180} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00180                         \{\par
00181         EB_FLAGS_T e_state =  VirtEncoder::action(); \par
00182         EB_FLAGS_T b_state =  VirtButton::action();\par
00183 \par
00184         {\cf19 if} (e_state == EB_NONE) \{\par
00185             {\cf19 return} b_state; \par
00186         \}\par
00187         \par
00188         {\cf19 if}(b_state == EB_HOLD)\{\par
00189             {\cf19 switch} (e_state)\par
00190             \{\par
00191                 {\cf19 case} EB_TURN_R:\par
00192                     {\cf19 return} EB_TURN_HOLD_R;\par
00193                 {\cf19 case} EB_TURN_L:\par
00194                     {\cf19 return} EB_TURN_HOLD_L;\par
00195                 {\cf19 case} EB_TURN:\par
00196                     {\cf19 return} EB_TURN;\par
00197                 {\cf19 default}:\par
00198                     {\cf19 return} EB_HOLD;\par
00199             \}\par
00200         \}\par
00201         {\cf19 return} e_state;\par
00202 \par
00203 \par
00204         {\cf20 /* needs to be tested}\par
00205 {\cf20 }\par
00206 {\cf20          switch (b_state | e_state)}\par
00207 {\cf20          \{}\par
00208 {\cf20             case 1000000001000:}\par
00209 {\cf20                 return EB_TURN_HOLD_R; //EB_HOLD + EB_TURN_R}\par
00210 {\cf20             case 10000000011000:}\par
00211 {\cf20                 return EB_TURN_HOLD_L; //EB_HOLD + EB_TURN_L}\par
00212 {\cf20             case 10000001000 :}\par
00213 {\cf20                 return EB_TURN;//EB_HOLD + EB_TURN}\par
00214 {\cf20             case (e_state | EB_NONE):}\par
00215 {\cf20                 return e_state; //if b_state == EB_NONE}\par
00216 {\cf20             default:}\par
00217 {\cf20                 return b_state; }\par
00218 {\cf20          \}}\par
00219 {\cf20         }\par
00220 {\cf20         */}\par
00221     \}\par
}
}
{\xe \v attach_call\:VirtEncButton}
{\xe \v VirtEncButton\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::attach_call ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle button events. The callback will be called when button events occur. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 137} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                           \{ \par
00138 {\cf21 #ifndef EB_NO_CALLBACK}\par
00139         {\cf19 if} (callback_func == {\cf17 nullptr} || cb) {\cf19 return} {\cf17 false};\par
00140         cb = *callback_func;\par
00141         {\cf19 return} {\cf17 true};\par
00142 {\cf21 #endif}\par
00143         {\cf19 return} {\cf17 false};\par
00144     \}\par
}
}
{\xe \v attach_call\:VirtEncButton}
{\xe \v VirtEncButton\:attach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::attach_call ({\b EB_FLAGS_T}  {\i handler}, {\b cb_t}  {\i callback_func}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attaches a callback function to handle a specific event of the virtual encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i handler} \cell }{The event type to attach the callback function to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i callback_func} \cell }{The callback function to be attached. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns true if the callback function was successfully attached, false otherwise. \par
}}}{
Definition at line {\b 61} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00061                                                             \{\par
00062 {\cf21 #ifndef EB_NO_CALLBACK}\par
00063         {\cf19 if}(callback_func)\{\par
00064             {\cf19 switch} (handler)\par
00065             \{\par
00066                 {\cf19 case} EB_PRESS:\par
00067                     {\cf19 if}(cb[0]) {\cf19 return} {\cf17 false};\par
00068                     {\cf19 return} VirtButton::attach_call(callback_func);\par
00069                 \par
00070                 {\cf19 case} EB_TURN_R:\par
00071                     {\cf19 if}(cb[1]) {\cf19 return} {\cf17 false};\par
00072                     {\cf19 return} VirtEncoder::attach_right(callback_func); {\cf20 //todo attach_call}\par
00073 \par
00074                 {\cf19 case} EB_TURN_L:\par
00075                     {\cf19 if}(cb[2]) {\cf19 return} {\cf17 false};\par
00076                     {\cf19 return} VirtEncoder::attach_left(callback_func); {\cf20 //todo attach_call}\par
00077 \par
00078                 {\cf19 case} EB_TURN_HOLD_R:\par
00079                     {\cf19 if}(cb[3]) {\cf19 return} {\cf17 false};\par
00080                     cb[3] = *callback_func;\par
00081                     {\cf19 return} {\cf17 true};\par
00082 \par
00083                 {\cf19 case} EB_TURN_HOLD_L:\par
00084                     {\cf19 if}(cb[4]) {\cf19 return} {\cf17 false};\par
00085                     cb[4] = *callback_func;\par
00086                     {\cf19 return} {\cf17 true};\par
00087 \par
00088                 {\cf19 default}:\par
00089                     {\cf19 return} {\cf17 false};\par
00090             \}\par
00091         \}       \par
00092 {\cf21 #endif}\par
00093         {\cf19 return} {\cf17 false};\par
00094     \}\par
}
}
{\xe \v attach_left\:VirtEncButton}
{\xe \v VirtEncButton\:attach_left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::attach_left ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 105} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00105                                         \{\par
00106 {\cf21 #ifndef EB_NO_CALLBACK}\par
00107         uint8_t l_r = (read_encf(E_REVERSE)) ? 0 : 1;\par
00108         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00109         cb[l_r] = *callback_func;\par
00110         {\cf19 return} {\cf17 true};\par
00111 {\cf21 #endif}\par
00112         {\cf19 return} {\cf17 false};\par
00113     \}\par
}
}
{\xe \v attach_right\:VirtEncButton}
{\xe \v VirtEncButton\:attach_right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::attach_right ({\b cb_t}  {\i callback_func}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
callback_func can be "cb_t" type \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 89} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00089                                          \{\par
00090 {\cf21 #ifndef EB_NO_CALLBACK}\par
00091         uint8_t l_r = (read_encf(E_REVERSE)) ? 1 : 0;\par
00092         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00093         cb[l_r] = *callback_func;\par
00094         {\cf19 return} {\cf17 true};\par
00095 {\cf21 #endif}\par
00096         {\cf19 return} {\cf17 false};\par
00097     \}\par
}
}
{\xe \v busy\:VirtEncButton}
{\xe \v VirtEncButton\:busy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::busy (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 237} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00237                 \{\par
00238         {\cf19 return} read_btn_flag(B_BUSY);\par
00239     \}\par
}
}
{\xe \v clear\:VirtEncButton}
{\xe \v VirtEncButton\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncButton::clear (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the state of the virtual encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function clears the state of the virtual encoder button, including the button state and encoder state. \par
}{
Definition at line {\b 49} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00049                  \{\par
00050         VirtButton::clear();\par
00051         VirtEncoder::clear();\par
00052     \}\par
}
}
{\xe \v click\:VirtEncButton}
{\xe \v VirtEncButton\:click}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::click (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00162                  \{\par
00163         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD, B_REL_R);\par
00164     \}\par
}
}
{\xe \v clr_btn_flag\:VirtEncButton}
{\xe \v VirtEncButton\:clr_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::clr_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 503} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00503                                                                               \{\par
00504         flags &= ~x;\par
00505     \}\par
}
}
{\xe \v clr_encf\:VirtEncButton}
{\xe \v VirtEncButton\:clr_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::clr_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00350                                                                           \{\par
00351         flags &= ~x;\par
00352     \}\par
}
}
{\xe \v detach_call\:VirtEncButton}
{\xe \v VirtEncButton\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncButton::detach_call (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for the virtual encoder button. }}\par
{
Definition at line {\b 99} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00099                       \{\par
00100 {\cf21 #ifndef EB_NO_CALLBACK}\par
00101         VirtButton::detach_call();\par
00102         VirtEncoder::detach_call();\par
00103         cb[3] = {\cf17 nullptr};\par
00104         cb[4] = {\cf17 nullptr};\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v dir\:VirtEncButton}
{\xe \v VirtEncButton\:dir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::dir (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1 if rotated left, 1 if rotated right \par
}}}{
Definition at line {\b 170} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                  \{\par
00171         {\cf19 return} read_encf(E_DIR) ? 1 : -1;\par
00172     \}\par
}
}
{\xe \v encHolding\:VirtEncButton}
{\xe \v VirtEncButton\:encHolding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::encHolding (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is being held. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is being held, false otherwise \par
}}}{
Definition at line {\b 169} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00169                       \{\par
00170         {\cf19 return} read_btn_flag(B_EHLD);\par
00171     \}\par
}
}
{\xe \v eq_btn_flag\:VirtEncButton}
{\xe \v VirtEncButton\:eq_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::eq_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b const} {\b uint16_t}  {\i y}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 513} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00513                                                                                                \{\par
00514         {\cf19 return} (flags & x) == y;\par
00515     \}\par
}
}
{\xe \v fast\:VirtEncButton}
{\xe \v VirtEncButton\:fast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::fast (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is in the fast mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is in the fast mode, false otherwise \par
}}}{
Definition at line {\b 124} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00124                 \{\par
00125         {\cf19 return} read_encf(E_FAST);\par
00126     \}\par
}
}
{\xe \v getClicks\:VirtEncButton}
{\xe \v VirtEncButton\:getClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::getClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                         \{\par
00203         {\cf19 return} clicks;\par
00204     \}\par
}
}
{\xe \v getSteps\:VirtEncButton}
{\xe \v VirtEncButton\:getSteps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::getSteps (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00206                         \{\par
00207 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00208 {\cf21 #ifdef EB_STEP_TIME}\par
00209         {\cf19 return} run_timer ? ((stepFor() + EB_STEP_T - 1) / EB_STEP_T) : 0;  \par
00210 {\cf21 #else}\par
00211         {\cf19 return} run_timer ? ((stepFor() + (EB_STEP_T << EB_SHIFT) - 1) / (EB_STEP_T << EB_SHIFT)) : 0;\par
00212 {\cf21 #endif}\par
00213 {\cf21 #endif}\par
00214         {\cf19 return} 0;\par
00215     \}\par
}
}
{\xe \v hasClicks\:VirtEncButton}
{\xe \v VirtEncButton\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00194                      \{\par
00195         {\cf19 return} eq_btn_flag(B_CLKS_R | B_HLD, B_CLKS_R);\par
00196     \}\par
}
}
{\xe \v hasClicks\:VirtEncButton}
{\xe \v VirtEncButton\:hasClicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hasClicks ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00198                                 \{\par
00199         {\cf19 return} clicks == num && hasClicks();\par
00200     \}\par
}
}
{\xe \v hold\:VirtEncButton}
{\xe \v VirtEncButton\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                 \{\par
00171         {\cf19 return} read_btn_flag(B_HLD_R);\par
00172     \}\par
}
}
{\xe \v hold\:VirtEncButton}
{\xe \v VirtEncButton\:hold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::hold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00174                            \{\par
00175         {\cf19 return} clicks == num && hold();\par
00176     \}\par
}
}
{\xe \v holdFor\:VirtEncButton}
{\xe \v VirtEncButton\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::holdFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the duration for which the button has been held.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds. \par
}}}{
Definition at line {\b 313} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                        \{\par
00314 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00315         {\cf19 if} (read_btn_flag(B_HLD)) \{\par
00316 {\cf21 #ifdef EB_HOLD_TIME}\par
00317             {\cf19 return} pressFor() - EB_HOLD_T;\par
00318 {\cf21 #else}\par
00319             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT);\par
00320 {\cf21 #endif}\par
00321         \}\par
00322 {\cf21 #endif}\par
00323         {\cf19 return} 0;\par
00324     \}\par
}
}
{\xe \v holdFor\:VirtEncButton}
{\xe \v VirtEncButton\:holdFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holdFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the button has been held for a specified duration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ms} \cell }{The duration in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the button has been held for the specified duration, false otherwise. \par
}}}{
Definition at line {\b 332} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00332                               \{\par
00333         {\cf19 return} holdFor() > ms;\par
00334     \}\par
}
}
{\xe \v holding\:VirtEncButton}
{\xe \v VirtEncButton\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00178                    \{\par
00179         {\cf19 return} eq_btn_flag(B_PRS | B_HLD, B_PRS | B_HLD);\par
00180     \}\par
}
}
{\xe \v holding\:VirtEncButton}
{\xe \v VirtEncButton\:holding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::holding ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                               \{\par
00183         {\cf19 return} clicks == num && holding();\par
00184     \}\par
}
}
{\xe \v init\:VirtEncButton}
{\xe \v VirtEncButton\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::init (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00060                \{\par
00061         setHoldTimeout();\par
00062         setStepTimeout();\par
00063         setClickTimeout();\par
00064         setDebounceTimeout();\par
00065 \par
00066     \}\par
}
}
{\xe \v initEnc\:VirtEncButton}
{\xe \v VirtEncButton\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::initEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
}{
Definition at line {\b 134} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                                    \{\par
00135         initEnc(e0 | (e1 << 1));\par
00136     \}\par
}
}
{\xe \v initEnc\:VirtEncButton}
{\xe \v VirtEncButton\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::initEnc (int8_t  {\i v}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v} \cell }{the initial value of the encoder \cell }
{\row }
}
}{
Definition at line {\b 143} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143                            \{\par
00144         prev = v;\par
00145     \}\par
}
}
{\xe \v left\:VirtEncButton}
{\xe \v VirtEncButton\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::left (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left without holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the left without holding the button, false otherwise \par
}}}{
Definition at line {\b 142} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00142                 \{\par
00143         {\cf19 return} !read_encf(E_DIR) && turn() && !read_btn_flag(B_EHLD);\par
00144     \}\par
}
}
{\xe \v leftH\:VirtEncButton}
{\xe \v VirtEncButton\:leftH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::leftH (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the left while holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the left while holding the button, false otherwise \par
}}}{
Definition at line {\b 160} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00160                  \{\par
00161         {\cf19 return} !read_encf(E_DIR) && turnH();\par
00162     \}\par
}
}
{\xe \v pollBtn\:VirtEncButton}
{\xe \v VirtEncButton\:pollBtn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pollBtn ({\b bool}  {\i s}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 391} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00391                          \{\par
00392         {\cf19 if} (read_btn_flag(B_BISR)) \{\par
00393             clr_btn_flag(B_BISR);\par
00394             s = 1;\par
00395         \} {\cf19 else} s ^= read_btn_flag(B_INV);\par
00396 \par
00397         {\cf19 if} (!read_btn_flag(B_BUSY)) \{\par
00398             {\cf19 if} (s) set_btn_flag(B_BUSY);\par
00399             {\cf19 else} {\cf19 return} 0;\par
00400         \}\par
00401 \par
00402         uint16_t ms = EB_UPTIME();\par
00403         uint16_t deb = ms - timer;\par
00404 \par
00405         {\cf19 if} (s) \{                                      \par
00406             {\cf19 if} (!read_btn_flag(B_PRS)) \{                  \par
00407                 {\cf19 if} (!read_btn_flag(B_DEB) && EB_DEB_T) \{  \par
00408                     set_btn_flag(B_DEB);                   \par
00409                     timer = ms;                         \par
00410                 \} {\cf19 else} \{                                \par
00411                     {\cf19 if} (deb >= EB_DEB_T || !EB_DEB_T) \{ \par
00412                         set_btn_flag(B_PRS | B_PRS_R);      \par
00413 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00414                         run_timer = ms;\par
00415 {\cf21 #endif}\par
00416                         timer = ms;  \par
00417                     \}\par
00418                 \}\par
00419             \} {\cf19 else} \{  \par
00420                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00421                     {\cf19 if} (!read_btn_flag(B_HLD)) \{  \par
00422 {\cf21 #ifdef EB_HOLD_TIME}\par
00423                         {\cf19 if} (deb >= (uint16_t)EB_HOLD_T) \{  \par
00424 {\cf21 #else}\par
00425                         {\cf19 if} (deb >= (uint16_t)(EB_HOLD_T << EB_SHIFT)) \{  \par
00426 {\cf21 #endif}\par
00427                             set_btn_flag(B_HLD_R | B_HLD); \par
00428                             timer = ms;                 \par
00429                         \}\par
00430                     \} {\cf19 else} \{  \par
00431 {\cf21 #ifdef EB_STEP_TIME}\par
00432                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? EB_STEP_T : EB_HOLD_T)) \{\par
00433 {\cf21 #else}\par
00434                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? (EB_STEP_T << EB_SHIFT) : (EB_HOLD_T << EB_SHIFT))) \{\par
00435 {\cf21 #endif}\par
00436                             set_btn_flag(B_STP | B_STP_R);  \par
00437                             timer = ms;                   \par
00438                         \}\par
00439                     \}\par
00440                 \}\par
00441             \}\par
00442         \} {\cf19 else} \{                                     \par
00443             {\cf19 if} (read_btn_flag(B_PRS)) \{                 \par
00444                 {\cf19 if} (deb >= EB_DEB_T) \{               \par
00445                     {\cf19 if} (!read_btn_flag(B_HLD)) clicks++;    \par
00446                     {\cf19 if} (read_btn_flag(B_EHLD)) clicks = 0;  \par
00447                     set_btn_flag(B_REL | B_REL_R);        \par
00448                     clr_btn_flag(B_PRS);                   \par
00449                 \}\par
00450             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_REL)) \{\par
00451                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00452                     set_btn_flag(B_REL_R);\par
00453                 \}\par
00454                 clr_btn_flag(B_REL | B_EHLD);\par
00455                 timer = ms;       \par
00456             \} {\cf19 else} {\cf19 if} (clicks) \{  \par
00457 {\cf21 #ifdef EB_CLICK_TIME}\par
00458                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)EB_CLICK_T) set_btn_flag(B_CLKS_R);  \par
00459 {\cf21 #else}\par
00460                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)(EB_CLICK_T << EB_SHIFT)) set_btn_flag(B_CLKS_R);  \par
00461 {\cf21 #endif}\par
00462 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00463                 {\cf19 else} {\cf19 if} (run_timer) run_timer = 0;\par
00464 {\cf21 #endif}\par
00465             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_BUSY)) \{\par
00466                 clr_btn_flag(B_HLD | B_STP | B_BUSY);\par
00467                 set_btn_flag(B_TOUT);\par
00468 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00469                 run_timer = 0;\par
00470 {\cf21 #endif}\par
00471                 timer = ms;  {\cf20 // test!!}\par
00472             \}\par
00473             {\cf19 if} (read_btn_flag(B_DEB)) clr_btn_flag(B_DEB);  \par
00474         \}\par
00475         {\cf19 return} read_btn_flag(B_CLKS_R | B_PRS_R | B_HLD_R | B_STP_R | B_REL_R);\par
00476     \}\par
}
}
{\xe \v pollEnc\:VirtEncButton}
{\xe \v VirtEncButton\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::pollEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 305} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00305                                      \{\par
00306         {\cf19 return} pollEnc(e0 | (e1 << 1));\par
00307     \}\par
}
}
{\xe \v pollEnc\:VirtEncButton}
{\xe \v VirtEncButton\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::pollEnc (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 315} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00315                                  \{\par
00316         {\cf19 if} (prev != state) \{\par
00317             ecount += ((0x49941661 >> ((state | (prev << 2)) << 1)) & 0b11) - 1;\par
00318             prev = state;\par
00319             {\cf19 if} (!ecount) {\cf19 return} 0;\par
00320             {\cf19 switch} (flags & 0b11) \{\par
00321                 {\cf19 case} EB_STEP4_LOW:\par
00322                     {\cf19 if} (state != 0b11) {\cf19 return} 0;  {\cf20 // skip 00, 01, 10}\par
00323                     {\cf19 break};\par
00324                 {\cf19 case} EB_STEP4_HIGH:\par
00325                     {\cf19 if} (state) {\cf19 return} 0;  {\cf20 // skip 01, 10, 11}\par
00326                     {\cf19 break};\par
00327                 {\cf19 case} EB_STEP2:\par
00328                     {\cf19 if} (state == 0b10 || state == 0b01) {\cf19 return} 0;  {\cf20 // skip 10 01}\par
00329                     {\cf19 break};\par
00330             \}\par
00331             state = ((ecount > 0) ^ read_encf(E_REVERSE)) ? 1 : -1;\par
00332             ecount = 0;\par
00333 {\cf21 #ifndef EB_NO_COUNTER}\par
00334             counter += state;\par
00335 {\cf21 #endif}\par
00336             {\cf19 return} state;\par
00337         \}\par
00338         {\cf19 return} 0;\par
00339     \}\par
}
}
{\xe \v press\:VirtEncButton}
{\xe \v VirtEncButton\:press}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::press (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00154                  \{\par
00155         {\cf19 return} read_btn_flag(B_PRS_R);\par
00156     \}\par
}
}
{\xe \v pressFor\:VirtEncButton}
{\xe \v VirtEncButton\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::pressFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the duration in milliseconds for which the button has been pressed. If the EB_NO_PEDOMETER macro is defined, the function always returns 0. If the button is not currently pressed, the function also returns 0.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The duration in milliseconds for which the button has been pressed. \par
}}}{
Definition at line {\b 297} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00297                         \{\par
00298 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00299         {\cf19 if} (run_timer) {\cf19 return} (uint16_t)EB_UPTIME() - run_timer;\par
00300 {\cf21 #endif}\par
00301         {\cf19 return} 0;\par
00302     \}\par
}
}
{\xe \v pressFor\:VirtEncButton}
{\xe \v VirtEncButton\:pressFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 304} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00304                                \{\par
00305         {\cf19 return} pressFor() > ms;\par
00306     \}\par
}
}
{\xe \v pressing\:VirtEncButton}
{\xe \v VirtEncButton\:pressing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::pressing (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00166                     \{\par
00167         {\cf19 return} read_btn_flag(B_PRS);\par
00168     \}\par
}
}
{\xe \v pressISR\:VirtEncButton}
{\xe \v VirtEncButton\:pressISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::pressISR (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00112                     \{\par
00113         {\cf19 if} (!read_btn_flag(B_DEB)) timer = EB_UPTIME();\par
00114         set_btn_flag(B_DEB | B_BISR);\par
00115     \}\par
}
}
{\xe \v read_btn_flag\:VirtEncButton}
{\xe \v VirtEncButton\:read_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::read_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 506} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                                                                                \{\par
00507         {\cf19 return} flags & x;\par
00508     \}\par
}
}
{\xe \v read_encf\:VirtEncButton}
{\xe \v VirtEncButton\:read_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::read_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00357                                                                            \{\par
00358         {\cf19 return} flags & x;\par
00359     \}\par
}
}
{\xe \v release\:VirtEncButton}
{\xe \v VirtEncButton\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::release (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00158                    \{\par
00159         {\cf19 return} eq_btn_flag(B_REL_R | B_REL, B_REL_R | B_REL);\par
00160     \}\par
}
}
{\xe \v releaseHold\:VirtEncButton}
{\xe \v VirtEncButton\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                        \{\par
00218         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD | B_STP, B_REL_R | B_HLD);\par
00219     \}\par
}
}
{\xe \v releaseHold\:VirtEncButton}
{\xe \v VirtEncButton\:releaseHold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseHold ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00221                                   \{\par
00222         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_HLD | B_STP, B_CLKS_R | B_HLD);\par
00223     \}\par
}
}
{\xe \v releaseStep\:VirtEncButton}
{\xe \v VirtEncButton\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00225                        \{\par
00226         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_STP, B_REL_R | B_STP);\par
00227     \}\par
}
}
{\xe \v releaseStep\:VirtEncButton}
{\xe \v VirtEncButton\:releaseStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::releaseStep ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00229                                   \{\par
00230         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_STP, B_CLKS_R | B_STP);\par
00231     \}\par
}
}
{\xe \v reset\:VirtEncButton}
{\xe \v VirtEncButton\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::reset (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117                  \{\par
00118         clicks = 0;\par
00119         clr_btn_flag(~B_INV);\par
00120     \}\par
}
}
{\xe \v right\:VirtEncButton}
{\xe \v VirtEncButton\:right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::right (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right without holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right without holding the button, false otherwise \par
}}}{
Definition at line {\b 133} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00133                  \{\par
00134         {\cf19 return} read_encf(E_DIR) && turn() && !read_btn_flag(B_EHLD);\par
00135     \}\par
}
}
{\xe \v rightH\:VirtEncButton}
{\xe \v VirtEncButton\:rightH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::rightH (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right while holding the button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right while holding the button, false otherwise \par
}}}{
Definition at line {\b 151} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00151                   \{\par
00152         {\cf19 return} read_encf(E_DIR) && turnH();\par
00153     \}\par
}
}
{\xe \v set_btn_flag\:VirtEncButton}
{\xe \v VirtEncButton\:set_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::set_btn_flag ({\b const} {\b uint16_t}  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 500} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00500                                                                               \{\par
00501         flags |= x;\par
00502     \}\par
}
}
{\xe \v set_encf\:VirtEncButton}
{\xe \v VirtEncButton\:set_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::set_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 347} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00347                                                                           \{\par
00348         flags |= x;\par
00349     \}\par
}
}
{\xe \v setBtnLevel\:VirtEncButton}
{\xe \v VirtEncButton\:setBtnLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setBtnLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00108                                  \{\par
00109         write_btn_flag(B_INV, !level);\par
00110     \}\par
}
}
{\xe \v setButtonLevel\:VirtEncButton}
{\xe \v VirtEncButton\:setButtonLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setButtonLevel ({\b bool}  {\i level}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00385                                     \{\par
00386         write_btn_flag(B_INV, !level);\par
00387     \}\par
}
}
{\xe \v setClickTimeout\:VirtEncButton}
{\xe \v VirtEncButton\:setClickTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setClickTimeout ({\b uint16_t}  {\i timeout} = {\f2 500}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the click timeout for the virtual button. Clicks faster than this timeout will be detected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The click timeout value in milliseconds. Default is 500 milliseconds. Max is 4000ms. \cell }
{\row }
}
}{
Definition at line {\b 96} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096                                                \{\par
00097 {\cf21 #ifndef EB_CLICK_TIME}\par
00098         EB_CLICK_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00099 {\cf21 #endif}\par
00100     \}\par
}
}
{\xe \v setDebounceTimeout\:VirtEncButton}
{\xe \v VirtEncButton\:setDebounceTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setDebounceTimeout ({\b uint8_t}  {\i timeout} = {\f2 50}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00102                                                 \{\par
00103 {\cf21 #ifndef EB_DEB_TIME}\par
00104         EB_DEB_T = (timeout < 255) ? timeout : 255;\par
00105 {\cf21 #endif}\par
00106     \}\par
}
}
{\xe \v setEncISR\:VirtEncButton}
{\xe \v VirtEncButton\:setEncISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncISR (bool  {\i use} = {\f2 true}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use} \cell }{true to use the ISR, false otherwise \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Argument "use" by default is true because name of this function means that it is used to set/activate the ISR. \par
}}}{
Definition at line {\b 78} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078                                  \{\par
00079         write_encf(E_ISR, use);\par
00080     \}\par
}
}
{\xe \v setEncReverse\:VirtEncButton}
{\xe \v VirtEncButton\:setEncReverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncReverse (bool  {\i rev} = {\f2 false}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rev} \cell }{true to reverse the encoder, false otherwise \cell }
{\row }
}
}{
Definition at line {\b 57} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00057                                          \{\par
00058         {\cf19 if} (rev) set_encf(E_REVERSE);\par
00059         {\cf19 else} clr_encf(E_REVERSE);\par
00060     \}\par
}
}
{\xe \v setEncType\:VirtEncButton}
{\xe \v VirtEncButton\:setEncType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::setEncType (uint8_t  {\i type} = {\f2 {\b EB_STEP1}}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i type} \cell }{the encoder type to set \cell }
{\row }
}
}{
Definition at line {\b 67} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00067                                              \{\par
00068         flags = (flags & 0b11111100) | type;\par
00069     \}\par
}
}
{\xe \v setFastTimeout\:VirtEncButton}
{\xe \v VirtEncButton\:setFastTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::setFastTimeout ({\b uint8_t}  {\i tout}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the Fast Timeout object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The fast timeout value to set \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the fast timeout was successfully set, false otherwise \par
}}}{
Definition at line {\b 35} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00035                                       \{\par
00036 {\cf21 #ifndef EB_FAST_TIME}\par
00037         EB_FAST_T = tout;\par
00038         {\cf19 return} {\cf17 true};\par
00039 {\cf21 #endif}\par
00040         {\cf19 return} {\cf17 false};\par
00041     \}\par
}
}
{\xe \v setHoldTimeout\:VirtEncButton}
{\xe \v VirtEncButton\:setHoldTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setHoldTimeout ({\b uint16_t}  {\i timeout} = {\f2 600}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the hold timeout for the virtual button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The hold timeout value in milliseconds. Default is 600 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 74} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00074                                               \{\par
00075 {\cf21 #ifndef EB_HOLD_TIME}\par
00076         EB_HOLD_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00077 {\cf21 #endif}\par
00078     \}\par
}
}
{\xe \v setStepTimeout\:VirtEncButton}
{\xe \v VirtEncButton\:setStepTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::setStepTimeout ({\b uint16_t}  {\i timeout} = {\f2 200}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the step timeout for the virtual button. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{The timeout value in milliseconds. Default is 200 milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
max timeout is 4000 ms \par
}}}{
Definition at line {\b 85} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085                                               \{\par
00086 {\cf21 #ifndef EB_STEP_TIME}\par
00087         EB_STEP_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00088 {\cf21 #endif}\par
00089     \}\par
}
}
{\xe \v step\:VirtEncButton}
{\xe \v VirtEncButton\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                 \{\par
00187         {\cf19 return} read_btn_flag(B_STP_R);\par
00188     \}\par
}
}
{\xe \v step\:VirtEncButton}
{\xe \v VirtEncButton\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::step ({\b uint8_t}  {\i num}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190                            \{\par
00191         {\cf19 return} clicks == num && step();\par
00192     \}\par
}
}
{\xe \v stepFor\:VirtEncButton}
{\xe \v VirtEncButton\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::stepFor (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00336                        \{\par
00337 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00338         {\cf19 if} (read_btn_flag(B_STP)) \{\par
00339 {\cf21 #ifdef EB_HOLD_TIME}\par
00340             {\cf19 return} pressFor() - EB_HOLD_T * 2;\par
00341 {\cf21 #else}\par
00342             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT) * 2;\par
00343 {\cf21 #endif}\par
00344         \}\par
00345 {\cf21 #endif}\par
00346         {\cf19 return} 0;\par
00347     \}\par
}
}
{\xe \v stepFor\:VirtEncButton}
{\xe \v VirtEncButton\:stepFor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::stepFor ({\b uint16_t}  {\i ms}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 349} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                               \{\par
00350         {\cf19 return} stepFor() > ms;\par
00351     \}\par
}
}
{\xe \v tick\:VirtEncButton}
{\xe \v VirtEncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tick (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 257} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00257                   \{\par
00258         {\cf19 return} tick(-1);\par
00259     \}\par
}
}
{\xe \v tick\:VirtEncButton}
{\xe \v VirtEncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b bool}  {\i btn}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 324} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00324                         \{\par
00325         {\cf19 return} tick(-1, btn);\par
00326     \}\par
}
}
{\xe \v tick\:VirtEncButton}
{\xe \v VirtEncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tick (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 228} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00228                                   \{\par
00229         {\cf19 return} tick(e0 | (e1 << 1));\par
00230     \}\par
}
}
{\xe \v tick\:VirtEncButton}
{\xe \v VirtEncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b bool}  {\i e0}, {\b bool}  {\i e1}, {\b bool}  {\i btn}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 276} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00276                                           \{\par
00277         {\cf19 return} tick(e0 | (e1 << 1), btn);\par
00278     \}\par
}
}
{\xe \v tick\:VirtEncButton}
{\xe \v VirtEncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tick (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 238} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                               \{\par
00239         state = tickRaw(state);\par
00240         {\cf19 if} (state)\par
00241         \{\par
00242 {\cf21     #ifndef EB_NO_CALLBACK}\par
00243             {\cf19 if} (cb[0] && state < 0) cb[0]();\par
00244             {\cf19 if} (cb[1] && state > 0) cb[1]();\par
00245 {\cf21     #endif}\par
00246             {\cf19 return} state;\par
00247         \}\par
00248         clear();\par
00249         {\cf19 return} 0;\par
00250     \}\par
}
}
{\xe \v tick\:VirtEncButton}
{\xe \v VirtEncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tick ({\b int8_t}  {\i state}, {\b bool}  {\i btn}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 287} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00287                                       \{\par
00288         clear();\par
00289         {\cf18 bool} f = tickRaw(state, btn);\par
00290 \par
00291 {\cf21 #ifndef EB_NO_CALLBACK}\par
00292         {\cf19 if}(f)\{\par
00293             {\cf19 switch} (action())\par
00294             \{\par
00295                 {\cf19 case} EB_PRESS:\par
00296                     {\cf19 if}(cb[0]) (this->cb[0])();\par
00297                     {\cf19 break};\par
00298                 {\cf19 case} EB_TURN_R:\par
00299                     {\cf19 if}(cb[1]) (this->cb[1])();\par
00300                     {\cf19 break};\par
00301                 {\cf19 case} EB_TURN_L:\par
00302                     {\cf19 if}(cb[2]) (this->cb[2])();\par
00303                     {\cf19 break};\par
00304                 {\cf19 case} EB_TURN_HOLD_R:\par
00305                     {\cf19 if}(cb[3]) (this->cb[3])();\par
00306                     {\cf19 break};\par
00307                 {\cf19 case} EB_TURN_HOLD_L:\par
00308                     {\cf19 if}(cb[4]) (this->cb[4])();\par
00309                     {\cf19 break};\par
00310                 {\cf19 default}:\par
00311                     {\cf19 break};\par
00312             \}\par
00313         \}\par
00314 {\cf21 #endif}\par
00315         {\cf19 return} f;\par
00316     \}\par
}
}
{\xe \v tick\:VirtEncButton}
{\xe \v VirtEncButton\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::tick ({\b VirtButton} &  {\i b0}, {\b VirtButton} &  {\i b1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00354                                               \{\par
00355         {\cf19 if} (read_btn_flag(B_BOTH)) \{\par
00356             {\cf19 if} (!b0.pressing() && !b1.pressing()) clr_btn_flag(B_BOTH);\par
00357             {\cf19 if} (!b0.pressing()) b0.reset();\par
00358             {\cf19 if} (!b1.pressing()) b1.reset();\par
00359             b0.clear();\par
00360             b1.clear();\par
00361             {\cf19 return} tick(1);\par
00362         \} {\cf19 else} \{\par
00363             {\cf19 if} (b0.pressing() && b1.pressing()) set_btn_flag(B_BOTH);\par
00364             {\cf19 return} tick(0);\par
00365         \}\par
00366     \}\par
}
}
{\xe \v tickISR\:VirtEncButton}
{\xe \v VirtEncButton\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncButton::tickISR ({\b bool}  {\i e0}, {\b bool}  {\i e1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The updated state of the encoder button \par
}}}{
Definition at line {\b 234} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00234                                      \{\par
00235         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00236     \}\par
}
}
{\xe \v tickISR\:VirtEncButton}
{\xe \v VirtEncButton\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncButton::tickISR ({\b int8_t}  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the interrupt tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The updated state of the encoder button \par
}}}{
Definition at line {\b 244} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                  \{\par
00245         state = VirtEncoder::pollEnc(state);\par
00246         {\cf19 if} (state) \{\par
00247 {\cf21 #ifdef EB_NO_BUFFER}\par
00248             set_encf(E_ISR_F);\par
00249             write_encf(E_DIR, state > 0);\par
00250             write_encf(E_FAST, checkFast());\par
00251 {\cf21 #else}\par
00252             {\cf19 for} (uint8_t i = 0; i < 15; i += 3) \{\par
00253                 {\cf19 if} (!(ebuffer & (1 << i))) \{\par
00254                     ebuffer |= (1 << i);                 {\cf20 // turn}\par
00255                     {\cf19 if} (state > 0) ebuffer |= E_DIR;    {\cf20 // dir}\par
00256                     {\cf19 if} (checkFast()) ebuffer |= E_FAST;  {\cf20 // fast}\par
00257 \par
00258                     {\cf20 // if (state > 0) ebuffer |= (1 << (i + 1));    // dir}\par
00259                     {\cf20 // if (checkFast()) ebuffer |= (1 << (i + 2));  // fast}\par
00260                     {\cf19 break};\par
00261                 \}\par
00262             \}\par
00263 {\cf21 #endif}\par
00264         \}\par
00265         {\cf19 return} state;\par
00266     \}\par
}
}
{\xe \v tickRaw\:VirtEncButton}
{\xe \v VirtEncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tickRaw (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 294} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00294                      \{\par
00295         {\cf19 return} tickRaw(-1);\par
00296     \}\par
}
}
{\xe \v tickRaw\:VirtEncButton}
{\xe \v VirtEncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b bool}  {\i btn}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 386} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00386                            \{\par
00387         {\cf19 return} tickRaw(-1, btn);\par
00388     \}\par
}
}
{\xe \v tickRaw\:VirtEncButton}
{\xe \v VirtEncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tickRaw (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 268} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00268                                      \{\par
00269         {\cf19 return} tickRaw(e0 | (e1 << 1));\par
00270     \}\par
}
}
{\xe \v tickRaw\:VirtEncButton}
{\xe \v VirtEncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b bool}  {\i e0}, {\b bool}  {\i e1}, {\b bool}  {\i btn}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e0} \cell }{The state of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i e1} \cell }{The state of the second encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 338} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00338                                              \{\par
00339         {\cf19 return} tickRaw(e0 | (e1 << 1), btn);\par
00340     \}\par
}
}
{\xe \v tickRaw\:VirtEncButton}
{\xe \v VirtEncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int8_t} VirtEncoder::tickRaw (int8_t  {\i state}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00279                                  \{\par
00280         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00281             clr_encf(E_ISR_F);\par
00282             set_encf(E_TRN_R);\par
00283             {\cf19 return} dir();\par
00284         \}\par
00285         {\cf19 if} ((state >= 0) && (state = pollEnc(state))) \{\par
00286             write_encf(E_DIR, state > 0);\par
00287             set_encf(E_TRN_R);\par
00288             {\cf19 return} state;\par
00289         \}\par
00290         {\cf19 return} 0;\par
00291     \}\par
}
}
{\xe \v tickRaw\:VirtEncButton}
{\xe \v VirtEncButton\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::tickRaw ({\b int8_t}  {\i state}, {\b bool}  {\i btn}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle the raw tick for the encoder button. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i state} \cell }{The current state of the encoder button \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i btn} \cell }{The state of the button \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button state has changed, false otherwise \par
}}}{
Definition at line {\b 349} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00349                                          \{\par
00350         btn = VirtButton::tickRaw(btn);\par
00351 \par
00352         {\cf18 bool} encf = 0;\par
00353 {\cf21 #ifdef EB_NO_BUFFER}\par
00354         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00355             clr_encf(E_ISR_F);\par
00356             encf = 1;\par
00357         \}\par
00358 {\cf21 #else}\par
00359         {\cf19 if} (ebuffer) \{\par
00360             write_encf(E_DIR, ebuffer & 0b10);\par
00361             write_encf(E_FAST, ebuffer & 0b100);\par
00362             ebuffer >>= 3;\par
00363             encf = 1;\par
00364         \}\par
00365 {\cf21 #endif}\par
00366         {\cf19 else} {\cf19 if} ((state >= 0) && (state = VirtEncoder::pollEnc(state))) \{\par
00367             write_encf(E_DIR, state > 0);\par
00368             write_encf(E_FAST, checkFast());\par
00369             encf = 1;\par
00370         \}\par
00371         {\cf19 if} (encf) \{\par
00372             {\cf19 if} (read_btn_flag(B_PRS)) set_btn_flag(B_EHLD);    \par
00373             {\cf19 else} clicks = 0;\par
00374             {\cf19 if} (!read_btn_flag(B_TOUT)) set_btn_flag(B_TOUT);  \par
00375             set_encf(E_TRN_R);                      \par
00376         \}\par
00377         {\cf19 return} encf | btn;\par
00378     \}\par
}
}
{\xe \v timeout\:VirtEncButton}
{\xe \v VirtEncButton\:timeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtButton::timeout (uint16_t  {\i tout}){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the timeout has occurred.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tout} \cell }{The timeout value in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the timeout has occurred, false otherwise. \par
}}}{
Definition at line {\b 282} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00282                                 \{\par
00283         {\cf19 if} (read_btn_flag(B_TOUT) && (uint16_t)((uint16_t)EB_UPTIME() - timer) > tout) \{\par
00284             clr_btn_flag(B_TOUT);\par
00285             {\cf19 return} 1;\par
00286         \}\par
00287         {\cf19 return} 0;\par
00288     \}\par
}
}
{\xe \v turn\:VirtEncButton}
{\xe \v VirtEncButton\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncoder::turn (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder has been turned, false otherwise \par
}}}{
Definition at line {\b 161} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00161                 \{\par
00162         {\cf19 return} read_encf(E_TRN_R);\par
00163     \}\par
}
}
{\xe \v turnH\:VirtEncButton}
{\xe \v VirtEncButton\:turnH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtEncButton::turnH (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder button is turned to the right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder button is turned to the right, false otherwise \par
}}}{
Definition at line {\b 115} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                  \{\par
00116         {\cf19 return} turn() && read_btn_flag(B_EHLD);\par
00117     \}\par
}
}
{\xe \v waiting\:VirtEncButton}
{\xe \v VirtEncButton\:waiting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} VirtButton::waiting (){\f2 [inline]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00233                    \{\par
00234         {\cf19 return} clicks && eq_btn_flag(B_PRS | B_REL, 0);\par
00235     \}\par
}
}
{\xe \v write_btn_flag\:VirtEncButton}
{\xe \v VirtEncButton\:write_btn_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtButton::write_btn_flag ({\b const} {\b uint16_t}  {\i x}, {\b bool}  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 509} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00509                                                                                         \{\par
00510         {\cf19 if} (v) set_btn_flag(x);\par
00511         {\cf19 else} clr_btn_flag(x);\par
00512     \}\par
}
}
{\xe \v write_encf\:VirtEncButton}
{\xe \v VirtEncButton\:write_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b void} VirtEncoder::write_encf (const uint16_t  {\i x}, bool  {\i v}){\f2 [inline]}, {\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00353                                                                                     \{\par
00354         {\cf19 if} (v) set_encf(x);\par
00355         {\cf19 else} clr_encf(x);\par
00356     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:VirtEncButton}
{\xe \v VirtEncButton\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtEncButton::cb[5] = \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\b nullptr}, {\b nullptr}\}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 396} of file {\b VirtEncButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00396 \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\cf17 nullptr}, {\cf17 nullptr}\};\par
}
}
{\xe \v clicks\:VirtEncButton}
{\xe \v VirtEncButton\:clicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::clicks{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b VirtButton.h}.}\par
}
{\xe \v counter\:VirtEncButton}
{\xe \v VirtEncButton\:counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int32_t} VirtEncoder::counter = 0{\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 342} of file {\b VirtEncoder.h}.}\par
}
{\xe \v EB_CLICK_T\:VirtEncButton}
{\xe \v VirtEncButton\:EB_CLICK_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_CLICK_T = (500 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_DEB_T\:VirtEncButton}
{\xe \v VirtEncButton\:EB_DEB_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_DEB_T = 50{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_FAST_T\:VirtEncButton}
{\xe \v VirtEncButton\:EB_FAST_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtEncButton::EB_FAST_T = 30{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 400} of file {\b VirtEncButton.h}.}\par
}
{\xe \v EB_HOLD_T\:VirtEncButton}
{\xe \v VirtEncButton\:EB_HOLD_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_HOLD_T = (600 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 494} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_STEP_T\:VirtEncButton}
{\xe \v VirtEncButton\:EB_STEP_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} VirtButton::EB_STEP_T = (200 >> {\b EB_SHIFT}){\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 497} of file {\b VirtButton.h}.}\par
}
{\xe \v ebuffer\:VirtEncButton}
{\xe \v VirtEncButton\:ebuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtEncButton::ebuffer = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 404} of file {\b VirtEncButton.h}.}\par
}
{\xe \v run_timer\:VirtEncButton}
{\xe \v VirtEncButton\:run_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::run_timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 480} of file {\b VirtButton.h}.}\par
}
{\xe \v timer\:VirtEncButton}
{\xe \v VirtEncButton\:timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16_t} VirtButton::timer = 0{\f2 [protected]}, {\f2 [inherited]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b VirtEncButton.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VirtEncoder Class Reference\par \pard\plain 
{\tc\tcl2 \v VirtEncoder}
{\xe \v VirtEncoder}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a virtual encoder. This class provides methods to set the encoder's properties, attach_call callback functions for handling encoder events, and poll the encoder for rotation and direction. }}\par
{
{\f2 #include <VirtEncoder.h>}}\par
Inheritance diagram for VirtEncoder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dc/d02/class_virt_encoder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VirtEncoder} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor for {\b VirtEncoder} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncReverse} (bool rev=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncType} (uint8_t type={\b EB_STEP1})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEncISR} (bool use=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b attach_right} ({\b cb_t} callback_func)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b attach_left} ({\b cb_t} callback_func)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b detach_call} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for handling encoder events. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initEnc} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initEnc} (int8_t v)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the encoder flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b turn} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b dir} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EB_FLAGS_T} {\b action} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing the possible flags for the encoder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickISR} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickISR} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tick} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
tickRaw <br>\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b counter} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cb_t} {\b cb} [2] = \{nullptr, nullptr\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} (int8_t state)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b tickRaw} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b pollEnc} (bool e0, bool e1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int8_t {\b pollEnc} (int8_t state)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_encf} (const uint16_t x) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clr_encf} (const uint16_t x) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_encf} (const uint16_t x, bool v) __attribute__((always_inline))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b read_encf} (const uint16_t x) __attribute__((always_inline))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a virtual encoder. This class provides methods to set the encoder's properties, attach_call callback functions for handling encoder events, and poll the encoder for rotation and direction. \par
}{
Definition at line {\b 42} of file {\b VirtEncoder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VirtEncoder\:VirtEncoder}
{\xe \v VirtEncoder\:VirtEncoder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
VirtEncoder::VirtEncoder (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor for {\b VirtEncoder} class. }}\par
{
Definition at line {\b 48} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00048 : prev(0), ecount(0) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v action\:VirtEncoder}
{\xe \v VirtEncoder\:action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EB_FLAGS_T} VirtEncoder::action (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Representing the possible flags for the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
EB_FLAGS_T can have the following values:{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN: Represents the flag for turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN_L: Represents the flag for left turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_TURN_R: Represents the flag for right turning action.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EB_NONE: Represents the flag for no action. \par}
}}}{
Definition at line {\b 182} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182                         \{\par
00183         {\cf19 switch} (flags & 0b111111111) \{\par
00184             {\cf19 case}(E_TRN_R | E_FAST):\par
00185                 {\cf19 return} EB_TURN;\par
00186             {\cf19 case}(E_TRN_R | E_DIR | E_REVERSE):\par
00187                 {\cf19 return} EB_TURN_L;\par
00188             {\cf19 case}(E_TRN_R | E_DIR):\par
00189                 {\cf19 return} EB_TURN_R;   \par
00190             {\cf19 default}:\par
00191                 {\cf19 return} EB_NONE;\par
00192         \}\par
00193     \}\par
}
}
{\xe \v attach_left\:VirtEncoder}
{\xe \v VirtEncoder\:attach_left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::attach_left ({\b cb_t}  {\i callback_func}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned left. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 105} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00105                                         \{\par
00106 {\cf21 #ifndef EB_NO_CALLBACK}\par
00107         uint8_t l_r = (read_encf(E_REVERSE)) ? 0 : 1;\par
00108         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00109         cb[l_r] = *callback_func;\par
00110         {\cf19 return} {\cf17 true};\par
00111 {\cf21 #endif}\par
00112         {\cf19 return} {\cf17 false};\par
00113     \}\par
}
}
{\xe \v attach_right\:VirtEncoder}
{\xe \v VirtEncoder\:attach_right}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::attach_right ({\b cb_t}  {\i callback_func}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attach a callback function to handle encoder events when turned right. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i callback_func} \cell }{pointer to the callback function \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
callback_func can be "cb_t" type \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the callback is attached, false otherwise \par
}}}{
Definition at line {\b 89} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00089                                          \{\par
00090 {\cf21 #ifndef EB_NO_CALLBACK}\par
00091         uint8_t l_r = (read_encf(E_REVERSE)) ? 1 : 0;\par
00092         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00093         cb[l_r] = *callback_func;\par
00094         {\cf19 return} {\cf17 true};\par
00095 {\cf21 #endif}\par
00096         {\cf19 return} {\cf17 false};\par
00097     \}\par
}
}
{\xe \v clear\:VirtEncoder}
{\xe \v VirtEncoder\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::clear (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the encoder flags. }}\par
{
Definition at line {\b 150} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00150                  \{\par
00151         {\cf19 if} (read_encf(E_TRN_R)) clr_encf(E_TRN_R);\par
00152     \}\par
}
}
{\xe \v clr_encf\:VirtEncoder}
{\xe \v VirtEncoder\:clr_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::clr_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00350                                                                           \{\par
00351         flags &= ~x;\par
00352     \}\par
}
}
{\xe \v detach_call\:VirtEncoder}
{\xe \v VirtEncoder\:detach_call}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::detach_call (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detach the callback functions for handling encoder events. }}\par
{
Definition at line {\b 121} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121                        \{\par
00122 {\cf21 #ifndef EB_NO_CALLBACK}\par
00123         cb[0] = {\cf17 nullptr};\par
00124         cb[1] = {\cf17 nullptr};\par
00125 {\cf21 #endif}\par
00126     \}\par
}
}
{\xe \v dir\:VirtEncoder}
{\xe \v VirtEncoder\:dir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::dir (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the direction of rotation of the encoder. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1 if rotated left, 1 if rotated right \par
}}}{
Definition at line {\b 170} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170                  \{\par
00171         {\cf19 return} read_encf(E_DIR) ? 1 : -1;\par
00172     \}\par
}
}
{\xe \v initEnc\:VirtEncoder}
{\xe \v VirtEncoder\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::initEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
}{
Definition at line {\b 134} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                                    \{\par
00135         initEnc(e0 | (e1 << 1));\par
00136     \}\par
}
}
{\xe \v initEnc\:VirtEncoder}
{\xe \v VirtEncoder\:initEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::initEnc (int8_t  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the encoder with the specified value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v} \cell }{the initial value of the encoder \cell }
{\row }
}
}{
Definition at line {\b 143} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143                            \{\par
00144         prev = v;\par
00145     \}\par
}
}
{\xe \v pollEnc\:VirtEncoder}
{\xe \v VirtEncoder\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::pollEnc (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 305} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00305                                      \{\par
00306         {\cf19 return} pollEnc(e0 | (e1 << 1));\par
00307     \}\par
}
}
{\xe \v pollEnc\:VirtEncoder}
{\xe \v VirtEncoder\:pollEnc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::pollEnc (int8_t  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Poll the encoder without setting the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 315} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00315                                  \{\par
00316         {\cf19 if} (prev != state) \{\par
00317             ecount += ((0x49941661 >> ((state | (prev << 2)) << 1)) & 0b11) - 1;\par
00318             prev = state;\par
00319             {\cf19 if} (!ecount) {\cf19 return} 0;\par
00320             {\cf19 switch} (flags & 0b11) \{\par
00321                 {\cf19 case} EB_STEP4_LOW:\par
00322                     {\cf19 if} (state != 0b11) {\cf19 return} 0;  {\cf20 // skip 00, 01, 10}\par
00323                     {\cf19 break};\par
00324                 {\cf19 case} EB_STEP4_HIGH:\par
00325                     {\cf19 if} (state) {\cf19 return} 0;  {\cf20 // skip 01, 10, 11}\par
00326                     {\cf19 break};\par
00327                 {\cf19 case} EB_STEP2:\par
00328                     {\cf19 if} (state == 0b10 || state == 0b01) {\cf19 return} 0;  {\cf20 // skip 10 01}\par
00329                     {\cf19 break};\par
00330             \}\par
00331             state = ((ecount > 0) ^ read_encf(E_REVERSE)) ? 1 : -1;\par
00332             ecount = 0;\par
00333 {\cf21 #ifndef EB_NO_COUNTER}\par
00334             counter += state;\par
00335 {\cf21 #endif}\par
00336             {\cf19 return} state;\par
00337         \}\par
00338         {\cf19 return} 0;\par
00339     \}\par
}
}
{\xe \v read_encf\:VirtEncoder}
{\xe \v VirtEncoder\:read_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::read_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00357                                                                            \{\par
00358         {\cf19 return} flags & x;\par
00359     \}\par
}
}
{\xe \v set_encf\:VirtEncoder}
{\xe \v VirtEncoder\:set_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::set_encf (const uint16_t  {\i x}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 347} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00347                                                                           \{\par
00348         flags |= x;\par
00349     \}\par
}
}
{\xe \v setEncISR\:VirtEncoder}
{\xe \v VirtEncoder\:setEncISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncISR (bool  {\i use} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use} \cell }{true to use the ISR, false otherwise \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Argument "use" by default is true because name of this function means that it is used to set/activate the ISR. \par
}}}{
Definition at line {\b 78} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078                                  \{\par
00079         write_encf(E_ISR, use);\par
00080     \}\par
}
}
{\xe \v setEncReverse\:VirtEncoder}
{\xe \v VirtEncoder\:setEncReverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncReverse (bool  {\i rev} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's reverse flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rev} \cell }{true to reverse the encoder, false otherwise \cell }
{\row }
}
}{
Definition at line {\b 57} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00057                                          \{\par
00058         {\cf19 if} (rev) set_encf(E_REVERSE);\par
00059         {\cf19 else} clr_encf(E_REVERSE);\par
00060     \}\par
}
}
{\xe \v setEncType\:VirtEncoder}
{\xe \v VirtEncoder\:setEncType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::setEncType (uint8_t  {\i type} = {\f2 {\b EB_STEP1}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the encoder's type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i type} \cell }{the encoder type to set \cell }
{\row }
}
}{
Definition at line {\b 67} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00067                                              \{\par
00068         flags = (flags & 0b11111100) | type;\par
00069     \}\par
}
}
{\xe \v tick\:VirtEncoder}
{\xe \v VirtEncoder\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tick (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 257} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00257                   \{\par
00258         {\cf19 return} tick(-1);\par
00259     \}\par
}
}
{\xe \v tick\:VirtEncoder}
{\xe \v VirtEncoder\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tick (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 228} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00228                                   \{\par
00229         {\cf19 return} tick(e0 | (e1 << 1));\par
00230     \}\par
}
}
{\xe \v tick\:VirtEncoder}
{\xe \v VirtEncoder\:tick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tick (int8_t  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 238} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00238                               \{\par
00239         state = tickRaw(state);\par
00240         {\cf19 if} (state)\par
00241         \{\par
00242 {\cf21     #ifndef EB_NO_CALLBACK}\par
00243             {\cf19 if} (cb[0] && state < 0) cb[0]();\par
00244             {\cf19 if} (cb[1] && state > 0) cb[1]();\par
00245 {\cf21     #endif}\par
00246             {\cf19 return} state;\par
00247         \}\par
00248         clear();\par
00249         {\cf19 return} 0;\par
00250     \}\par
}
}
{\xe \v tickISR\:VirtEncoder}
{\xe \v VirtEncoder\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickISR (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 202} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00202                                      \{\par
00203         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00204     \}\par
}
}
{\xe \v tickISR\:VirtEncoder}
{\xe \v VirtEncoder\:tickISR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickISR (int8_t  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick using the interrupt service routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i state} \cell }{the current state of the encoder \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 212} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00212                                  \{\par
00213         state = pollEnc(state);\par
00214         {\cf19 if} (state) \{\par
00215             set_encf(E_ISR_F);\par
00216             write_encf(E_DIR, state > 0);\par
00217         \}\par
00218         {\cf19 return} state;\par
00219     \}\par
}
}
{\xe \v tickRaw\:VirtEncoder}
{\xe \v VirtEncoder\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickRaw (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 294} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00294                      \{\par
00295         {\cf19 return} tickRaw(-1);\par
00296     \}\par
}
}
{\xe \v tickRaw\:VirtEncoder}
{\xe \v VirtEncoder\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickRaw (bool  {\i e0}, bool  {\i e1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the encoder tick without clearing the turn flag. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e0} \cell }{the value of the first encoder pin \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i e1} \cell }{the value of the second encoder pin \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1, 0, or 1 based on the direction of rotation \par
}}}{
Definition at line {\b 268} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00268                                      \{\par
00269         {\cf19 return} tickRaw(e0 | (e1 << 1));\par
00270     \}\par
}
}
{\xe \v tickRaw\:VirtEncoder}
{\xe \v VirtEncoder\:tickRaw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int8_t VirtEncoder::tickRaw (int8_t  {\i state}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00279                                  \{\par
00280         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00281             clr_encf(E_ISR_F);\par
00282             set_encf(E_TRN_R);\par
00283             {\cf19 return} dir();\par
00284         \}\par
00285         {\cf19 if} ((state >= 0) && (state = pollEnc(state))) \{\par
00286             write_encf(E_DIR, state > 0);\par
00287             set_encf(E_TRN_R);\par
00288             {\cf19 return} state;\par
00289         \}\par
00290         {\cf19 return} 0;\par
00291     \}\par
}
}
{\xe \v turn\:VirtEncoder}
{\xe \v VirtEncoder\:turn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VirtEncoder::turn (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the encoder has been turned. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the encoder has been turned, false otherwise \par
}}}{
Definition at line {\b 161} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00161                 \{\par
00162         {\cf19 return} read_encf(E_TRN_R);\par
00163     \}\par
}
}
{\xe \v write_encf\:VirtEncoder}
{\xe \v VirtEncoder\:write_encf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VirtEncoder::write_encf (const uint16_t  {\i x}, bool  {\i v}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00353                                                                                     \{\par
00354         {\cf19 if} (v) set_encf(x);\par
00355         {\cf19 else} clr_encf(x);\par
00356     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cb\:VirtEncoder}
{\xe \v VirtEncoder\:cb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cb_t} VirtEncoder::cb[2] = \{nullptr, nullptr\}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 362} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00362 \{{\cf17 nullptr}, {\cf17 nullptr}\}; {\cf20 // callbacks for right and left turns}\par
}
}
{\xe \v counter\:VirtEncoder}
{\xe \v VirtEncoder\:counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t VirtEncoder::counter = 0}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 342} of file {\b VirtEncoder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/core/{\b VirtEncoder.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/core/Button.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/core/Button.h}
{\xe \v src/core/Button.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Button} class for handling button presses and debouncing. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "VirtButton.h"}\par
{\f2 #include "utils.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Button}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a button that extends the {\b VirtButton} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ButtonT< PIN >}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Button} class for handling button presses and debouncing. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Button.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Button.h\par \pard\plain 
{\tc\tcl2 \v src/core/Button.h}
{\xe \v src/core/Button.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00006 {\cf21 #pragma once}\par
00007 {\cf21 #include <Arduino.h>}\par
00008 \par
00009 {\cf21 #include "VirtButton.h"}\par
00010 {\cf21 #include "utils.h"}\par
00011 \par
00012 {\cf20 // ============= VAR PIN =============}\par
00013 \par
00020 {\cf17 class }Button : {\cf17 public} VirtButton \{\par
00021    {\cf17 public}:\par
00027     Button(uint8_t npin);\par
00028 \par
00036     {\cf18 void} init(uint8_t npin = 0, uint8_t mode = INPUT_PULLUP, uint8_t btnLevel = LOW);\par
00037 \par
00046     {\cf18 bool} read();\par
00047 \par
00056     {\cf18 bool} tick();\par
00057 \par
00066     {\cf18 bool} tickRaw();\par
00067 \par
00068    {\cf17 private}:\par
00069     uint8_t pin;\par
00070 \};\par
00071 \par
00072 {\cf20 // ============= TEMPLATE PIN =============}\par
00073 \par
00074 {\cf17 template} <u{\cf18 int}8_t PIN>\par
00075 {\cf17 class }ButtonT : {\cf17 public} VirtButton \{\par
00076    {\cf17 public}:\par
00077     ButtonT(uint8_t mode = INPUT_PULLUP, uint8_t btnLevel = LOW) \{\par
00078         init(mode, btnLevel);\par
00079     \}\par
00080 \par
00081     {\cf18 void} init(uint8_t mode = INPUT_PULLUP, uint8_t btnLevel = LOW) \{\par
00082         pinMode(PIN, mode);\par
00083         setBtnLevel(btnLevel);\par
00084     \}\par
00085 \par
00086     {\cf18 bool} read() \{\par
00087         {\cf19 return} EBread(PIN) ^ read_btn_flag(B_INV);\par
00088     \}\par
00089 \par
00090     {\cf18 bool} tick() \{\par
00091         {\cf19 return} VirtButton::tick(EBread(PIN));\par
00092     \}\par
00093 \par
00094     {\cf18 bool} tickRaw() \{\par
00095         {\cf19 return} VirtButton::tickRaw(EBread(PIN));\par
00096     \}\par
00097 \par
00098    {\cf17 private}:\par
00099 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/core/EncButton.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/core/EncButton.h}
{\xe \v src/core/EncButton.h}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EncButton} class for handling rotary encoder with button. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "VirtEncButton.h"}\par
{\f2 #include "utils.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EncButton}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class that represents an encoder button. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EncButtonT< ENCA, ENCB, BTN >}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EncButton} class for handling rotary encoder with button. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b EncButton.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EncButton.h\par \pard\plain 
{\tc\tcl2 \v src/core/EncButton.h}
{\xe \v src/core/EncButton.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00006 {\cf21 #pragma once}\par
00007 {\cf21 #include <Arduino.h>}\par
00008 \par
00009 {\cf21 #include "VirtEncButton.h"}\par
00010 {\cf21 #include "utils.h"}\par
00011 \par
00012 {\cf20 // ===================== CLASS =====================}\par
00020 {\cf17 class }EncButton : {\cf17 public} VirtEncButton \{\par
00021    {\cf17 public}:\par
00032     EncButton(uint8_t encA = 0, uint8_t encB = 0, uint8_t btn = 0, uint8_t modeEnc = INPUT, uint8_t modeBtn = INPUT_PULLUP, uint8_t btnLevel = LOW) \{\par
00033         init(encA, encB, btn, modeEnc, modeBtn, btnLevel);\par
00034     \}\par
00035 \par
00046     {\cf18 void} init(uint8_t encA = 0, uint8_t encB = 0, uint8_t btn = 0, uint8_t modeEnc = INPUT, uint8_t modeBtn = INPUT_PULLUP, uint8_t btnLevel = LOW) \{\par
00047         e0 = encA;\par
00048         e1 = encB;\par
00049         b = btn;\par
00050         pinMode(e0, modeEnc);\par
00051         pinMode(e1, modeEnc);\par
00052         pinMode(b, modeBtn);\par
00053         setBtnLevel(btnLevel);\par
00054         initEnc(readEnc());\par
00055     \}\par
00056 \par
00057     {\cf20 // ====================== TICK ======================}\par
00058 \par
00064     int8_t tickISR() \{\par
00065         {\cf19 return} VirtEncButton::tickISR(readEnc());\par
00066     \}\par
00067 \par
00073     {\cf18 bool} tick() \{\par
00074         {\cf19 if} (read_encf(E_ISR))\par
00075             {\cf19 return} VirtEncButton::tick(EBread(b));\par
00076         {\cf19 else}\par
00077             {\cf19 return} VirtEncButton::tick(readEnc(), EBread(b));\par
00078     \}\par
00079 \par
00085     {\cf18 bool} tickRaw() \{\par
00086         {\cf19 if} (read_encf(E_ISR))\par
00087             {\cf19 return} VirtEncButton::tickRaw(EBread(b));\par
00088         {\cf19 else}\par
00089             {\cf19 return} VirtEncButton::tickRaw(readEnc(), EBread(b));\par
00090     \}\par
00091 \par
00092     {\cf20 // ====================== READ ======================}\par
00093 \par
00099     {\cf18 bool} readBtn() \{\par
00100         {\cf19 return} EBread(b) ^ read_btn_flag(B_INV);\par
00101     \}\par
00102 \par
00108     int8_t readEnc() \{\par
00109         {\cf19 return} EBread(e0) | (EBread(e1) << 1);\par
00110     \}\par
00111 \par
00112     {\cf20 // ===================== PRIVATE =====================}\par
00113    {\cf17 private}:\par
00114     uint8_t e0, e1, b;\par
00115 \};\par
00116 \par
00117 {\cf20 // ===================== T CLASS =====================}\par
00118 {\cf17 template} <u{\cf18 int}8_t ENCA, u{\cf18 int}8_t ENCB, u{\cf18 int}8_t BTN>\par
00119 {\cf17 class }EncButtonT : {\cf17 public} VirtEncButton \{\par
00120    {\cf17 public}:\par
00121     EncButtonT(uint8_t modeEnc = INPUT, uint8_t modeBtn = INPUT_PULLUP, uint8_t btnLevel = LOW) \{\par
00122         init(modeEnc, modeBtn, btnLevel);\par
00123     \}\par
00124 \par
00125     {\cf18 void} init(uint8_t modeEnc = INPUT, uint8_t modeBtn = INPUT_PULLUP, uint8_t btnLevel = LOW) \{\par
00126         pinMode(ENCA, modeEnc);\par
00127         pinMode(ENCB, modeEnc);\par
00128         pinMode(BTN, modeBtn);\par
00129         setBtnLevel(btnLevel);\par
00130         initEnc(readEnc());\par
00131     \}\par
00132 \par
00133     {\cf20 // ====================== TICK ======================}\par
00134     int8_t tickISR() \{\par
00135         {\cf19 return} VirtEncButton::tickISR(readEnc());\par
00136     \}\par
00137 \par
00138     {\cf18 bool} tick() \{\par
00139         {\cf19 if} (read_encf(E_ISR)) {\cf19 return} VirtEncButton::tick(EBread(BTN));\par
00140         {\cf19 else} {\cf19 return} VirtEncButton::tick(readEnc(), EBread(BTN));\par
00141     \}\par
00142 \par
00143     {\cf18 bool} tickRaw() \{\par
00144         {\cf19 if} (read_encf(E_ISR)) {\cf19 return} VirtEncButton::tickRaw(EBread(BTN));\par
00145         {\cf19 else} {\cf19 return} VirtEncButton::tickRaw(readEnc(), EBread(BTN));\par
00146     \}\par
00147 \par
00148     {\cf20 // ====================== READ ======================}\par
00149     {\cf18 bool} readBtn() \{\par
00150         {\cf19 return} EBread(BTN) ^ read_btn_flag(B_INV);\par
00151     \}\par
00152 \par
00153     int8_t readEnc() \{\par
00154         {\cf19 return} EBread(ENCA) | (EBread(ENCB) << 1);\par
00155     \}\par
00156 \par
00157     {\cf20 // ===================== PRIVATE =====================}\par
00158    {\cf17 private}:\par
00159 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/EncButton.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/EncButton.h}
{\xe \v src/EncButton.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "core/VirtButton.h"}\par
{\f2 #include "core/VirtEncoder.h"}\par
{\f2 #include "core/VirtEncButton.h"}\par
{\f2 #include "core/Button.h"}\par
{\f2 #include "core/Encoder.h"}\par
{\f2 #include "core/EncButton.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EncButton.h\par \pard\plain 
{\tc\tcl2 \v src/EncButton.h}
{\xe \v src/EncButton.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <Arduino.h>}\par
00003 \par
00004 {\cf21 #include "core/VirtButton.h"}\par
00005 {\cf21 #include "core/VirtEncoder.h"}\par
00006 {\cf21 #include "core/VirtEncButton.h"}\par
00007 {\cf21 #include "core/Button.h"}\par
00008 {\cf21 #include "core/Encoder.h"}\par
00009 {\cf21 #include "core/EncButton.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/core/Encoder.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/core/Encoder.h}
{\xe \v src/core/Encoder.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Encoder} class for handling rotary encoder. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "VirtEncoder.h"}\par
{\f2 #include "utils.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Encoder}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Encoder} class represents an encoder device. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EncoderT< ENCA, ENCB >}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Encoder} class for handling rotary encoder. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Encoder.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Encoder.h\par \pard\plain 
{\tc\tcl2 \v src/core/Encoder.h}
{\xe \v src/core/Encoder.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00006 {\cf21 #pragma once}\par
00007 {\cf21 #include <Arduino.h>}\par
00008 \par
00009 {\cf21 #include "VirtEncoder.h"}\par
00010 {\cf21 #include "utils.h"}\par
00011 \par
00017 {\cf17 class }Encoder : {\cf17 public} VirtEncoder \{\par
00018    {\cf17 public}:\par
00026     Encoder(uint8_t encA = 0, uint8_t encB = 0, uint8_t mode = INPUT) \{\par
00027         init(encA, encB, mode);\par
00028     \}\par
00029 \par
00037     {\cf18 void} init(uint8_t encA = 0, uint8_t encB = 0, uint8_t mode = INPUT) \{\par
00038         e0 = encA;\par
00039         e1 = encB;\par
00040         pinMode(e0, mode);\par
00041         pinMode(e1, mode);\par
00042         initEnc(readEnc());\par
00043     \}\par
00044 \par
00050     int8_t tickISR() \{\par
00051         {\cf19 return} VirtEncoder::tickISR(readEnc());\par
00052     \}\par
00053 \par
00061     int8_t tick() \{\par
00062         {\cf19 if} (read_encf(E_ISR))\par
00063             {\cf19 return} VirtEncoder::tick();\par
00064         {\cf19 else}\par
00065             {\cf19 return} VirtEncoder::tick(readEnc());\par
00066     \}\par
00067 \par
00075     int8_t tickRaw() \{\par
00076         {\cf19 if} (read_encf(E_ISR))\par
00077             {\cf19 return} VirtEncoder::tickRaw();\par
00078         {\cf19 else}\par
00079             {\cf19 return} VirtEncoder::tickRaw(readEnc());\par
00080     \}\par
00081 \par
00082    {\cf17 private}:\par
00083     uint8_t e0, e1;\par
00084 \par
00090     int8_t readEnc() \{\par
00091         {\cf19 return} EBread(e0) | (EBread(e1) << 1);\par
00092     \}\par
00093 \};\par
00094 \par
00095 {\cf20 // ============= TEMPLATE PIN =============}\par
00096 {\cf17 template} <u{\cf18 int}8_t ENCA, u{\cf18 int}8_t ENCB>\par
00097 {\cf17 class }EncoderT : {\cf17 public} VirtEncoder \{\par
00098    {\cf17 public}:\par
00099     EncoderT(uint8_t mode = INPUT) \{\par
00100         init(mode);\par
00101     \}\par
00102 \par
00103     {\cf18 void} init(uint8_t mode = INPUT) \{\par
00104         pinMode(ENCA, mode);\par
00105         pinMode(ENCB, mode);\par
00106         initEnc(readEnc());\par
00107     \}\par
00108 \par
00109     int8_t tickISR() \{\par
00110         {\cf19 return} VirtEncoder::tickISR(readEnc());\par
00111     \}\par
00112 \par
00113     int8_t tick() \{\par
00114         {\cf19 if} (read_encf(E_ISR)) {\cf19 return} VirtEncoder::tick();\par
00115         {\cf19 else} {\cf19 return} VirtEncoder::tick(readEnc());\par
00116     \}\par
00117 \par
00118     int8_t tickRaw() \{\par
00119         {\cf19 if} (read_encf(E_ISR)) {\cf19 return} VirtEncoder::tickRaw();\par
00120         {\cf19 else} {\cf19 return} VirtEncoder::tickRaw(readEnc());\par
00121     \}\par
00122 \par
00123     int8_t readEnc() \{\par
00124         {\cf19 return} EBread(ENCA) | (EBread(ENCB) << 1);\par
00125     \}\par
00126 \par
00127    {\cf17 private}:\par
00128 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/core/utils.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/core/utils.cpp}
{\xe \v src/core/utils.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "utils.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b EBread} (const uint8_t pin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EBwrite} (const uint8_t pin, bool value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EBread\:utils.cpp}
{\xe \v utils.cpp\:EBread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EBread (const uint8_t  {\i pin})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b utils.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00003                               \{\par
00004 {\cf21 #if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)}\par
00005     {\cf19 if} (pin < 8)\par
00006         {\cf19 return} bitRead(PIND, pin);\par
00007     {\cf19 else} {\cf19 if} (pin < 14)\par
00008         {\cf19 return} bitRead(PINB, pin - 8);\par
00009     {\cf19 else} {\cf19 if} (pin < 20)\par
00010         {\cf19 return} bitRead(PINC, pin - 14);\par
00011 {\cf21 #elif defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny13__)}\par
00012     {\cf19 return} bitRead(PINB, pin);\par
00013 {\cf21 #elif defined(__AVR_ATmega2560__)}\par
00014     {\cf19 if} (pin < 8)\par
00015       {\cf19 return} bitRead(PIND, pin);\par
00016     {\cf19 else} {\cf19 if} (pin < 14)\par
00017       {\cf19 return} bitRead(PINE, pin - 8);\par
00018     {\cf19 else} {\cf19 if} (pin < 22)\par
00019       {\cf19 return} bitRead(PING, pin - 14);\par
00020     {\cf19 else} {\cf19 if} (pin < 30)\par
00021       {\cf19 return} bitRead(PINH, pin - 22);\par
00022     {\cf19 else} {\cf19 if} (pin < 38)\par
00023       {\cf19 return} bitRead(PINJ, pin - 30);\par
00024     {\cf19 else} {\cf19 if} (pin < 46)\par
00025       {\cf19 return} bitRead(PINK, pin - 38);\par
00026     {\cf19 else} {\cf19 if} (pin < 54)\par
00027       {\cf19 return} bitRead(PINL, pin - 46);\par
00028 {\cf21 #else}\par
00029     {\cf19 return} digitalRead(pin);\par
00030 {\cf21 #endif}\par
00031     {\cf19 return} 0;\par
00032 \}\par
}
}
{\xe \v EBwrite\:utils.cpp}
{\xe \v utils.cpp\:EBwrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EBwrite (const uint8_t  {\i pin}, bool  {\i value})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b utils.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00034                                            \{\par
00035 {\cf21 #if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)}\par
00036     {\cf19 if} (pin < 8)\par
00037         bitWrite(PORTD, pin, value);\par
00038     {\cf19 else} {\cf19 if} (pin < 14)\par
00039         bitWrite(PORTB, pin - 8, value);\par
00040     {\cf19 else} {\cf19 if} (pin < 20)\par
00041         bitWrite(PORTC, pin - 14, value);\par
00042 {\cf21 #elif defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny13__)}\par
00043     bitWrite(PORTB, pin, value);\par
00044 {\cf21 #elif defined(__AVR_ATmega2560__)}\par
00045     {\cf19 if} (pin < 8)\par
00046         bitWrite(PORTD, pin, value);\par
00047     {\cf19 else} {\cf19 if} (pin < 14)\par
00048         bitWrite(PORTE, pin - 8, value);\par
00049     {\cf19 else} {\cf19 if} (pin < 22)\par
00050         bitWrite(PORTG, pin - 14, value);\par
00051     {\cf19 else} {\cf19 if} (pin < 30)\par
00052         bitWrite(PORTH, pin - 22, value);\par
00053     {\cf19 else} {\cf19 if} (pin < 38)\par
00054         bitWrite(PORTJ, pin - 30, value);\par
00055     {\cf19 else} {\cf19 if} (pin < 46)\par
00056         bitWrite(PORTK, pin - 38, value);\par
00057     {\cf19 else} {\cf19 if} (pin < 54)\par
00058         bitWrite(PORTL, pin - 46, value);\par
00059 {\cf21 #else}\par
00060     digitalWrite(pin, value);\par
00061 {\cf21 #endif}\par
00062 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utils.cpp\par \pard\plain 
{\tc\tcl2 \v src/core/utils.cpp}
{\xe \v src/core/utils.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "utils.h"}\par
00002 \par
00003 {\cf18 bool} EBread({\cf17 const} uint8_t pin)\{\par
00004 {\cf21 #if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)}\par
00005     {\cf19 if} (pin < 8)\par
00006         {\cf19 return} bitRead(PIND, pin);\par
00007     {\cf19 else} {\cf19 if} (pin < 14)\par
00008         {\cf19 return} bitRead(PINB, pin - 8);\par
00009     {\cf19 else} {\cf19 if} (pin < 20)\par
00010         {\cf19 return} bitRead(PINC, pin - 14);\par
00011 {\cf21 #elif defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny13__)}\par
00012     {\cf19 return} bitRead(PINB, pin);\par
00013 {\cf21 #elif defined(__AVR_ATmega2560__)}\par
00014     {\cf19 if} (pin < 8)\par
00015       {\cf19 return} bitRead(PIND, pin);\par
00016     {\cf19 else} {\cf19 if} (pin < 14)\par
00017       {\cf19 return} bitRead(PINE, pin - 8);\par
00018     {\cf19 else} {\cf19 if} (pin < 22)\par
00019       {\cf19 return} bitRead(PING, pin - 14);\par
00020     {\cf19 else} {\cf19 if} (pin < 30)\par
00021       {\cf19 return} bitRead(PINH, pin - 22);\par
00022     {\cf19 else} {\cf19 if} (pin < 38)\par
00023       {\cf19 return} bitRead(PINJ, pin - 30);\par
00024     {\cf19 else} {\cf19 if} (pin < 46)\par
00025       {\cf19 return} bitRead(PINK, pin - 38);\par
00026     {\cf19 else} {\cf19 if} (pin < 54)\par
00027       {\cf19 return} bitRead(PINL, pin - 46);\par
00028 {\cf21 #else}\par
00029     {\cf19 return} digitalRead(pin);\par
00030 {\cf21 #endif}\par
00031     {\cf19 return} 0;\par
00032 \}\par
00033 \par
00034 {\cf18 void} EBwrite({\cf17 const} uint8_t pin, {\cf18 bool} value)\{\par
00035 {\cf21 #if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)}\par
00036     {\cf19 if} (pin < 8)\par
00037         bitWrite(PORTD, pin, value);\par
00038     {\cf19 else} {\cf19 if} (pin < 14)\par
00039         bitWrite(PORTB, pin - 8, value);\par
00040     {\cf19 else} {\cf19 if} (pin < 20)\par
00041         bitWrite(PORTC, pin - 14, value);\par
00042 {\cf21 #elif defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny13__)}\par
00043     bitWrite(PORTB, pin, value);\par
00044 {\cf21 #elif defined(__AVR_ATmega2560__)}\par
00045     {\cf19 if} (pin < 8)\par
00046         bitWrite(PORTD, pin, value);\par
00047     {\cf19 else} {\cf19 if} (pin < 14)\par
00048         bitWrite(PORTE, pin - 8, value);\par
00049     {\cf19 else} {\cf19 if} (pin < 22)\par
00050         bitWrite(PORTG, pin - 14, value);\par
00051     {\cf19 else} {\cf19 if} (pin < 30)\par
00052         bitWrite(PORTH, pin - 22, value);\par
00053     {\cf19 else} {\cf19 if} (pin < 38)\par
00054         bitWrite(PORTJ, pin - 30, value);\par
00055     {\cf19 else} {\cf19 if} (pin < 46)\par
00056         bitWrite(PORTK, pin - 38, value);\par
00057     {\cf19 else} {\cf19 if} (pin < 54)\par
00058         bitWrite(PORTL, pin - 46, value);\par
00059 {\cf21 #else}\par
00060     digitalWrite(pin, value);\par
00061 {\cf21 #endif}\par
00062 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/core/utils.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/core/utils.h}
{\xe \v src/core/utils.h}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utility functions for handling pins and flags. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EB_FLAGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b X}(a,  b)\~ a = (1 << b),\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EB_UPTIME}()\~ millis()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b cb_t}) ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b EB_FLAGS_T} \{ {\b EB_FLAGS}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b EBread} (const uint8_t pin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EBwrite} (const uint8_t pin, bool value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utility functions for handling pins and flags. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b utils.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v EB_FLAGS\:utils.h}
{\xe \v utils.h\:EB_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EB_FLAGS}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     X(EB_NONE         , 0)\\\par
    X(EB_PRESS        , 1)\\\par
    X(EB_STEP         , 2)\\\par
    X(EB_HOLD         , 3)\\\par
    X(EB_RELEASE      , 4)\\\par
    X(EB_CLICK        , 5)\\\par
    X(EB_CLICKS       , 6)\\\par
    X(EB_REL_HOLD     , 7)\\\par
    X(EB_REL_HOLD_C   , 8)\\\par
    X(EB_REL_STEP     , 9)\\\par
    X(EB_REL_STEP_C   , 10)\\\par
    X(EB_TURN         , 11)\\\par
    X(EB_TURN_R       , 12)\\\par
    X(EB_TURN_L       , 13)\\\par
    X(EB_TURN_HOLD_R  , 14)\\\par
    X(EB_TURN_HOLD_L  , 15)\par
}
{
Definition at line {\b 12} of file {\b utils.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032              \{\par
00033     EB_FLAGS\par
00034 \} EB_FLAGS_T;\par
00035 {\cf21 #undef X}\par
00036 \par
00037 {\cf21 #define EB_UPTIME() millis()}\par
00038 \par
00039 {\cf17 typedef} void (*cb_t)();\par
00040 \par
00041 {\cf18 bool} EBread({\cf17 const} uint8_t pin);\par
00042 {\cf18 void} EBwrite({\cf17 const} uint8_t pin, {\cf18 bool} value);\par
}
}
{\xe \v EB_UPTIME\:utils.h}
{\xe \v utils.h\:EB_UPTIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EB_UPTIME()\~ millis()}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b utils.h}.}\par
}
{\xe \v X\:utils.h}
{\xe \v utils.h\:X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define X( a,  b)\~ a = (1 << b),}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b utils.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v cb_t\:utils.h}
{\xe \v utils.h\:cb_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* cb_t) ()}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b utils.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v EB_FLAGS_T\:utils.h}
{\xe \v utils.h\:EB_FLAGS_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b EB_FLAGS_T}}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v EB_FLAGS\:utils.h}
{\xe \v utils.h\:EB_FLAGS}
{\qr EB_FLAGS{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 32} of file {\b utils.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032              \{\par
00033     EB_FLAGS\par
00034 \} EB_FLAGS_T;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v EBread\:utils.h}
{\xe \v utils.h\:EBread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EBread (const uint8_t  {\i pin})}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b utils.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00003                               \{\par
00004 {\cf21 #if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)}\par
00005     {\cf19 if} (pin < 8)\par
00006         {\cf19 return} bitRead(PIND, pin);\par
00007     {\cf19 else} {\cf19 if} (pin < 14)\par
00008         {\cf19 return} bitRead(PINB, pin - 8);\par
00009     {\cf19 else} {\cf19 if} (pin < 20)\par
00010         {\cf19 return} bitRead(PINC, pin - 14);\par
00011 {\cf21 #elif defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny13__)}\par
00012     {\cf19 return} bitRead(PINB, pin);\par
00013 {\cf21 #elif defined(__AVR_ATmega2560__)}\par
00014     {\cf19 if} (pin < 8)\par
00015       {\cf19 return} bitRead(PIND, pin);\par
00016     {\cf19 else} {\cf19 if} (pin < 14)\par
00017       {\cf19 return} bitRead(PINE, pin - 8);\par
00018     {\cf19 else} {\cf19 if} (pin < 22)\par
00019       {\cf19 return} bitRead(PING, pin - 14);\par
00020     {\cf19 else} {\cf19 if} (pin < 30)\par
00021       {\cf19 return} bitRead(PINH, pin - 22);\par
00022     {\cf19 else} {\cf19 if} (pin < 38)\par
00023       {\cf19 return} bitRead(PINJ, pin - 30);\par
00024     {\cf19 else} {\cf19 if} (pin < 46)\par
00025       {\cf19 return} bitRead(PINK, pin - 38);\par
00026     {\cf19 else} {\cf19 if} (pin < 54)\par
00027       {\cf19 return} bitRead(PINL, pin - 46);\par
00028 {\cf21 #else}\par
00029     {\cf19 return} digitalRead(pin);\par
00030 {\cf21 #endif}\par
00031     {\cf19 return} 0;\par
00032 \}\par
}
}
{\xe \v EBwrite\:utils.h}
{\xe \v utils.h\:EBwrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EBwrite (const uint8_t  {\i pin}, bool  {\i value})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b utils.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00034                                            \{\par
00035 {\cf21 #if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)}\par
00036     {\cf19 if} (pin < 8)\par
00037         bitWrite(PORTD, pin, value);\par
00038     {\cf19 else} {\cf19 if} (pin < 14)\par
00039         bitWrite(PORTB, pin - 8, value);\par
00040     {\cf19 else} {\cf19 if} (pin < 20)\par
00041         bitWrite(PORTC, pin - 14, value);\par
00042 {\cf21 #elif defined(__AVR_ATtiny85__) || defined(__AVR_ATtiny13__)}\par
00043     bitWrite(PORTB, pin, value);\par
00044 {\cf21 #elif defined(__AVR_ATmega2560__)}\par
00045     {\cf19 if} (pin < 8)\par
00046         bitWrite(PORTD, pin, value);\par
00047     {\cf19 else} {\cf19 if} (pin < 14)\par
00048         bitWrite(PORTE, pin - 8, value);\par
00049     {\cf19 else} {\cf19 if} (pin < 22)\par
00050         bitWrite(PORTG, pin - 14, value);\par
00051     {\cf19 else} {\cf19 if} (pin < 30)\par
00052         bitWrite(PORTH, pin - 22, value);\par
00053     {\cf19 else} {\cf19 if} (pin < 38)\par
00054         bitWrite(PORTJ, pin - 30, value);\par
00055     {\cf19 else} {\cf19 if} (pin < 46)\par
00056         bitWrite(PORTK, pin - 38, value);\par
00057     {\cf19 else} {\cf19 if} (pin < 54)\par
00058         bitWrite(PORTL, pin - 46, value);\par
00059 {\cf21 #else}\par
00060     digitalWrite(pin, value);\par
00061 {\cf21 #endif}\par
00062 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utils.h\par \pard\plain 
{\tc\tcl2 \v src/core/utils.h}
{\xe \v src/core/utils.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00006 {\cf21 #pragma once}\par
00007 \par
00008 {\cf21 #include <Arduino.h>}\par
00009 \par
00010 {\cf20 // ===================== FLAGS ======================}\par
00011 {\cf20 //EB_NONE for error catching and Encoder with button handling}\par
00012 {\cf21 #define EB_FLAGS \\}\par
00013 {\cf21     X(EB_NONE         , 0)\\}\par
00014 {\cf21     X(EB_PRESS        , 1)\\}\par
00015 {\cf21     X(EB_STEP         , 2)\\}\par
00016 {\cf21     X(EB_HOLD         , 3)\\}\par
00017 {\cf21     X(EB_RELEASE      , 4)\\}\par
00018 {\cf21     X(EB_CLICK        , 5)\\}\par
00019 {\cf21     X(EB_CLICKS       , 6)\\}\par
00020 {\cf21     X(EB_REL_HOLD     , 7)\\}\par
00021 {\cf21     X(EB_REL_HOLD_C   , 8)\\}\par
00022 {\cf21     X(EB_REL_STEP     , 9)\\}\par
00023 {\cf21     X(EB_REL_STEP_C   , 10)\\}\par
00024 {\cf21     X(EB_TURN         , 11)\\}\par
00025 {\cf21     X(EB_TURN_R       , 12)\\}\par
00026 {\cf21     X(EB_TURN_L       , 13)\\}\par
00027 {\cf21     X(EB_TURN_HOLD_R  , 14)\\}\par
00028 {\cf21     X(EB_TURN_HOLD_L  , 15)}\par
00029 \par
00030 {\cf20 //TURN_H_HANDLER    }\par
00031 {\cf21 #define X(a, b) a = (1 << b),}\par
00032 {\cf17 typedef} {\cf17 enum} \{\par
00033     EB_FLAGS\par
00034 \} EB_FLAGS_T;\par
00035 {\cf21 #undef X}\par
00036 \par
00037 {\cf21 #define EB_UPTIME() millis()}\par
00038 \par
00039 {\cf17 typedef} void (*cb_t)();\par
00040 \par
00041 {\cf18 bool} EBread({\cf17 const} uint8_t pin);\par
00042 {\cf18 void} EBwrite({\cf17 const} uint8_t pin, {\cf18 bool} value);\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/core/VirtButton.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/core/VirtButton.h}
{\xe \v src/core/VirtButton.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VirtButton} class for handling virtual buttons. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "utils.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VirtButton}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EB_SHIFT}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EB_FOR_SCALE}\~ 6\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BUTTON_FLAGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b X}(a,  b)\~ a = (1 << b),\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BUTTON_FLAG_T} \{ {\b BUTTON_FLAGS}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VirtButton} class for handling virtual buttons. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BUTTON_FLAGS\:VirtButton.h}
{\xe \v VirtButton.h\:BUTTON_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BUTTON_FLAGS}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     X(B_CLKS_R, 0)\\\par
    X(B_PRS_R,  1)\\\par
    X(B_HLD_R,  2)\\\par
    X(B_STP_R,  3)\\\par
    X(B_REL_R,  4)\\\par
    X(B_PRS,    5)\\\par
    X(B_HLD,    6)\\\par
    X(B_STP,    7)\\\par
    X(B_REL,    8)\\\par
    X(B_BUSY,   9)\\\par
    X(B_DEB,    10)\\\par
    X(B_TOUT,   11)\\\par
    X(B_INV,    12)\\\par
    X(B_BOTH,   13)\\\par
    X(B_BISR,   14)\\\par
    X(B_EHLD,   15)\par
}
{
Definition at line {\b 31} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00050              \{\par
00051     BUTTON_FLAGS\par
00052 \} BUTTON_FLAG_T;\par
00053 {\cf21 #undef X}\par
00054 \par
00055 \par
00056 {\cf17 class }VirtButton \{\par
00057    {\cf17 public}:\par
00058     {\cf20 // ====================== SET ======================}\par
00059 \par
00060     {\cf18 void} init()\{\par
00061         setHoldTimeout();\par
00062         setStepTimeout();\par
00063         setClickTimeout();\par
00064         setDebounceTimeout();\par
00065 \par
00066     \}\par
00067 \par
00074     {\cf18 void} setHoldTimeout(uint16_t timeout=600) \{\par
00075 {\cf21 #ifndef EB_HOLD_TIME}\par
00076         EB_HOLD_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00077 {\cf21 #endif}\par
00078     \}\par
00079 \par
00085     {\cf18 void} setStepTimeout(uint16_t timeout=200) \{\par
00086 {\cf21 #ifndef EB_STEP_TIME}\par
00087         EB_STEP_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00088 {\cf21 #endif}\par
00089     \}\par
00090 \par
00096     {\cf18 void} setClickTimeout(uint16_t timeout=500) \{\par
00097 {\cf21 #ifndef EB_CLICK_TIME}\par
00098         EB_CLICK_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00099 {\cf21 #endif}\par
00100     \}\par
00101 \par
00102     {\cf18 void} setDebounceTimeout(uint8_t timeout=50) \{\par
00103 {\cf21 #ifndef EB_DEB_TIME}\par
00104         EB_DEB_T = (timeout < 255) ? timeout : 255;\par
00105 {\cf21 #endif}\par
00106     \}\par
00107 \par
00108     {\cf18 void} setBtnLevel({\cf18 bool} level) \{\par
00109         write_btn_flag(B_INV, !level);\par
00110     \}\par
00111 \par
00112     {\cf18 void} pressISR() \{\par
00113         {\cf19 if} (!read_btn_flag(B_DEB)) timer = EB_UPTIME();\par
00114         set_btn_flag(B_DEB | B_BISR);\par
00115     \}\par
00116 \par
00117     {\cf18 void} reset() \{\par
00118         clicks = 0;\par
00119         clr_btn_flag(~B_INV);\par
00120     \}\par
00121 \par
00122     {\cf18 void} clear() \{\par
00123         {\cf19 if} (read_btn_flag(B_CLKS_R)) clicks = 0;\par
00124         {\cf19 if} (read_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R)) \{\par
00125             clr_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R);\par
00126         \}\par
00127     \}\par
00128 \par
00129 \par
00137     {\cf18 bool} attach_call( cb_t callback_func) \{ \par
00138 {\cf21 #ifndef EB_NO_CALLBACK}\par
00139         {\cf19 if} (callback_func == {\cf17 nullptr} || cb) {\cf19 return} {\cf17 false};\par
00140         cb = *callback_func;\par
00141         {\cf19 return} {\cf17 true};\par
00142 {\cf21 #endif}\par
00143         {\cf19 return} {\cf17 false};\par
00144     \}\par
00145 \par
00146     {\cf20 //todo check variant with one name on 2 virtual functions}\par
00147     {\cf18 void} detach_call() \{\par
00148 {\cf21 #ifndef EB_NO_CALLBACK}\par
00149         cb = {\cf17 nullptr};\par
00150 {\cf21 #endif}\par
00151     \}\par
00152 \par
00153     {\cf20 // ====================== GET ======================}\par
00154     {\cf18 bool} press() \{\par
00155         {\cf19 return} read_btn_flag(B_PRS_R);\par
00156     \}\par
00157 \par
00158     {\cf18 bool} release() \{\par
00159         {\cf19 return} eq_btn_flag(B_REL_R | B_REL, B_REL_R | B_REL);\par
00160     \}\par
00161 \par
00162     {\cf18 bool} click() \{\par
00163         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD, B_REL_R);\par
00164     \}\par
00165 \par
00166     {\cf18 bool} pressing() \{\par
00167         {\cf19 return} read_btn_flag(B_PRS);\par
00168     \}\par
00169 \par
00170     {\cf18 bool} hold() \{\par
00171         {\cf19 return} read_btn_flag(B_HLD_R);\par
00172     \}\par
00173 \par
00174     {\cf18 bool} hold(uint8_t num) \{\par
00175         {\cf19 return} clicks == num && hold();\par
00176     \}\par
00177 \par
00178     {\cf18 bool} holding() \{\par
00179         {\cf19 return} eq_btn_flag(B_PRS | B_HLD, B_PRS | B_HLD);\par
00180     \}\par
00181 \par
00182     {\cf18 bool} holding(uint8_t num) \{\par
00183         {\cf19 return} clicks == num && holding();\par
00184     \}\par
00185 \par
00186     {\cf18 bool} step() \{\par
00187         {\cf19 return} read_btn_flag(B_STP_R);\par
00188     \}\par
00189 \par
00190     {\cf18 bool} step(uint8_t num) \{\par
00191         {\cf19 return} clicks == num && step();\par
00192     \}\par
00193 \par
00194     {\cf18 bool} hasClicks() \{\par
00195         {\cf19 return} eq_btn_flag(B_CLKS_R | B_HLD, B_CLKS_R);\par
00196     \}\par
00197 \par
00198     {\cf18 bool} hasClicks(uint8_t num) \{\par
00199         {\cf19 return} clicks == num && hasClicks();\par
00200     \}\par
00201 \par
00202     uint8_t getClicks() \{\par
00203         {\cf19 return} clicks;\par
00204     \}\par
00205 \par
00206     uint16_t getSteps() \{\par
00207 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00208 {\cf21 #ifdef EB_STEP_TIME}\par
00209         {\cf19 return} run_timer ? ((stepFor() + EB_STEP_T - 1) / EB_STEP_T) : 0;  \par
00210 {\cf21 #else}\par
00211         {\cf19 return} run_timer ? ((stepFor() + (EB_STEP_T << EB_SHIFT) - 1) / (EB_STEP_T << EB_SHIFT)) : 0;\par
00212 {\cf21 #endif}\par
00213 {\cf21 #endif}\par
00214         {\cf19 return} 0;\par
00215     \}\par
00216 \par
00217     {\cf18 bool} releaseHold() \{\par
00218         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD | B_STP, B_REL_R | B_HLD);\par
00219     \}\par
00220 \par
00221     {\cf18 bool} releaseHold(uint8_t num) \{\par
00222         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_HLD | B_STP, B_CLKS_R | B_HLD);\par
00223     \}\par
00224 \par
00225     {\cf18 bool} releaseStep() \{\par
00226         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_STP, B_REL_R | B_STP);\par
00227     \}\par
00228 \par
00229     {\cf18 bool} releaseStep(uint8_t num) \{\par
00230         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_STP, B_CLKS_R | B_STP);\par
00231     \}\par
00232 \par
00233     {\cf18 bool} waiting() \{\par
00234         {\cf19 return} clicks && eq_btn_flag(B_PRS | B_REL, 0);\par
00235     \}\par
00236 \par
00237     {\cf18 bool} busy() \{\par
00238         {\cf19 return} read_btn_flag(B_BUSY);\par
00239     \}\par
00240 \par
00246     EB_FLAGS_T action() \{\par
00247         {\cf19 switch} (flags & 0b111111111) \{\par
00248             {\cf19 case} (B_PRS | B_PRS_R):\par
00249                 {\cf19 return} EB_PRESS;\par
00250             {\cf19 case} (B_PRS | B_HLD | B_HLD_R):\par
00251                 {\cf19 return} EB_HOLD;\par
00252             {\cf19 case} (B_PRS | B_HLD | B_STP | B_STP_R):\par
00253                 {\cf19 return} EB_STEP;\par
00254             {\cf19 case} (B_REL | B_REL_R):\par
00255             {\cf19 case} (B_REL | B_REL_R | B_HLD):\par
00256             {\cf19 case} (B_REL | B_REL_R | B_HLD | B_STP):\par
00257                 {\cf19 return} EB_RELEASE;\par
00258             {\cf19 case} (B_REL_R):\par
00259                 {\cf19 return} EB_CLICK;\par
00260             {\cf19 case} (B_CLKS_R):\par
00261                 {\cf19 return} EB_CLICKS;\par
00262             {\cf19 case} (B_REL_R | B_HLD):\par
00263                 {\cf19 return} EB_REL_HOLD;\par
00264             {\cf19 case} (B_CLKS_R | B_HLD):\par
00265                 {\cf19 return} EB_REL_HOLD_C;\par
00266             {\cf19 case} (B_REL_R | B_HLD | B_STP):\par
00267                 {\cf19 return} EB_REL_STEP;\par
00268             {\cf19 case} (B_CLKS_R | B_HLD | B_STP):\par
00269                 {\cf19 return} EB_REL_STEP_C;\par
00270             {\cf19 default}:\par
00271                 {\cf19 return} EB_NONE;\par
00272         \}\par
00273     \}\par
00274 \par
00275     {\cf20 // ====================== TIME ======================}\par
00282     {\cf18 bool} timeout(uint16_t tout) \{\par
00283         {\cf19 if} (read_btn_flag(B_TOUT) && (uint16_t)((uint16_t)EB_UPTIME() - timer) > tout) \{\par
00284             clr_btn_flag(B_TOUT);\par
00285             {\cf19 return} 1;\par
00286         \}\par
00287         {\cf19 return} 0;\par
00288     \}\par
00289 \par
00297     uint16_t pressFor() \{\par
00298 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00299         {\cf19 if} (run_timer) {\cf19 return} (uint16_t)EB_UPTIME() - run_timer;\par
00300 {\cf21 #endif}\par
00301         {\cf19 return} 0;\par
00302     \}\par
00303 \par
00304     {\cf18 bool} pressFor(uint16_t ms) \{\par
00305         {\cf19 return} pressFor() > ms;\par
00306     \}\par
00307 \par
00313     uint16_t holdFor() \{\par
00314 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00315         {\cf19 if} (read_btn_flag(B_HLD)) \{\par
00316 {\cf21 #ifdef EB_HOLD_TIME}\par
00317             {\cf19 return} pressFor() - EB_HOLD_T;\par
00318 {\cf21 #else}\par
00319             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT);\par
00320 {\cf21 #endif}\par
00321         \}\par
00322 {\cf21 #endif}\par
00323         {\cf19 return} 0;\par
00324     \}\par
00325 \par
00332     {\cf18 bool} holdFor(uint16_t ms) \{\par
00333         {\cf19 return} holdFor() > ms;\par
00334     \}\par
00335 \par
00336     uint16_t stepFor() \{\par
00337 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00338         {\cf19 if} (read_btn_flag(B_STP)) \{\par
00339 {\cf21 #ifdef EB_HOLD_TIME}\par
00340             {\cf19 return} pressFor() - EB_HOLD_T * 2;\par
00341 {\cf21 #else}\par
00342             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT) * 2;\par
00343 {\cf21 #endif}\par
00344         \}\par
00345 {\cf21 #endif}\par
00346         {\cf19 return} 0;\par
00347     \}\par
00348 \par
00349     {\cf18 bool} stepFor(uint16_t ms) \{\par
00350         {\cf19 return} stepFor() > ms;\par
00351     \}\par
00352 \par
00353     {\cf20 // ====================== POLL ======================}\par
00354     {\cf18 bool} tick(VirtButton& b0, VirtButton& b1) \{\par
00355         {\cf19 if} (read_btn_flag(B_BOTH)) \{\par
00356             {\cf19 if} (!b0.pressing() && !b1.pressing()) clr_btn_flag(B_BOTH);\par
00357             {\cf19 if} (!b0.pressing()) b0.reset();\par
00358             {\cf19 if} (!b1.pressing()) b1.reset();\par
00359             b0.clear();\par
00360             b1.clear();\par
00361             {\cf19 return} tick(1);\par
00362         \} {\cf19 else} \{\par
00363             {\cf19 if} (b0.pressing() && b1.pressing()) set_btn_flag(B_BOTH);\par
00364             {\cf19 return} tick(0);\par
00365         \}\par
00366     \}\par
00367 \par
00368     {\cf18 bool} tick({\cf18 bool} state) \{\par
00369         clear();\par
00370         state = pollBtn(state);\par
00371 {\cf21 #ifndef EB_NO_CALLBACK}\par
00372         {\cf19 if} (cb && state) cb();\par
00373 {\cf21 #endif}\par
00374         {\cf19 return} state;\par
00375     \}\par
00376 \par
00377 \par
00378     {\cf18 bool} tickRaw({\cf18 bool} state) \{\par
00379         {\cf19 return} pollBtn(state);\par
00380     \}\par
00381 \par
00382     uint8_t clicks;\par
00383 \par
00384     {\cf20 // deprecated}\par
00385     {\cf18 void} setButtonLevel({\cf18 bool} level) \{\par
00386         write_btn_flag(B_INV, !level);\par
00387     \}\par
00388 \par
00389     {\cf20 // ====================== PRIVATE ======================}\par
00390    {\cf17 protected}:\par
00391     {\cf18 bool} pollBtn({\cf18 bool} s) \{\par
00392         {\cf19 if} (read_btn_flag(B_BISR)) \{\par
00393             clr_btn_flag(B_BISR);\par
00394             s = 1;\par
00395         \} {\cf19 else} s ^= read_btn_flag(B_INV);\par
00396 \par
00397         {\cf19 if} (!read_btn_flag(B_BUSY)) \{\par
00398             {\cf19 if} (s) set_btn_flag(B_BUSY);\par
00399             {\cf19 else} {\cf19 return} 0;\par
00400         \}\par
00401 \par
00402         uint16_t ms = EB_UPTIME();\par
00403         uint16_t deb = ms - timer;\par
00404 \par
00405         {\cf19 if} (s) \{                                      \par
00406             {\cf19 if} (!read_btn_flag(B_PRS)) \{                  \par
00407                 {\cf19 if} (!read_btn_flag(B_DEB) && EB_DEB_T) \{  \par
00408                     set_btn_flag(B_DEB);                   \par
00409                     timer = ms;                         \par
00410                 \} {\cf19 else} \{                                \par
00411                     {\cf19 if} (deb >= EB_DEB_T || !EB_DEB_T) \{ \par
00412                         set_btn_flag(B_PRS | B_PRS_R);      \par
00413 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00414                         run_timer = ms;\par
00415 {\cf21 #endif}\par
00416                         timer = ms;  \par
00417                     \}\par
00418                 \}\par
00419             \} {\cf19 else} \{  \par
00420                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00421                     {\cf19 if} (!read_btn_flag(B_HLD)) \{  \par
00422 {\cf21 #ifdef EB_HOLD_TIME}\par
00423                         {\cf19 if} (deb >= (uint16_t)EB_HOLD_T) \{  \par
00424 {\cf21 #else}\par
00425                         {\cf19 if} (deb >= (uint16_t)(EB_HOLD_T << EB_SHIFT)) \{  \par
00426 {\cf21 #endif}\par
00427                             set_btn_flag(B_HLD_R | B_HLD); \par
00428                             timer = ms;                 \par
00429                         \}\par
00430                     \} {\cf19 else} \{  \par
00431 {\cf21 #ifdef EB_STEP_TIME}\par
00432                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? EB_STEP_T : EB_HOLD_T)) \{\par
00433 {\cf21 #else}\par
00434                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? (EB_STEP_T << EB_SHIFT) : (EB_HOLD_T << EB_SHIFT))) \{\par
00435 {\cf21 #endif}\par
00436                             set_btn_flag(B_STP | B_STP_R);  \par
00437                             timer = ms;                   \par
00438                         \}\par
00439                     \}\par
00440                 \}\par
00441             \}\par
00442         \} {\cf19 else} \{                                     \par
00443             {\cf19 if} (read_btn_flag(B_PRS)) \{                 \par
00444                 {\cf19 if} (deb >= EB_DEB_T) \{               \par
00445                     {\cf19 if} (!read_btn_flag(B_HLD)) clicks++;    \par
00446                     {\cf19 if} (read_btn_flag(B_EHLD)) clicks = 0;  \par
00447                     set_btn_flag(B_REL | B_REL_R);        \par
00448                     clr_btn_flag(B_PRS);                   \par
00449                 \}\par
00450             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_REL)) \{\par
00451                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00452                     set_btn_flag(B_REL_R);\par
00453                 \}\par
00454                 clr_btn_flag(B_REL | B_EHLD);\par
00455                 timer = ms;       \par
00456             \} {\cf19 else} {\cf19 if} (clicks) \{  \par
00457 {\cf21 #ifdef EB_CLICK_TIME}\par
00458                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)EB_CLICK_T) set_btn_flag(B_CLKS_R);  \par
00459 {\cf21 #else}\par
00460                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)(EB_CLICK_T << EB_SHIFT)) set_btn_flag(B_CLKS_R);  \par
00461 {\cf21 #endif}\par
00462 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00463                 {\cf19 else} {\cf19 if} (run_timer) run_timer = 0;\par
00464 {\cf21 #endif}\par
00465             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_BUSY)) \{\par
00466                 clr_btn_flag(B_HLD | B_STP | B_BUSY);\par
00467                 set_btn_flag(B_TOUT);\par
00468 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00469                 run_timer = 0;\par
00470 {\cf21 #endif}\par
00471                 timer = ms;  {\cf20 // test!!}\par
00472             \}\par
00473             {\cf19 if} (read_btn_flag(B_DEB)) clr_btn_flag(B_DEB);  \par
00474         \}\par
00475         {\cf19 return} read_btn_flag(B_CLKS_R | B_PRS_R | B_HLD_R | B_STP_R | B_REL_R);\par
00476     \}\par
00477 \par
00478     uint16_t timer = 0;\par
00479 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00480     uint16_t run_timer = 0;\par
00481 {\cf21 #endif}\par
00482 \par
00483 {\cf21 #ifndef EB_NO_CALLBACK}\par
00484     cb_t cb = {\cf17 nullptr};\par
00485 {\cf21 #endif}\par
00486 \par
00487 {\cf21 #ifndef EB_DEB_TIME}\par
00488     uint8_t EB_DEB_T = 50;\par
00489 {\cf21 #endif}\par
00490 {\cf21 #ifndef EB_CLICK_TIME}\par
00491     uint8_t EB_CLICK_T = (500 >> EB_SHIFT);\par
00492 {\cf21 #endif}\par
00493 {\cf21 #ifndef EB_HOLD_TIME}\par
00494     uint8_t EB_HOLD_T = (600 >> EB_SHIFT);\par
00495 {\cf21 #endif}\par
00496 {\cf21 #ifndef EB_STEP_TIME}\par
00497     uint8_t EB_STEP_T = (200 >> EB_SHIFT);\par
00498 {\cf21 #endif}\par
00499 \par
00500     {\cf17 inline} {\cf18 void} set_btn_flag({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00501         flags |= x;\par
00502     \}\par
00503     {\cf17 inline} {\cf18 void} clr_btn_flag({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00504         flags &= ~x;\par
00505     \}\par
00506     {\cf17 inline} {\cf18 bool} read_btn_flag({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00507         {\cf19 return} flags & x;\par
00508     \}\par
00509     {\cf17 inline} {\cf18 void} write_btn_flag({\cf17 const} uint16_t x, {\cf18 bool} v) __attribute__((always_inline)) \{\par
00510         {\cf19 if} (v) set_btn_flag(x);\par
00511         {\cf19 else} clr_btn_flag(x);\par
00512     \}\par
00513     {\cf17 inline} {\cf18 bool} eq_btn_flag({\cf17 const} uint16_t x, {\cf17 const} uint16_t y) __attribute__((always_inline)) \{\par
00514         {\cf19 return} (flags & x) == y;\par
00515     \}\par
00516 \par
00517    {\cf17 private}:\par
00518     uint16_t flags = 0;\par
00519 \}\par
}
}
{\xe \v EB_FOR_SCALE\:VirtButton.h}
{\xe \v VirtButton.h\:EB_FOR_SCALE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EB_FOR_SCALE\~ 6}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b VirtButton.h}.}\par
}
{\xe \v EB_SHIFT\:VirtButton.h}
{\xe \v VirtButton.h\:EB_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EB_SHIFT\~ 4}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b VirtButton.h}.}\par
}
{\xe \v X\:VirtButton.h}
{\xe \v VirtButton.h\:X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define X( a,  b)\~ a = (1 << b),}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b VirtButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v BUTTON_FLAG_T\:VirtButton.h}
{\xe \v VirtButton.h\:BUTTON_FLAG_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b BUTTON_FLAG_T}}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v BUTTON_FLAGS\:VirtButton.h}
{\xe \v VirtButton.h\:BUTTON_FLAGS}
{\qr BUTTON_FLAGS{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 50} of file {\b VirtButton.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00050              \{\par
00051     BUTTON_FLAGS\par
00052 \} BUTTON_FLAG_T;\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VirtButton.h\par \pard\plain 
{\tc\tcl2 \v src/core/VirtButton.h}
{\xe \v src/core/VirtButton.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00006 {\cf21 #pragma once}\par
00007 {\cf21 #include <Arduino.h>}\par
00008 \par
00009 {\cf21 #include "utils.h"}\par
00010 \par
00011 {\cf21 #define EB_SHIFT 4}\par
00012 \par
00013 {\cf21 #ifdef EB_DEB_TIME}\par
00014 {\cf21 #define EB_DEB_T (EB_DEB_TIME)}\par
00015 {\cf21 #endif}\par
00016 \par
00017 {\cf21 #ifdef EB_CLICK_TIME}\par
00018 {\cf21 #define EB_CLICK_T (EB_CLICK_TIME)}\par
00019 {\cf21 #endif}\par
00020 \par
00021 {\cf21 #ifdef EB_HOLD_TIME}\par
00022 {\cf21 #define EB_HOLD_T (EB_HOLD_TIME)}\par
00023 {\cf21 #endif}\par
00024 \par
00025 {\cf21 #ifdef EB_STEP_TIME}\par
00026 {\cf21 #define EB_STEP_T (EB_STEP_TIME)}\par
00027 {\cf21 #endif}\par
00028 \par
00029 {\cf21 #define EB_FOR_SCALE 6}\par
00030 \par
00031 {\cf21 #define BUTTON_FLAGS \\}\par
00032 {\cf21     X(B_CLKS_R, 0)\\}\par
00033 {\cf21     X(B_PRS_R,  1)\\}\par
00034 {\cf21     X(B_HLD_R,  2)\\}\par
00035 {\cf21     X(B_STP_R,  3)\\}\par
00036 {\cf21     X(B_REL_R,  4)\\}\par
00037 {\cf21     X(B_PRS,    5)\\}\par
00038 {\cf21     X(B_HLD,    6)\\}\par
00039 {\cf21     X(B_STP,    7)\\}\par
00040 {\cf21     X(B_REL,    8)\\}\par
00041 {\cf21     X(B_BUSY,   9)\\}\par
00042 {\cf21     X(B_DEB,    10)\\}\par
00043 {\cf21     X(B_TOUT,   11)\\}\par
00044 {\cf21     X(B_INV,    12)\\}\par
00045 {\cf21     X(B_BOTH,   13)\\}\par
00046 {\cf21     X(B_BISR,   14)\\}\par
00047 {\cf21     X(B_EHLD,   15)}\par
00048     \par
00049 {\cf21 #define X(a, b) a = (1 << b),}\par
00050 {\cf17 typedef} {\cf17 enum} \{\par
00051     BUTTON_FLAGS\par
00052 \} BUTTON_FLAG_T;\par
00053 {\cf21 #undef X}\par
00054 \par
00055 \par
00056 {\cf17 class }VirtButton \{\par
00057    {\cf17 public}:\par
00058     {\cf20 // ====================== SET ======================}\par
00059 \par
00060     {\cf18 void} init()\{\par
00061         setHoldTimeout();\par
00062         setStepTimeout();\par
00063         setClickTimeout();\par
00064         setDebounceTimeout();\par
00065 \par
00066     \}\par
00067 \par
00074     {\cf18 void} setHoldTimeout(uint16_t timeout=600) \{\par
00075 {\cf21 #ifndef EB_HOLD_TIME}\par
00076         EB_HOLD_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00077 {\cf21 #endif}\par
00078     \}\par
00079 \par
00085     {\cf18 void} setStepTimeout(uint16_t timeout=200) \{\par
00086 {\cf21 #ifndef EB_STEP_TIME}\par
00087         EB_STEP_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00088 {\cf21 #endif}\par
00089     \}\par
00090 \par
00096     {\cf18 void} setClickTimeout(uint16_t timeout=500) \{\par
00097 {\cf21 #ifndef EB_CLICK_TIME}\par
00098         EB_CLICK_T = (timeout < 4000) ? timeout >> EB_SHIFT : 4000 >> EB_SHIFT;\par
00099 {\cf21 #endif}\par
00100     \}\par
00101 \par
00102     {\cf18 void} setDebounceTimeout(uint8_t timeout=50) \{\par
00103 {\cf21 #ifndef EB_DEB_TIME}\par
00104         EB_DEB_T = (timeout < 255) ? timeout : 255;\par
00105 {\cf21 #endif}\par
00106     \}\par
00107 \par
00108     {\cf18 void} setBtnLevel({\cf18 bool} level) \{\par
00109         write_btn_flag(B_INV, !level);\par
00110     \}\par
00111 \par
00112     {\cf18 void} pressISR() \{\par
00113         {\cf19 if} (!read_btn_flag(B_DEB)) timer = EB_UPTIME();\par
00114         set_btn_flag(B_DEB | B_BISR);\par
00115     \}\par
00116 \par
00117     {\cf18 void} reset() \{\par
00118         clicks = 0;\par
00119         clr_btn_flag(~B_INV);\par
00120     \}\par
00121 \par
00122     {\cf18 void} clear() \{\par
00123         {\cf19 if} (read_btn_flag(B_CLKS_R)) clicks = 0;\par
00124         {\cf19 if} (read_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R)) \{\par
00125             clr_btn_flag(B_CLKS_R | B_STP_R | B_PRS_R | B_HLD_R | B_REL_R);\par
00126         \}\par
00127     \}\par
00128 \par
00129 \par
00137     {\cf18 bool} attach_call( cb_t callback_func) \{ \par
00138 {\cf21 #ifndef EB_NO_CALLBACK}\par
00139         {\cf19 if} (callback_func == {\cf17 nullptr} || cb) {\cf19 return} {\cf17 false};\par
00140         cb = *callback_func;\par
00141         {\cf19 return} {\cf17 true};\par
00142 {\cf21 #endif}\par
00143         {\cf19 return} {\cf17 false};\par
00144     \}\par
00145 \par
00146     {\cf20 //todo check variant with one name on 2 virtual functions}\par
00147     {\cf18 void} detach_call() \{\par
00148 {\cf21 #ifndef EB_NO_CALLBACK}\par
00149         cb = {\cf17 nullptr};\par
00150 {\cf21 #endif}\par
00151     \}\par
00152 \par
00153     {\cf20 // ====================== GET ======================}\par
00154     {\cf18 bool} press() \{\par
00155         {\cf19 return} read_btn_flag(B_PRS_R);\par
00156     \}\par
00157 \par
00158     {\cf18 bool} release() \{\par
00159         {\cf19 return} eq_btn_flag(B_REL_R | B_REL, B_REL_R | B_REL);\par
00160     \}\par
00161 \par
00162     {\cf18 bool} click() \{\par
00163         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD, B_REL_R);\par
00164     \}\par
00165 \par
00166     {\cf18 bool} pressing() \{\par
00167         {\cf19 return} read_btn_flag(B_PRS);\par
00168     \}\par
00169 \par
00170     {\cf18 bool} hold() \{\par
00171         {\cf19 return} read_btn_flag(B_HLD_R);\par
00172     \}\par
00173 \par
00174     {\cf18 bool} hold(uint8_t num) \{\par
00175         {\cf19 return} clicks == num && hold();\par
00176     \}\par
00177 \par
00178     {\cf18 bool} holding() \{\par
00179         {\cf19 return} eq_btn_flag(B_PRS | B_HLD, B_PRS | B_HLD);\par
00180     \}\par
00181 \par
00182     {\cf18 bool} holding(uint8_t num) \{\par
00183         {\cf19 return} clicks == num && holding();\par
00184     \}\par
00185 \par
00186     {\cf18 bool} step() \{\par
00187         {\cf19 return} read_btn_flag(B_STP_R);\par
00188     \}\par
00189 \par
00190     {\cf18 bool} step(uint8_t num) \{\par
00191         {\cf19 return} clicks == num && step();\par
00192     \}\par
00193 \par
00194     {\cf18 bool} hasClicks() \{\par
00195         {\cf19 return} eq_btn_flag(B_CLKS_R | B_HLD, B_CLKS_R);\par
00196     \}\par
00197 \par
00198     {\cf18 bool} hasClicks(uint8_t num) \{\par
00199         {\cf19 return} clicks == num && hasClicks();\par
00200     \}\par
00201 \par
00202     uint8_t getClicks() \{\par
00203         {\cf19 return} clicks;\par
00204     \}\par
00205 \par
00206     uint16_t getSteps() \{\par
00207 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00208 {\cf21 #ifdef EB_STEP_TIME}\par
00209         {\cf19 return} run_timer ? ((stepFor() + EB_STEP_T - 1) / EB_STEP_T) : 0;  \par
00210 {\cf21 #else}\par
00211         {\cf19 return} run_timer ? ((stepFor() + (EB_STEP_T << EB_SHIFT) - 1) / (EB_STEP_T << EB_SHIFT)) : 0;\par
00212 {\cf21 #endif}\par
00213 {\cf21 #endif}\par
00214         {\cf19 return} 0;\par
00215     \}\par
00216 \par
00217     {\cf18 bool} releaseHold() \{\par
00218         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_HLD | B_STP, B_REL_R | B_HLD);\par
00219     \}\par
00220 \par
00221     {\cf18 bool} releaseHold(uint8_t num) \{\par
00222         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_HLD | B_STP, B_CLKS_R | B_HLD);\par
00223     \}\par
00224 \par
00225     {\cf18 bool} releaseStep() \{\par
00226         {\cf19 return} eq_btn_flag(B_REL_R | B_REL | B_STP, B_REL_R | B_STP);\par
00227     \}\par
00228 \par
00229     {\cf18 bool} releaseStep(uint8_t num) \{\par
00230         {\cf19 return} clicks == num && eq_btn_flag(B_CLKS_R | B_STP, B_CLKS_R | B_STP);\par
00231     \}\par
00232 \par
00233     {\cf18 bool} waiting() \{\par
00234         {\cf19 return} clicks && eq_btn_flag(B_PRS | B_REL, 0);\par
00235     \}\par
00236 \par
00237     {\cf18 bool} busy() \{\par
00238         {\cf19 return} read_btn_flag(B_BUSY);\par
00239     \}\par
00240 \par
00246     EB_FLAGS_T action() \{\par
00247         {\cf19 switch} (flags & 0b111111111) \{\par
00248             {\cf19 case} (B_PRS | B_PRS_R):\par
00249                 {\cf19 return} EB_PRESS;\par
00250             {\cf19 case} (B_PRS | B_HLD | B_HLD_R):\par
00251                 {\cf19 return} EB_HOLD;\par
00252             {\cf19 case} (B_PRS | B_HLD | B_STP | B_STP_R):\par
00253                 {\cf19 return} EB_STEP;\par
00254             {\cf19 case} (B_REL | B_REL_R):\par
00255             {\cf19 case} (B_REL | B_REL_R | B_HLD):\par
00256             {\cf19 case} (B_REL | B_REL_R | B_HLD | B_STP):\par
00257                 {\cf19 return} EB_RELEASE;\par
00258             {\cf19 case} (B_REL_R):\par
00259                 {\cf19 return} EB_CLICK;\par
00260             {\cf19 case} (B_CLKS_R):\par
00261                 {\cf19 return} EB_CLICKS;\par
00262             {\cf19 case} (B_REL_R | B_HLD):\par
00263                 {\cf19 return} EB_REL_HOLD;\par
00264             {\cf19 case} (B_CLKS_R | B_HLD):\par
00265                 {\cf19 return} EB_REL_HOLD_C;\par
00266             {\cf19 case} (B_REL_R | B_HLD | B_STP):\par
00267                 {\cf19 return} EB_REL_STEP;\par
00268             {\cf19 case} (B_CLKS_R | B_HLD | B_STP):\par
00269                 {\cf19 return} EB_REL_STEP_C;\par
00270             {\cf19 default}:\par
00271                 {\cf19 return} EB_NONE;\par
00272         \}\par
00273     \}\par
00274 \par
00275     {\cf20 // ====================== TIME ======================}\par
00282     {\cf18 bool} timeout(uint16_t tout) \{\par
00283         {\cf19 if} (read_btn_flag(B_TOUT) && (uint16_t)((uint16_t)EB_UPTIME() - timer) > tout) \{\par
00284             clr_btn_flag(B_TOUT);\par
00285             {\cf19 return} 1;\par
00286         \}\par
00287         {\cf19 return} 0;\par
00288     \}\par
00289 \par
00297     uint16_t pressFor() \{\par
00298 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00299         {\cf19 if} (run_timer) {\cf19 return} (uint16_t)EB_UPTIME() - run_timer;\par
00300 {\cf21 #endif}\par
00301         {\cf19 return} 0;\par
00302     \}\par
00303 \par
00304     {\cf18 bool} pressFor(uint16_t ms) \{\par
00305         {\cf19 return} pressFor() > ms;\par
00306     \}\par
00307 \par
00313     uint16_t holdFor() \{\par
00314 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00315         {\cf19 if} (read_btn_flag(B_HLD)) \{\par
00316 {\cf21 #ifdef EB_HOLD_TIME}\par
00317             {\cf19 return} pressFor() - EB_HOLD_T;\par
00318 {\cf21 #else}\par
00319             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT);\par
00320 {\cf21 #endif}\par
00321         \}\par
00322 {\cf21 #endif}\par
00323         {\cf19 return} 0;\par
00324     \}\par
00325 \par
00332     {\cf18 bool} holdFor(uint16_t ms) \{\par
00333         {\cf19 return} holdFor() > ms;\par
00334     \}\par
00335 \par
00336     uint16_t stepFor() \{\par
00337 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00338         {\cf19 if} (read_btn_flag(B_STP)) \{\par
00339 {\cf21 #ifdef EB_HOLD_TIME}\par
00340             {\cf19 return} pressFor() - EB_HOLD_T * 2;\par
00341 {\cf21 #else}\par
00342             {\cf19 return} pressFor() - (EB_HOLD_T << EB_SHIFT) * 2;\par
00343 {\cf21 #endif}\par
00344         \}\par
00345 {\cf21 #endif}\par
00346         {\cf19 return} 0;\par
00347     \}\par
00348 \par
00349     {\cf18 bool} stepFor(uint16_t ms) \{\par
00350         {\cf19 return} stepFor() > ms;\par
00351     \}\par
00352 \par
00353     {\cf20 // ====================== POLL ======================}\par
00354     {\cf18 bool} tick(VirtButton& b0, VirtButton& b1) \{\par
00355         {\cf19 if} (read_btn_flag(B_BOTH)) \{\par
00356             {\cf19 if} (!b0.pressing() && !b1.pressing()) clr_btn_flag(B_BOTH);\par
00357             {\cf19 if} (!b0.pressing()) b0.reset();\par
00358             {\cf19 if} (!b1.pressing()) b1.reset();\par
00359             b0.clear();\par
00360             b1.clear();\par
00361             {\cf19 return} tick(1);\par
00362         \} {\cf19 else} \{\par
00363             {\cf19 if} (b0.pressing() && b1.pressing()) set_btn_flag(B_BOTH);\par
00364             {\cf19 return} tick(0);\par
00365         \}\par
00366     \}\par
00367 \par
00368     {\cf18 bool} tick({\cf18 bool} state) \{\par
00369         clear();\par
00370         state = pollBtn(state);\par
00371 {\cf21 #ifndef EB_NO_CALLBACK}\par
00372         {\cf19 if} (cb && state) cb();\par
00373 {\cf21 #endif}\par
00374         {\cf19 return} state;\par
00375     \}\par
00376 \par
00377 \par
00378     {\cf18 bool} tickRaw({\cf18 bool} state) \{\par
00379         {\cf19 return} pollBtn(state);\par
00380     \}\par
00381 \par
00382     uint8_t clicks;\par
00383 \par
00384     {\cf20 // deprecated}\par
00385     {\cf18 void} setButtonLevel({\cf18 bool} level) \{\par
00386         write_btn_flag(B_INV, !level);\par
00387     \}\par
00388 \par
00389     {\cf20 // ====================== PRIVATE ======================}\par
00390    {\cf17 protected}:\par
00391     {\cf18 bool} pollBtn({\cf18 bool} s) \{\par
00392         {\cf19 if} (read_btn_flag(B_BISR)) \{\par
00393             clr_btn_flag(B_BISR);\par
00394             s = 1;\par
00395         \} {\cf19 else} s ^= read_btn_flag(B_INV);\par
00396 \par
00397         {\cf19 if} (!read_btn_flag(B_BUSY)) \{\par
00398             {\cf19 if} (s) set_btn_flag(B_BUSY);\par
00399             {\cf19 else} {\cf19 return} 0;\par
00400         \}\par
00401 \par
00402         uint16_t ms = EB_UPTIME();\par
00403         uint16_t deb = ms - timer;\par
00404 \par
00405         {\cf19 if} (s) \{                                      \par
00406             {\cf19 if} (!read_btn_flag(B_PRS)) \{                  \par
00407                 {\cf19 if} (!read_btn_flag(B_DEB) && EB_DEB_T) \{  \par
00408                     set_btn_flag(B_DEB);                   \par
00409                     timer = ms;                         \par
00410                 \} {\cf19 else} \{                                \par
00411                     {\cf19 if} (deb >= EB_DEB_T || !EB_DEB_T) \{ \par
00412                         set_btn_flag(B_PRS | B_PRS_R);      \par
00413 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00414                         run_timer = ms;\par
00415 {\cf21 #endif}\par
00416                         timer = ms;  \par
00417                     \}\par
00418                 \}\par
00419             \} {\cf19 else} \{  \par
00420                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00421                     {\cf19 if} (!read_btn_flag(B_HLD)) \{  \par
00422 {\cf21 #ifdef EB_HOLD_TIME}\par
00423                         {\cf19 if} (deb >= (uint16_t)EB_HOLD_T) \{  \par
00424 {\cf21 #else}\par
00425                         {\cf19 if} (deb >= (uint16_t)(EB_HOLD_T << EB_SHIFT)) \{  \par
00426 {\cf21 #endif}\par
00427                             set_btn_flag(B_HLD_R | B_HLD); \par
00428                             timer = ms;                 \par
00429                         \}\par
00430                     \} {\cf19 else} \{  \par
00431 {\cf21 #ifdef EB_STEP_TIME}\par
00432                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? EB_STEP_T : EB_HOLD_T)) \{\par
00433 {\cf21 #else}\par
00434                         {\cf19 if} (deb >= (uint16_t)(read_btn_flag(B_STP) ? (EB_STEP_T << EB_SHIFT) : (EB_HOLD_T << EB_SHIFT))) \{\par
00435 {\cf21 #endif}\par
00436                             set_btn_flag(B_STP | B_STP_R);  \par
00437                             timer = ms;                   \par
00438                         \}\par
00439                     \}\par
00440                 \}\par
00441             \}\par
00442         \} {\cf19 else} \{                                     \par
00443             {\cf19 if} (read_btn_flag(B_PRS)) \{                 \par
00444                 {\cf19 if} (deb >= EB_DEB_T) \{               \par
00445                     {\cf19 if} (!read_btn_flag(B_HLD)) clicks++;    \par
00446                     {\cf19 if} (read_btn_flag(B_EHLD)) clicks = 0;  \par
00447                     set_btn_flag(B_REL | B_REL_R);        \par
00448                     clr_btn_flag(B_PRS);                   \par
00449                 \}\par
00450             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_REL)) \{\par
00451                 {\cf19 if} (!read_btn_flag(B_EHLD)) \{\par
00452                     set_btn_flag(B_REL_R);\par
00453                 \}\par
00454                 clr_btn_flag(B_REL | B_EHLD);\par
00455                 timer = ms;       \par
00456             \} {\cf19 else} {\cf19 if} (clicks) \{  \par
00457 {\cf21 #ifdef EB_CLICK_TIME}\par
00458                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)EB_CLICK_T) set_btn_flag(B_CLKS_R);  \par
00459 {\cf21 #else}\par
00460                 {\cf19 if} (read_btn_flag(B_HLD | B_STP) || deb >= (uint16_t)(EB_CLICK_T << EB_SHIFT)) set_btn_flag(B_CLKS_R);  \par
00461 {\cf21 #endif}\par
00462 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00463                 {\cf19 else} {\cf19 if} (run_timer) run_timer = 0;\par
00464 {\cf21 #endif}\par
00465             \} {\cf19 else} {\cf19 if} (read_btn_flag(B_BUSY)) \{\par
00466                 clr_btn_flag(B_HLD | B_STP | B_BUSY);\par
00467                 set_btn_flag(B_TOUT);\par
00468 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00469                 run_timer = 0;\par
00470 {\cf21 #endif}\par
00471                 timer = ms;  {\cf20 // test!!}\par
00472             \}\par
00473             {\cf19 if} (read_btn_flag(B_DEB)) clr_btn_flag(B_DEB);  \par
00474         \}\par
00475         {\cf19 return} read_btn_flag(B_CLKS_R | B_PRS_R | B_HLD_R | B_STP_R | B_REL_R);\par
00476     \}\par
00477 \par
00478     uint16_t timer = 0;\par
00479 {\cf21 #ifndef EB_NO_PEDOMETER}\par
00480     uint16_t run_timer = 0;\par
00481 {\cf21 #endif}\par
00482 \par
00483 {\cf21 #ifndef EB_NO_CALLBACK}\par
00484     cb_t cb = {\cf17 nullptr};\par
00485 {\cf21 #endif}\par
00486 \par
00487 {\cf21 #ifndef EB_DEB_TIME}\par
00488     uint8_t EB_DEB_T = 50;\par
00489 {\cf21 #endif}\par
00490 {\cf21 #ifndef EB_CLICK_TIME}\par
00491     uint8_t EB_CLICK_T = (500 >> EB_SHIFT);\par
00492 {\cf21 #endif}\par
00493 {\cf21 #ifndef EB_HOLD_TIME}\par
00494     uint8_t EB_HOLD_T = (600 >> EB_SHIFT);\par
00495 {\cf21 #endif}\par
00496 {\cf21 #ifndef EB_STEP_TIME}\par
00497     uint8_t EB_STEP_T = (200 >> EB_SHIFT);\par
00498 {\cf21 #endif}\par
00499 \par
00500     {\cf17 inline} {\cf18 void} set_btn_flag({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00501         flags |= x;\par
00502     \}\par
00503     {\cf17 inline} {\cf18 void} clr_btn_flag({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00504         flags &= ~x;\par
00505     \}\par
00506     {\cf17 inline} {\cf18 bool} read_btn_flag({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00507         {\cf19 return} flags & x;\par
00508     \}\par
00509     {\cf17 inline} {\cf18 void} write_btn_flag({\cf17 const} uint16_t x, {\cf18 bool} v) __attribute__((always_inline)) \{\par
00510         {\cf19 if} (v) set_btn_flag(x);\par
00511         {\cf19 else} clr_btn_flag(x);\par
00512     \}\par
00513     {\cf17 inline} {\cf18 bool} eq_btn_flag({\cf17 const} uint16_t x, {\cf17 const} uint16_t y) __attribute__((always_inline)) \{\par
00514         {\cf19 return} (flags & x) == y;\par
00515     \}\par
00516 \par
00517    {\cf17 private}:\par
00518     uint16_t flags = 0;\par
00519 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/core/VirtEncButton.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/core/VirtEncButton.h}
{\xe \v src/core/VirtEncButton.h}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual encoder button class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "VirtButton.h"}\par
{\f2 #include "VirtEncoder.h"}\par
{\f2 #include "utils.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VirtEncButton}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a virtual encoder button. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual encoder button class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b VirtEncButton.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VirtEncButton.h\par \pard\plain 
{\tc\tcl2 \v src/core/VirtEncButton.h}
{\xe \v src/core/VirtEncButton.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00006 {\cf21 #pragma once}\par
00007 {\cf21 #include <Arduino.h>}\par
00008 \par
00009 {\cf21 #include "VirtButton.h"}\par
00010 {\cf21 #include "VirtEncoder.h"}\par
00011 {\cf21 #include "utils.h"}\par
00012 \par
00013 {\cf21 #ifdef EB_FAST_TIME}\par
00014 {\cf21 #define EB_FAST_T (EB_FAST_TIME)}\par
00015 {\cf21 #endif}\par
00016 \par
00025 {\cf17 class }VirtEncButton : {\cf17 public} VirtButton, {\cf17 public} VirtEncoder \{\par
00026    {\cf17 public}:\par
00027     {\cf20 // ====================== SET ======================}\par
00028 \par
00035     {\cf18 bool} setFastTimeout(uint8_t tout) \{\par
00036 {\cf21 #ifndef EB_FAST_TIME}\par
00037         EB_FAST_T = tout;\par
00038         {\cf19 return} {\cf17 true};\par
00039 {\cf21 #endif}\par
00040         {\cf19 return} {\cf17 false};\par
00041     \}\par
00042 \par
00049     {\cf18 void} clear() \{\par
00050         VirtButton::clear();\par
00051         VirtEncoder::clear();\par
00052     \}\par
00053 \par
00061     {\cf18 bool} attach_call(EB_FLAGS_T handler, cb_t callback_func)\{\par
00062 {\cf21 #ifndef EB_NO_CALLBACK}\par
00063         {\cf19 if}(callback_func)\{\par
00064             {\cf19 switch} (handler)\par
00065             \{\par
00066                 {\cf19 case} EB_PRESS:\par
00067                     {\cf19 if}(cb[0]) {\cf19 return} {\cf17 false};\par
00068                     {\cf19 return} VirtButton::attach_call(callback_func);\par
00069                 \par
00070                 {\cf19 case} EB_TURN_R:\par
00071                     {\cf19 if}(cb[1]) {\cf19 return} {\cf17 false};\par
00072                     {\cf19 return} VirtEncoder::attach_right(callback_func); {\cf20 //todo attach_call}\par
00073 \par
00074                 {\cf19 case} EB_TURN_L:\par
00075                     {\cf19 if}(cb[2]) {\cf19 return} {\cf17 false};\par
00076                     {\cf19 return} VirtEncoder::attach_left(callback_func); {\cf20 //todo attach_call}\par
00077 \par
00078                 {\cf19 case} EB_TURN_HOLD_R:\par
00079                     {\cf19 if}(cb[3]) {\cf19 return} {\cf17 false};\par
00080                     cb[3] = *callback_func;\par
00081                     {\cf19 return} {\cf17 true};\par
00082 \par
00083                 {\cf19 case} EB_TURN_HOLD_L:\par
00084                     {\cf19 if}(cb[4]) {\cf19 return} {\cf17 false};\par
00085                     cb[4] = *callback_func;\par
00086                     {\cf19 return} {\cf17 true};\par
00087 \par
00088                 {\cf19 default}:\par
00089                     {\cf19 return} {\cf17 false};\par
00090             \}\par
00091         \}       \par
00092 {\cf21 #endif}\par
00093         {\cf19 return} {\cf17 false};\par
00094     \}\par
00095 \par
00099     {\cf18 void} detach_call()\{\par
00100 {\cf21 #ifndef EB_NO_CALLBACK}\par
00101         VirtButton::detach_call();\par
00102         VirtEncoder::detach_call();\par
00103         cb[3] = {\cf17 nullptr};\par
00104         cb[4] = {\cf17 nullptr};\par
00105 {\cf21 #endif}\par
00106     \}\par
00107 \par
00108     {\cf20 // ====================== GET ======================}\par
00109 \par
00115     {\cf18 bool} turnH() \{\par
00116         {\cf19 return} turn() && read_btn_flag(B_EHLD);\par
00117     \}\par
00118 \par
00124     {\cf18 bool} fast() \{\par
00125         {\cf19 return} read_encf(E_FAST);\par
00126     \}\par
00127 \par
00133     {\cf18 bool} right() \{\par
00134         {\cf19 return} read_encf(E_DIR) && turn() && !read_btn_flag(B_EHLD);\par
00135     \}\par
00136 \par
00142     {\cf18 bool} left() \{\par
00143         {\cf19 return} !read_encf(E_DIR) && turn() && !read_btn_flag(B_EHLD);\par
00144     \}\par
00145 \par
00151     {\cf18 bool} rightH() \{\par
00152         {\cf19 return} read_encf(E_DIR) && turnH();\par
00153     \}\par
00154 \par
00160     {\cf18 bool} leftH() \{\par
00161         {\cf19 return} !read_encf(E_DIR) && turnH();\par
00162     \}\par
00163 \par
00169     {\cf18 bool} encHolding() \{\par
00170         {\cf19 return} read_btn_flag(B_EHLD);\par
00171     \}\par
00172 \par
00180     EB_FLAGS_T action() \{\par
00181         EB_FLAGS_T e_state =  VirtEncoder::action(); \par
00182         EB_FLAGS_T b_state =  VirtButton::action();\par
00183 \par
00184         {\cf19 if} (e_state == EB_NONE) \{\par
00185             {\cf19 return} b_state; \par
00186         \}\par
00187         \par
00188         {\cf19 if}(b_state == EB_HOLD)\{\par
00189             {\cf19 switch} (e_state)\par
00190             \{\par
00191                 {\cf19 case} EB_TURN_R:\par
00192                     {\cf19 return} EB_TURN_HOLD_R;\par
00193                 {\cf19 case} EB_TURN_L:\par
00194                     {\cf19 return} EB_TURN_HOLD_L;\par
00195                 {\cf19 case} EB_TURN:\par
00196                     {\cf19 return} EB_TURN;\par
00197                 {\cf19 default}:\par
00198                     {\cf19 return} EB_HOLD;\par
00199             \}\par
00200         \}\par
00201         {\cf19 return} e_state;\par
00202 \par
00203 \par
00204         {\cf20 /* needs to be tested}\par
00205 {\cf20 }\par
00206 {\cf20          switch (b_state | e_state)}\par
00207 {\cf20          \{}\par
00208 {\cf20             case 1000000001000:}\par
00209 {\cf20                 return EB_TURN_HOLD_R; //EB_HOLD + EB_TURN_R}\par
00210 {\cf20             case 10000000011000:}\par
00211 {\cf20                 return EB_TURN_HOLD_L; //EB_HOLD + EB_TURN_L}\par
00212 {\cf20             case 10000001000 :}\par
00213 {\cf20                 return EB_TURN;//EB_HOLD + EB_TURN}\par
00214 {\cf20             case (e_state | EB_NONE):}\par
00215 {\cf20                 return e_state; //if b_state == EB_NONE}\par
00216 {\cf20             default:}\par
00217 {\cf20                 return b_state; }\par
00218 {\cf20          \}}\par
00219 {\cf20         }\par
00220 {\cf20         */}\par
00221     \}\par
00222 \par
00223     \par
00224     {\cf20 // ====================== POLL ======================}\par
00225     {\cf20 // ISR}\par
00226 \par
00234     int8_t tickISR({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00235         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00236     \}\par
00237 \par
00244     int8_t tickISR(int8_t state) \{\par
00245         state = VirtEncoder::pollEnc(state);\par
00246         {\cf19 if} (state) \{\par
00247 {\cf21 #ifdef EB_NO_BUFFER}\par
00248             set_encf(E_ISR_F);\par
00249             write_encf(E_DIR, state > 0);\par
00250             write_encf(E_FAST, checkFast());\par
00251 {\cf21 #else}\par
00252             {\cf19 for} (uint8_t i = 0; i < 15; i += 3) \{\par
00253                 {\cf19 if} (!(ebuffer & (1 << i))) \{\par
00254                     ebuffer |= (1 << i);                 {\cf20 // turn}\par
00255                     {\cf19 if} (state > 0) ebuffer |= E_DIR;    {\cf20 // dir}\par
00256                     {\cf19 if} (checkFast()) ebuffer |= E_FAST;  {\cf20 // fast}\par
00257 \par
00258                     {\cf20 // if (state > 0) ebuffer |= (1 << (i + 1));    // dir}\par
00259                     {\cf20 // if (checkFast()) ebuffer |= (1 << (i + 2));  // fast}\par
00260                     {\cf19 break};\par
00261                 \}\par
00262             \}\par
00263 {\cf21 #endif}\par
00264         \}\par
00265         {\cf19 return} state;\par
00266     \}\par
00267 \par
00276     {\cf18 bool} tick({\cf18 bool} e0, {\cf18 bool} e1, {\cf18 bool} btn) \{\par
00277         {\cf19 return} tick(e0 | (e1 << 1), btn);\par
00278     \}\par
00279 \par
00287     {\cf18 bool} tick(int8_t state, {\cf18 bool} btn) \{\par
00288         clear();\par
00289         {\cf18 bool} f = tickRaw(state, btn);\par
00290 \par
00291 {\cf21 #ifndef EB_NO_CALLBACK}\par
00292         {\cf19 if}(f)\{\par
00293             {\cf19 switch} (action())\par
00294             \{\par
00295                 {\cf19 case} EB_PRESS:\par
00296                     {\cf19 if}(cb[0]) (this->cb[0])();\par
00297                     {\cf19 break};\par
00298                 {\cf19 case} EB_TURN_R:\par
00299                     {\cf19 if}(cb[1]) (this->cb[1])();\par
00300                     {\cf19 break};\par
00301                 {\cf19 case} EB_TURN_L:\par
00302                     {\cf19 if}(cb[2]) (this->cb[2])();\par
00303                     {\cf19 break};\par
00304                 {\cf19 case} EB_TURN_HOLD_R:\par
00305                     {\cf19 if}(cb[3]) (this->cb[3])();\par
00306                     {\cf19 break};\par
00307                 {\cf19 case} EB_TURN_HOLD_L:\par
00308                     {\cf19 if}(cb[4]) (this->cb[4])();\par
00309                     {\cf19 break};\par
00310                 {\cf19 default}:\par
00311                     {\cf19 break};\par
00312             \}\par
00313         \}\par
00314 {\cf21 #endif}\par
00315         {\cf19 return} f;\par
00316     \}\par
00317 \par
00324     {\cf18 bool} tick({\cf18 bool} btn) \{\par
00325         {\cf19 return} tick(-1, btn);\par
00326     \}\par
00327 \par
00328     {\cf20 // RAW}\par
00329 \par
00338     {\cf18 bool} tickRaw({\cf18 bool} e0, {\cf18 bool} e1, {\cf18 bool} btn) \{\par
00339         {\cf19 return} tickRaw(e0 | (e1 << 1), btn);\par
00340     \}\par
00341 \par
00349     {\cf18 bool} tickRaw(int8_t state, {\cf18 bool} btn) \{\par
00350         btn = VirtButton::tickRaw(btn);\par
00351 \par
00352         {\cf18 bool} encf = 0;\par
00353 {\cf21 #ifdef EB_NO_BUFFER}\par
00354         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00355             clr_encf(E_ISR_F);\par
00356             encf = 1;\par
00357         \}\par
00358 {\cf21 #else}\par
00359         {\cf19 if} (ebuffer) \{\par
00360             write_encf(E_DIR, ebuffer & 0b10);\par
00361             write_encf(E_FAST, ebuffer & 0b100);\par
00362             ebuffer >>= 3;\par
00363             encf = 1;\par
00364         \}\par
00365 {\cf21 #endif}\par
00366         {\cf19 else} {\cf19 if} ((state >= 0) && (state = VirtEncoder::pollEnc(state))) \{\par
00367             write_encf(E_DIR, state > 0);\par
00368             write_encf(E_FAST, checkFast());\par
00369             encf = 1;\par
00370         \}\par
00371         {\cf19 if} (encf) \{\par
00372             {\cf19 if} (read_btn_flag(B_PRS)) set_btn_flag(B_EHLD);    \par
00373             {\cf19 else} clicks = 0;\par
00374             {\cf19 if} (!read_btn_flag(B_TOUT)) set_btn_flag(B_TOUT);  \par
00375             set_encf(E_TRN_R);                      \par
00376         \}\par
00377         {\cf19 return} encf | btn;\par
00378     \}\par
00379 \par
00386     {\cf18 bool} tickRaw({\cf18 bool} btn) \{\par
00387         {\cf19 return} tickRaw(-1, btn);\par
00388     \}\par
00389 \par
00390     {\cf20 // ===================== PRIVATE =====================}\par
00391 \par
00392    {\cf17 protected}:\par
00393 \par
00394 {\cf21 #ifndef EB_NO_CALLBACK}\par
00395     {\cf20 // void (*callback[14])() = \{\}; //from version 2}\par
00396     cb_t cb[5] = \{VirtButton::cb, VirtEncoder::cb[0], VirtEncoder::cb[1], {\cf17 nullptr}, {\cf17 nullptr}\};\par
00397 {\cf21 #endif}\par
00398 \par
00399 {\cf21 #ifndef EB_FAST_TIME}\par
00400     uint8_t EB_FAST_T = 30;\par
00401 {\cf21 #endif}\par
00402 \par
00403 {\cf21 #ifndef EB_NO_BUFFER}\par
00404     uint16_t ebuffer = 0;\par
00405 {\cf21 #endif}\par
00406 \par
00407    {\cf17 private}:\par
00408     {\cf18 bool} checkFast() \{\par
00409         uint16_t ms = EB_UPTIME();\par
00410         {\cf18 bool} f = 0;\par
00411         {\cf19 if} (ms - timer < EB_FAST_T) f = 1;\par
00412         timer = ms;\par
00413         {\cf19 return} f;\par
00414     \}\par
00415 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/core/VirtEncoder.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/core/VirtEncoder.h}
{\xe \v src/core/VirtEncoder.h}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual encoder class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Arduino.h>}\par
{\f2 #include "utils.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VirtEncoder}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a virtual encoder. This class provides methods to set the encoder's properties, attach_call callback functions for handling encoder events, and poll the encoder for rotation and direction. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EB_STEP4_LOW}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EB_STEP4_HIGH}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EB_STEP2}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EB_STEP1}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENC_FLAGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b X}(a,  b)\~ a = (1 << b),\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ENC_FLAG_T} \{ {\b ENC_FLAGS}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual encoder class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b VirtEncoder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v EB_STEP1\:VirtEncoder.h}
{\xe \v VirtEncoder.h\:EB_STEP1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EB_STEP1\~ 3}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b VirtEncoder.h}.}\par
}
{\xe \v EB_STEP2\:VirtEncoder.h}
{\xe \v VirtEncoder.h\:EB_STEP2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EB_STEP2\~ 2}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b VirtEncoder.h}.}\par
}
{\xe \v EB_STEP4_HIGH\:VirtEncoder.h}
{\xe \v VirtEncoder.h\:EB_STEP4_HIGH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EB_STEP4_HIGH\~ 1}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b VirtEncoder.h}.}\par
}
{\xe \v EB_STEP4_LOW\:VirtEncoder.h}
{\xe \v VirtEncoder.h\:EB_STEP4_LOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EB_STEP4_LOW\~ 0}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b VirtEncoder.h}.}\par
}
{\xe \v ENC_FLAGS\:VirtEncoder.h}
{\xe \v VirtEncoder.h\:ENC_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ENC_FLAGS}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     X(E_TYPE,    0)\\\par
    X(E_REVERSE, 2)\\\par
    X(E_FAST,    3)\\\par
    X(E_DIR,     4)\\\par
    X(E_TRN_R,   5)\\\par
    X(E_ISR_F,   6)\\\par
    X(E_ISR,     7)\par
}
{
Definition at line {\b 19} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00030              \{\par
00031     ENC_FLAGS\par
00032 \} ENC_FLAG_T;\par
00033 {\cf21 #undef X}\par
00034 \par
00042 {\cf17 class }VirtEncoder \{\par
00043    {\cf17 public}:\par
00044    \par
00048     VirtEncoder() : prev(0), ecount(0) \{\}\par
00049     \par
00050     {\cf20 // ====================== SET ======================}\par
00051 \par
00057     {\cf18 void} setEncReverse({\cf18 bool} rev = {\cf17 false}) \{\par
00058         {\cf19 if} (rev) set_encf(E_REVERSE);\par
00059         {\cf19 else} clr_encf(E_REVERSE);\par
00060     \}\par
00061 \par
00067     {\cf18 void} setEncType(uint8_t type = EB_STEP1) \{\par
00068         flags = (flags & 0b11111100) | type;\par
00069     \}\par
00070 \par
00078     {\cf18 void} setEncISR({\cf18 bool} use={\cf17 true})\{\par
00079         write_encf(E_ISR, use);\par
00080     \}\par
00081 \par
00089     {\cf18 bool} attach_right(cb_t callback_func)\{\par
00090 {\cf21 #ifndef EB_NO_CALLBACK}\par
00091         uint8_t l_r = (read_encf(E_REVERSE)) ? 1 : 0;\par
00092         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00093         cb[l_r] = *callback_func;\par
00094         {\cf19 return} {\cf17 true};\par
00095 {\cf21 #endif}\par
00096         {\cf19 return} {\cf17 false};\par
00097     \}\par
00098 \par
00105     {\cf18 bool} attach_left(cb_t callback_func)\{\par
00106 {\cf21 #ifndef EB_NO_CALLBACK}\par
00107         uint8_t l_r = (read_encf(E_REVERSE)) ? 0 : 1;\par
00108         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00109         cb[l_r] = *callback_func;\par
00110         {\cf19 return} {\cf17 true};\par
00111 {\cf21 #endif}\par
00112         {\cf19 return} {\cf17 false};\par
00113     \}\par
00114 \par
00115     {\cf20 //todo universal function}\par
00116     {\cf20 // void attach_call()\{\}}\par
00117 \par
00121     {\cf18 void} detach_call() \{\par
00122 {\cf21 #ifndef EB_NO_CALLBACK}\par
00123         cb[0] = {\cf17 nullptr};\par
00124         cb[1] = {\cf17 nullptr};\par
00125 {\cf21 #endif}\par
00126     \}\par
00127 \par
00134     {\cf18 void} initEnc({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00135         initEnc(e0 | (e1 << 1));\par
00136     \}\par
00137 \par
00143     {\cf18 void} initEnc(int8_t v) \{\par
00144         prev = v;\par
00145     \}\par
00146 \par
00150     {\cf18 void} clear() \{\par
00151         {\cf19 if} (read_encf(E_TRN_R)) clr_encf(E_TRN_R);\par
00152     \}\par
00153 \par
00154     {\cf20 // ====================== POLL ======================}\par
00155 \par
00161     {\cf18 bool} turn() \{\par
00162         {\cf19 return} read_encf(E_TRN_R);\par
00163     \}\par
00164 \par
00170     int8_t dir() \{\par
00171         {\cf19 return} read_encf(E_DIR) ? 1 : -1;\par
00172     \}\par
00173 \par
00182     EB_FLAGS_T action() \{\par
00183         {\cf19 switch} (flags & 0b111111111) \{\par
00184             {\cf19 case}(E_TRN_R | E_FAST):\par
00185                 {\cf19 return} EB_TURN;\par
00186             {\cf19 case}(E_TRN_R | E_DIR | E_REVERSE):\par
00187                 {\cf19 return} EB_TURN_L;\par
00188             {\cf19 case}(E_TRN_R | E_DIR):\par
00189                 {\cf19 return} EB_TURN_R;   \par
00190             {\cf19 default}:\par
00191                 {\cf19 return} EB_NONE;\par
00192         \}\par
00193     \}\par
00194 \par
00202     int8_t tickISR({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00203         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00204     \}\par
00205 \par
00212     int8_t tickISR(int8_t state) \{\par
00213         state = pollEnc(state);\par
00214         {\cf19 if} (state) \{\par
00215             set_encf(E_ISR_F);\par
00216             write_encf(E_DIR, state > 0);\par
00217         \}\par
00218         {\cf19 return} state;\par
00219     \}\par
00220 \par
00228     int8_t tick({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00229         {\cf19 return} tick(e0 | (e1 << 1));\par
00230     \}\par
00231 \par
00238     int8_t tick(int8_t state) \{\par
00239         state = tickRaw(state);\par
00240         {\cf19 if} (state)\par
00241         \{\par
00242 {\cf21     #ifndef EB_NO_CALLBACK}\par
00243             {\cf19 if} (cb[0] && state < 0) cb[0]();\par
00244             {\cf19 if} (cb[1] && state > 0) cb[1]();\par
00245 {\cf21     #endif}\par
00246             {\cf19 return} state;\par
00247         \}\par
00248         clear();\par
00249         {\cf19 return} 0;\par
00250     \}\par
00251 \par
00257     int8_t tick() \{\par
00258         {\cf19 return} tick(-1);\par
00259     \}\par
00260 \par
00268     int8_t tickRaw({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00269         {\cf19 return} tickRaw(e0 | (e1 << 1));\par
00270     \}\par
00271 \par
00279     int8_t tickRaw(int8_t state) \{\par
00280         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00281             clr_encf(E_ISR_F);\par
00282             set_encf(E_TRN_R);\par
00283             {\cf19 return} dir();\par
00284         \}\par
00285         {\cf19 if} ((state >= 0) && (state = pollEnc(state))) \{\par
00286             write_encf(E_DIR, state > 0);\par
00287             set_encf(E_TRN_R);\par
00288             {\cf19 return} state;\par
00289         \}\par
00290         {\cf19 return} 0;\par
00291     \}\par
00292 \par
00293     \par
00294     int8_t tickRaw() \{\par
00295         {\cf19 return} tickRaw(-1);\par
00296     \}\par
00297 \par
00305     int8_t pollEnc({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00306         {\cf19 return} pollEnc(e0 | (e1 << 1));\par
00307     \}\par
00308 \par
00315     int8_t pollEnc(int8_t state) \{\par
00316         {\cf19 if} (prev != state) \{\par
00317             ecount += ((0x49941661 >> ((state | (prev << 2)) << 1)) & 0b11) - 1;\par
00318             prev = state;\par
00319             {\cf19 if} (!ecount) {\cf19 return} 0;\par
00320             {\cf19 switch} (flags & 0b11) \{\par
00321                 {\cf19 case} EB_STEP4_LOW:\par
00322                     {\cf19 if} (state != 0b11) {\cf19 return} 0;  {\cf20 // skip 00, 01, 10}\par
00323                     {\cf19 break};\par
00324                 {\cf19 case} EB_STEP4_HIGH:\par
00325                     {\cf19 if} (state) {\cf19 return} 0;  {\cf20 // skip 01, 10, 11}\par
00326                     {\cf19 break};\par
00327                 {\cf19 case} EB_STEP2:\par
00328                     {\cf19 if} (state == 0b10 || state == 0b01) {\cf19 return} 0;  {\cf20 // skip 10 01}\par
00329                     {\cf19 break};\par
00330             \}\par
00331             state = ((ecount > 0) ^ read_encf(E_REVERSE)) ? 1 : -1;\par
00332             ecount = 0;\par
00333 {\cf21 #ifndef EB_NO_COUNTER}\par
00334             counter += state;\par
00335 {\cf21 #endif}\par
00336             {\cf19 return} state;\par
00337         \}\par
00338         {\cf19 return} 0;\par
00339     \}\par
00340 \par
00341 {\cf21 #ifndef EB_NO_COUNTER}\par
00342     int32_t counter = 0;\par
00343 {\cf21 #endif}\par
00344 \par
00345     {\cf20 // ===================== PROTECTED =====================}\par
00346    {\cf17 protected}:\par
00347     {\cf17 inline} {\cf18 void} set_encf({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00348         flags |= x;\par
00349     \}\par
00350     {\cf17 inline} {\cf18 void} clr_encf({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00351         flags &= ~x;\par
00352     \}\par
00353     {\cf17 inline} {\cf18 void} write_encf({\cf17 const} uint16_t x, {\cf18 bool} v) __attribute__((always_inline)) \{\par
00354         {\cf19 if} (v) set_encf(x);\par
00355         {\cf19 else} clr_encf(x);\par
00356     \}\par
00357     {\cf17 inline} {\cf18 bool} read_encf({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00358         {\cf19 return} flags & x;\par
00359     \}\par
00360 \par
00361 {\cf21 #ifndef EB_NO_CALLBACK}\par
00362     cb_t cb[2] = \{{\cf17 nullptr}, {\cf17 nullptr}\}; {\cf20 // callbacks for right and left turns}\par
00363 {\cf21 #endif}\par
00364 \par
00365     {\cf20 // ===================== PRIVATE =====================}\par
00366    {\cf17 private}:\par
00367     uint8_t flags = 0;\par
00368     int8_t prev : 4;\par
00369     int8_t ecount : 4;\par
00370 \}\par
}
}
{\xe \v X\:VirtEncoder.h}
{\xe \v VirtEncoder.h\:X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define X( a,  b)\~ a = (1 << b),}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b VirtEncoder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v ENC_FLAG_T\:VirtEncoder.h}
{\xe \v VirtEncoder.h\:ENC_FLAG_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b ENC_FLAG_T}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ENC_FLAGS\:VirtEncoder.h}
{\xe \v VirtEncoder.h\:ENC_FLAGS}
{\qr ENC_FLAGS{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 30} of file {\b VirtEncoder.h}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00030              \{\par
00031     ENC_FLAGS\par
00032 \} ENC_FLAG_T;\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VirtEncoder.h\par \pard\plain 
{\tc\tcl2 \v src/core/VirtEncoder.h}
{\xe \v src/core/VirtEncoder.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #pragma once}\par
00008 {\cf21 #include <Arduino.h>}\par
00009 \par
00010 {\cf21 #include "utils.h"}\par
00011 \par
00012 {\cf20 // ===================== CONST ======================}\par
00013 \par
00014 {\cf21 #define EB_STEP4_LOW 0}\par
00015 {\cf21 #define EB_STEP4_HIGH 1}\par
00016 {\cf21 #define EB_STEP2 2}\par
00017 {\cf21 #define EB_STEP1 3}\par
00018 \par
00019 {\cf21 #define ENC_FLAGS \\}\par
00020 {\cf21     X(E_TYPE,    0)\\}\par
00021 {\cf21     X(E_REVERSE, 2)\\}\par
00022 {\cf21     X(E_FAST,    3)\\}\par
00023 {\cf21     X(E_DIR,     4)\\}\par
00024 {\cf21     X(E_TRN_R,   5)\\}\par
00025 {\cf21     X(E_ISR_F,   6)\\}\par
00026 {\cf21     X(E_ISR,     7)}\par
00027 \par
00028     \par
00029 {\cf21 #define X(a, b) a = (1 << b),}\par
00030 {\cf17 typedef} {\cf17 enum} \{\par
00031     ENC_FLAGS\par
00032 \} ENC_FLAG_T;\par
00033 {\cf21 #undef X}\par
00034 \par
00042 {\cf17 class }VirtEncoder \{\par
00043    {\cf17 public}:\par
00044    \par
00048     VirtEncoder() : prev(0), ecount(0) \{\}\par
00049     \par
00050     {\cf20 // ====================== SET ======================}\par
00051 \par
00057     {\cf18 void} setEncReverse({\cf18 bool} rev = {\cf17 false}) \{\par
00058         {\cf19 if} (rev) set_encf(E_REVERSE);\par
00059         {\cf19 else} clr_encf(E_REVERSE);\par
00060     \}\par
00061 \par
00067     {\cf18 void} setEncType(uint8_t type = EB_STEP1) \{\par
00068         flags = (flags & 0b11111100) | type;\par
00069     \}\par
00070 \par
00078     {\cf18 void} setEncISR({\cf18 bool} use={\cf17 true})\{\par
00079         write_encf(E_ISR, use);\par
00080     \}\par
00081 \par
00089     {\cf18 bool} attach_right(cb_t callback_func)\{\par
00090 {\cf21 #ifndef EB_NO_CALLBACK}\par
00091         uint8_t l_r = (read_encf(E_REVERSE)) ? 1 : 0;\par
00092         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00093         cb[l_r] = *callback_func;\par
00094         {\cf19 return} {\cf17 true};\par
00095 {\cf21 #endif}\par
00096         {\cf19 return} {\cf17 false};\par
00097     \}\par
00098 \par
00105     {\cf18 bool} attach_left(cb_t callback_func)\{\par
00106 {\cf21 #ifndef EB_NO_CALLBACK}\par
00107         uint8_t l_r = (read_encf(E_REVERSE)) ? 0 : 1;\par
00108         {\cf19 if} (callback_func == {\cf17 nullptr} || cb[l_r]) {\cf19 return} {\cf17 false};\par
00109         cb[l_r] = *callback_func;\par
00110         {\cf19 return} {\cf17 true};\par
00111 {\cf21 #endif}\par
00112         {\cf19 return} {\cf17 false};\par
00113     \}\par
00114 \par
00115     {\cf20 //todo universal function}\par
00116     {\cf20 // void attach_call()\{\}}\par
00117 \par
00121     {\cf18 void} detach_call() \{\par
00122 {\cf21 #ifndef EB_NO_CALLBACK}\par
00123         cb[0] = {\cf17 nullptr};\par
00124         cb[1] = {\cf17 nullptr};\par
00125 {\cf21 #endif}\par
00126     \}\par
00127 \par
00134     {\cf18 void} initEnc({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00135         initEnc(e0 | (e1 << 1));\par
00136     \}\par
00137 \par
00143     {\cf18 void} initEnc(int8_t v) \{\par
00144         prev = v;\par
00145     \}\par
00146 \par
00150     {\cf18 void} clear() \{\par
00151         {\cf19 if} (read_encf(E_TRN_R)) clr_encf(E_TRN_R);\par
00152     \}\par
00153 \par
00154     {\cf20 // ====================== POLL ======================}\par
00155 \par
00161     {\cf18 bool} turn() \{\par
00162         {\cf19 return} read_encf(E_TRN_R);\par
00163     \}\par
00164 \par
00170     int8_t dir() \{\par
00171         {\cf19 return} read_encf(E_DIR) ? 1 : -1;\par
00172     \}\par
00173 \par
00182     EB_FLAGS_T action() \{\par
00183         {\cf19 switch} (flags & 0b111111111) \{\par
00184             {\cf19 case}(E_TRN_R | E_FAST):\par
00185                 {\cf19 return} EB_TURN;\par
00186             {\cf19 case}(E_TRN_R | E_DIR | E_REVERSE):\par
00187                 {\cf19 return} EB_TURN_L;\par
00188             {\cf19 case}(E_TRN_R | E_DIR):\par
00189                 {\cf19 return} EB_TURN_R;   \par
00190             {\cf19 default}:\par
00191                 {\cf19 return} EB_NONE;\par
00192         \}\par
00193     \}\par
00194 \par
00202     int8_t tickISR({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00203         {\cf19 return} tickISR(e0 | (e1 << 1));\par
00204     \}\par
00205 \par
00212     int8_t tickISR(int8_t state) \{\par
00213         state = pollEnc(state);\par
00214         {\cf19 if} (state) \{\par
00215             set_encf(E_ISR_F);\par
00216             write_encf(E_DIR, state > 0);\par
00217         \}\par
00218         {\cf19 return} state;\par
00219     \}\par
00220 \par
00228     int8_t tick({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00229         {\cf19 return} tick(e0 | (e1 << 1));\par
00230     \}\par
00231 \par
00238     int8_t tick(int8_t state) \{\par
00239         state = tickRaw(state);\par
00240         {\cf19 if} (state)\par
00241         \{\par
00242 {\cf21     #ifndef EB_NO_CALLBACK}\par
00243             {\cf19 if} (cb[0] && state < 0) cb[0]();\par
00244             {\cf19 if} (cb[1] && state > 0) cb[1]();\par
00245 {\cf21     #endif}\par
00246             {\cf19 return} state;\par
00247         \}\par
00248         clear();\par
00249         {\cf19 return} 0;\par
00250     \}\par
00251 \par
00257     int8_t tick() \{\par
00258         {\cf19 return} tick(-1);\par
00259     \}\par
00260 \par
00268     int8_t tickRaw({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00269         {\cf19 return} tickRaw(e0 | (e1 << 1));\par
00270     \}\par
00271 \par
00279     int8_t tickRaw(int8_t state) \{\par
00280         {\cf19 if} (read_encf(E_ISR_F)) \{\par
00281             clr_encf(E_ISR_F);\par
00282             set_encf(E_TRN_R);\par
00283             {\cf19 return} dir();\par
00284         \}\par
00285         {\cf19 if} ((state >= 0) && (state = pollEnc(state))) \{\par
00286             write_encf(E_DIR, state > 0);\par
00287             set_encf(E_TRN_R);\par
00288             {\cf19 return} state;\par
00289         \}\par
00290         {\cf19 return} 0;\par
00291     \}\par
00292 \par
00293     \par
00294     int8_t tickRaw() \{\par
00295         {\cf19 return} tickRaw(-1);\par
00296     \}\par
00297 \par
00305     int8_t pollEnc({\cf18 bool} e0, {\cf18 bool} e1) \{\par
00306         {\cf19 return} pollEnc(e0 | (e1 << 1));\par
00307     \}\par
00308 \par
00315     int8_t pollEnc(int8_t state) \{\par
00316         {\cf19 if} (prev != state) \{\par
00317             ecount += ((0x49941661 >> ((state | (prev << 2)) << 1)) & 0b11) - 1;\par
00318             prev = state;\par
00319             {\cf19 if} (!ecount) {\cf19 return} 0;\par
00320             {\cf19 switch} (flags & 0b11) \{\par
00321                 {\cf19 case} EB_STEP4_LOW:\par
00322                     {\cf19 if} (state != 0b11) {\cf19 return} 0;  {\cf20 // skip 00, 01, 10}\par
00323                     {\cf19 break};\par
00324                 {\cf19 case} EB_STEP4_HIGH:\par
00325                     {\cf19 if} (state) {\cf19 return} 0;  {\cf20 // skip 01, 10, 11}\par
00326                     {\cf19 break};\par
00327                 {\cf19 case} EB_STEP2:\par
00328                     {\cf19 if} (state == 0b10 || state == 0b01) {\cf19 return} 0;  {\cf20 // skip 10 01}\par
00329                     {\cf19 break};\par
00330             \}\par
00331             state = ((ecount > 0) ^ read_encf(E_REVERSE)) ? 1 : -1;\par
00332             ecount = 0;\par
00333 {\cf21 #ifndef EB_NO_COUNTER}\par
00334             counter += state;\par
00335 {\cf21 #endif}\par
00336             {\cf19 return} state;\par
00337         \}\par
00338         {\cf19 return} 0;\par
00339     \}\par
00340 \par
00341 {\cf21 #ifndef EB_NO_COUNTER}\par
00342     int32_t counter = 0;\par
00343 {\cf21 #endif}\par
00344 \par
00345     {\cf20 // ===================== PROTECTED =====================}\par
00346    {\cf17 protected}:\par
00347     {\cf17 inline} {\cf18 void} set_encf({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00348         flags |= x;\par
00349     \}\par
00350     {\cf17 inline} {\cf18 void} clr_encf({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00351         flags &= ~x;\par
00352     \}\par
00353     {\cf17 inline} {\cf18 void} write_encf({\cf17 const} uint16_t x, {\cf18 bool} v) __attribute__((always_inline)) \{\par
00354         {\cf19 if} (v) set_encf(x);\par
00355         {\cf19 else} clr_encf(x);\par
00356     \}\par
00357     {\cf17 inline} {\cf18 bool} read_encf({\cf17 const} uint16_t x) __attribute__((always_inline)) \{\par
00358         {\cf19 return} flags & x;\par
00359     \}\par
00360 \par
00361 {\cf21 #ifndef EB_NO_CALLBACK}\par
00362     cb_t cb[2] = \{{\cf17 nullptr}, {\cf17 nullptr}\}; {\cf20 // callbacks for right and left turns}\par
00363 {\cf21 #endif}\par
00364 \par
00365     {\cf20 // ===================== PRIVATE =====================}\par
00366    {\cf17 private}:\par
00367     uint8_t flags = 0;\par
00368     int8_t prev : 4;\par
00369     int8_t ecount : 4;\par
00370 \};\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
